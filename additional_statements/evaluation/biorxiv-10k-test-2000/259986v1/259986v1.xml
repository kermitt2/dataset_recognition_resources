<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.2d1 20170631//EN" "JATS-archivearticle1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" article-type="article" dtd-version="1.2d1" specific-use="production" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">BIORXIV</journal-id>
<journal-title-group>
<journal-title>bioRxiv</journal-title>
<abbrev-journal-title abbrev-type="publisher">bioRxiv</abbrev-journal-title>
</journal-title-group>
<publisher>
<publisher-name>Cold Spring Harbor Laboratory</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1101/259986</article-id>
<article-version>1.1</article-version>
<article-categories>
<subj-group subj-group-type="author-type">
<subject>Regular Article</subject>
</subj-group>
<subj-group subj-group-type="heading">
<subject>New Results</subject>
</subj-group>
<subj-group subj-group-type="hwp-journal-coll">
<subject>Bioinformatics</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>A Fast Adaptive Algorithm for Computing Whole-Genome Homology Maps</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<name>
<surname>Jain</surname>
<given-names>Chirag</given-names>
</name>
<xref ref-type="aff" rid="a1">1</xref>
<xref ref-type="aff" rid="a2">2</xref>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Koren</surname>
<given-names>Sergey</given-names>
</name>
<xref ref-type="aff" rid="a2">2</xref>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Dilthey</surname>
<given-names>Alexander</given-names>
</name>
<xref ref-type="aff" rid="a2">2</xref>
<xref ref-type="aff" rid="a3">3</xref>
</contrib>
<contrib contrib-type="author" corresp="yes">
<name>
<surname>Phillippy</surname>
<given-names>Adam M.</given-names>
</name>
<xref ref-type="aff" rid="a2">2</xref>
<xref ref-type="corresp" rid="cor1">&#x002A;</xref>
</contrib>
<contrib contrib-type="author" corresp="yes">
<name>
<surname>Aluru</surname>
<given-names>Srinivas</given-names>
</name>
<xref ref-type="aff" rid="a1">1</xref>
<xref ref-type="corresp" rid="cor1">&#x002A;</xref>
</contrib>
<aff id="a1"><label>1</label><institution>School of Computational Science and Engineering, Georgia Institute of Technology</institution>, Atlanta, GA 30332, <country>USA</country></aff>
<aff id="a2"><label>2</label><institution>Genome Informatics Section, Computational and Statistical Genomics Branch, National Human Genome Research Institute, National Institutes of Health</institution>, Bethesda, MD 20892, <country>USA</country></aff>
<aff id="a3"><label>3</label><institution>Institute of Medical Microbiology, University Hospital of D&#x00FC;sseldorf</institution>, MoorenstraBe 5, 40225 D&#x00FC;sseldorf, <country>Germany</country></aff>
</contrib-group>
<author-notes>
<corresp id="cor1"><label>&#x002A;</label>To whom correspondence should be addressed.</corresp>
</author-notes>
<pub-date pub-type="epub">
<year>2018</year>
</pub-date>
<elocation-id>259986</elocation-id>
<history>
<date date-type="received">
<day>04</day>
<month>2</month>
<year>2018</year>
</date>
<date date-type="rev-recd">
<day>04</day>
<month>2</month>
<year>2018</year>
</date>
<date date-type="accepted">
<day>05</day>
<month>2</month>
<year>2018</year>
</date>
</history>
<permissions>
<copyright-statement>&#x00A9; 2018, Posted by Cold Spring Harbor Laboratory</copyright-statement>
<copyright-year>2018</copyright-year>
<license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by/4.0/"><license-p>This pre-print is available under a Creative Commons License (Attribution 4.0 International), CC BY 4.0, as described at <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link></license-p></license>
</permissions>
<self-uri xlink:href="259986.pdf" content-type="pdf" xlink:role="full-text"/>
<abstract>
<title>Abstract</title>
<sec><title>Motivation</title><p>Whole-genome alignment is an important problem in genomics for comparing different species, mapping draft assemblies to reference genomes, and identifying repeats. However, for large plant and animal genomes, this task remains compute and memory intensive.</p>
</sec>
<sec><title>Results</title><p>We introduce an approximate algorithm for computing local alignment boundaries between long DNA sequences. Given a minimum alignment length and an identity threshold, our algorithm computes the desired alignment boundaries and identity estimates using kmer-based statistics, and maintains sufficient probabilistic guarantees on the output sensitivity. Further, to prioritize higher scoring alignment intervals, we develop a plane-sweep based filtering technique which is theoretically optimal and practically efficient. Implementation of these ideas resulted in a fast and accurate assembly-to-genome and genome-to-genome mapper. As a result, we were able to map an error-corrected whole-genome NA12878 human assembly to the hg38 human reference genome in about one minute total execution time and &#x003C; 4 GB memory using 8 CPU threads, achieving more than an orderof magnitude improvement in both runtime and memory over competing methods. Recall accuracy of computed alignment boundaries was consistently found to be &#x003E; 97&#x0025; on multiple datasets. Finally, we performed a sensitive self-alignment of the human genome to compute all duplications of length &#x2265; 1 Kbp and &#x2265; 90&#x0025; identity. The reported output achieves good recall and covers 5&#x0025; more bases than the current UCSC genome browser&#x2019;s segmental duplication annotation.</p>
</sec>
<sec>
<title>Availability</title>
<p><ext-link ext-link-type="uri" xlink:href="https://github.com/marbl/MashMap">https://github.com/marbl/MashMap</ext-link>.</p>
</sec>
<sec>
<title>Contact</title>
<p><email>adam.phillippy@nih.gov</email>, <email>aluru@cc.gatech.edu</email></p>
</sec>
</abstract>
<counts>
<page-count count="8"/>
</counts>
</article-meta>
</front>
<body>
<sec id="s1">
<label>1</label>
<title>Introduction</title>
<p>Algorithms for inferring homology between DNA sequences have undergone continuous advances for more than three decades, mainly in the direction of achieving better accuracy to compare distant genomes, as well as better compute efficiency to scale with growing data. Up until the last decade, reconstruction of a complete reference genome through sequencing and assembly was deemed a major landmark in genomics (<xref ref-type="bibr" rid="c19">Lander <italic>et al</italic>., 2001</xref>; <xref ref-type="bibr" rid="c29">Venter <italic>et al</italic>., 2001</xref>). However, it did not take long for high-throughput sequencing technologies to fuel population-wide genomics projects through low-cost genome assemblies (e.g., the Genome 10K project, <xref ref-type="bibr" rid="c10">Haussler <italic>et al</italic>., 2009</xref>). Analysis of these new diagnosis in clinical settings, requires faster algorithms for facilitating whole-genome comparisons.</p>
<p>It is well-known that computing local alignments using an exact dynamic programming algorithm at the whole-genome scale is computationally prohibitive. This bottleneck motivated the development of seed-and-extend based genome aligners. Within the seed-and-extend paradigm, the two common approaches adopted to compute exact matches are either implemented using a hash table for <italic>k</italic>-mers (e.g., <xref ref-type="bibr" rid="c1">Altschul <italic>et al</italic>., 1997</xref>; <xref ref-type="bibr" rid="c22">Ma <italic>et al</italic>., 2002</xref>; <xref ref-type="bibr" rid="c27">Schwartz <italic>et al</italic>., 2003</xref>) or suffix trees and its variants (<xref ref-type="bibr" rid="c7">Delcher <italic>et al</italic>., 1999</xref>; <xref ref-type="bibr" rid="c6">Brudno <italic>et al</italic>., 2003</xref>; <xref ref-type="bibr" rid="c5">Bray <italic>et al</italic>., 2003</xref>; <xref ref-type="bibr" rid="c30">Vyverman <italic>et al</italic>., 2013</xref>; <xref ref-type="bibr" rid="c23">Mar&#x00E7;ais G <italic>et al</italic>., 2018</xref>). A third category includes cross-correlation based algorithms (e.g., Satsumaby <xref ref-type="bibr" rid="c9">Grabherr <italic>et al</italic>., 2010</xref>). However, these approaches still remain computationally intensive. For instance, Nucmer (<xref ref-type="bibr" rid="c18">Kurtz <italic>et al</italic>., 2004</xref>) and LAST (<xref ref-type="bibr" rid="c16">Kielbasa <italic>et al</italic>., 2011</xref>), two widely used genome-to-genome aligners, require 10 or more CPU hours to align a human genome assembly to a human reference genome.</p>
<p>The primary motivation behind this work is to significantly accelerate genome-to-genome mapping while maintaining accuracy on par with sensitive aligners. We seek a problem formulation that also provides a convenient handle for users to specify how diverged the input genomes are, based on their knowledge of which organisms are being compared, expected quality of genome assembly, and sensitivity requirements of any further downstream biological analysis.</p>
<p>The inspiration behind our algorithmic strategy stems from recent developments in techniques for long-read analyses. MinHash-based estimation of Jaccard similarity of <italic>k</italic>-mer sets between DNA sequences has been adopted for state-of-the-art long read genome assembly (<xref ref-type="bibr" rid="c17">Koren <italic>et al</italic>., 2017</xref>), whole-genome distance computation (<xref ref-type="bibr" rid="c24">Ondov <italic>et al</italic>., 2016</xref>; <xref ref-type="bibr" rid="c13">Jain <italic>et al</italic>., 2017b</xref>), and long read mapping (<xref ref-type="bibr" rid="c12">Jain <italic>et al</italic>., 2017a</xref>). Through our previous work Mashmap (<xref ref-type="bibr" rid="c12">Jain <italic>et al</italic>., 2017a</xref>), we demonstrated that a MinHash-based approximate mapping algorithm can compute long-read mapping boundaries with accuracy on par with alignment-based methods, while exhibiting two orders of magnitude speedup. Mashmap operates by assuming an error-distribution model, links alignment identity to Jaccard similarity, and provides sufficient probabilistic guarantees on output sensitivity. However, this algorithm is limited to end-to-end mapping of input sequences, which makes it impractical for contig mapping or <italic>split-read</italic> mapping. Here, we introduce new algorithmic strategies to compute local alignment boundaries for both whole-genome and split-read mapping applications.</p>
<p>Given minimum identity and length requirements for local alignments, we formulate the characteristics of output we intend to compute. Our new algorithm internally makes use of our previous end-to-end approximate read mapping framework (<xref ref-type="bibr" rid="c12">Jain <italic>et al</italic>., 2017a</xref>) by applying it to nonoverlapping substrings of the query sequence. We mathematically show that all valid local alignment boundaries, which satisfy the user-specified alignment identity and length thresholds are reported, with high probability. Further, we formulate a heuristic to prioritize mappings with higher scores. We leverage the classic plane-sweep technique from computational geometry to develop an <italic>O</italic>(<italic>n</italic> log <italic>n</italic>) algorithm to solve the filtering problem, with n being the count of total mappings.</p>
<p>We demonstrate the practical utility of our algorithm Mashmap2 by evaluating accuracy and computational performance using real data instances, which include mapping human genome assemblies and ultra-long reads to the human reference genome, and sensitive self-alignment analysis of the human genome. We compared the performance of Mashmap2 against a recent fast alignment-free method Minimap2 (<xref ref-type="bibr" rid="c20">Li, 2017</xref>) and the widely used alignment-based method Nucmer (<xref ref-type="bibr" rid="c18">Kurtz <italic>et al</italic>., 2004</xref>). Mashmap2 operates in about a minute and 4 GB memory, including both indexing and mapping stages, to map human genome assembly to a reference when given minimum alignment identity and length requirements of 95&#x0025; and 10 Kbp respectively. This makes it the fastest software for genome-to-genome mapping with an order of magnitude improvement in execution time and memory-usage. This performance is achieved while maintaining output sensitivity percentage in the high 90s. We also demonstrate its ability to compute all &#x2265;1 Kbp long segmental duplications in the human genome with high accuracy. We expect the performance and sensitivity guarantees provided by our algorithm will allow fast evaluation of draft assemblies versus a reference genome, scalable construction of whole-genome homology maps, and rapid split-read mapping of long reads to large reference databases.</p>
</sec>
<sec id="s2">
<label>2</label>
<title>The Mashmap2 Algorithm</title>
<p>We designed Mashmap2 to enable fast computation of homology maps between two sequences or a sequence and itself. It consists of two algorithmic components. The first computes approximate boundaries and alignment scores for all pairs of substrings that exceed a user specified length and identity threshold. The second applies a novel filtering algorithm to optionally weed out redundant, paralogous mappings.</p>
<sec id="s2a">
<label>2.1</label>
<title>Computing Local Alignment Boundaries</title>
<p>Consider all local mappings of the form <italic>Q</italic>[<italic>i&#x0324;j</italic>] between sequences <italic>Q</italic> (query) and <italic>R</italic> (reference) of length <italic>l</italic><sub>0</sub> or more, such that <italic>Q</italic>[<italic>i&#x0324;j</italic>] aligns with a substring of R with per-base error-rate &#x2264; &#x03F5;<sub>max</sub> and |<italic>j</italic> &#x2014; <italic>i</italic> &#x002B; 1| &#x2265; <italic>l</italic><sub>o</sub>. Alignment algorithms have quadratic time complexity, therefore an exact evaluation of the local mappings between all possible substring combinations will require <italic>O</italic>(| <italic>Q</italic> |<sup>3</sup>|R |<sup>3</sup>) time. As such, solving this problem exactly is computationally prohibitive for typical sizes of real datasets. Instead of explicitly computing all such structures, we seek at least one seed mapping of length <italic>l</italic><sub>0</sub>/2 along the path of each optimal alignment. Doing so, while maintaining high sensitivity and sufficient specificity will allow computation of the local alignments efficiently using an appropriate alignment algorithm.</p>
<p>In our approach, we leverage our previous alignment-free end-to-end read mapping algorithm, designed for mapping noisy long reads (<xref ref-type="bibr" rid="c12">Jain <italic>et al.</italic>, 2017a</xref>). This allows us to benefit from its attractive properties including probabilistic guarantees on quality, and algorithmic and space efficiency. We continue to assume the same error model that was used in this work, also restated here. We assume that alignment errors, i.e, substitutions and indels in a valid alignment occur independently and follow a Poisson distribution. We also simplify by assuming that k-mers are independent entities in sequences. For a given per-base error rate threshold <italic>&#x03F5;</italic><sub><italic>max</italic></sub>, the read-mapping algorithm reports all target mapping coordinates and identity estimates of a read in the reference, where it aligns end-to-end with &#x2264; <italic>&#x03F5;</italic><sub><italic>max</italic></sub> per-base error rate, with high probability. This is achieved by linking Jaccard coefficient between the fc-mer spectra of the read and its mapping region to the alignment-error rate, under the assumed error distribution model.</p>
</sec>
<sec id="s2e"><title>Proposed Algorithm</title>
<p>We first split the query sequence <italic>Q</italic> into <italic>l</italic><sub>0</sub>/2 sized non-overlapping fragments. If a substring of <italic>Q</italic>, say <italic>Q</italic><sub><italic>sub</italic></sub>, of length &#x2265; <italic>l</italic><sub>0</sub> aligns against a substring of <italic>R</italic> with <italic>&#x03F5;</italic> &#x2264; <italic>&#x03F5;</italic><sub><italic>max</italic></sub> per-base error rate, then there is at least one <italic>l</italic><sub>0</sub> /2 sized fragment that maps end-to-end along the optimal alignment path with &#x03F5; &#x00B7; <italic>l</italic><sub>0</sub>/2 expected errors. Accordingly, the read mapping routine in Mashmap can be used to map each fragment with <italic>e</italic><sub><italic>max</italic></sub> error-rate cutoff. Note that at least <inline-formula><alternatives><inline-graphic xlink:href="259986_inline1.gif"/></alternatives></inline-formula> query fragments completely span <italic>Q</italic><sub><italic>sub</italic></sub> (<xref ref-type="fig" rid="fig1">Figure 1</xref>). Let <italic>p</italic> be the probability that a fragment is mapped to the desired target position on the reference, computed as described by <xref ref-type="bibr" rid="c12">Jain <italic>et al.</italic> (2017a</xref>). Probability of reporting at least one seed mapping along the optimal alignment is given by <inline-formula><alternatives><inline-graphic xlink:href="259986_inline2.gif"/></alternatives></inline-formula>. We show that these probability scores are sufficiently high, between 0.92 and 1.00 for alignment error rate thresholds <italic>&#x03F5;</italic><sub><italic>max</italic></sub> 10&#x0025; and 20&#x0025; respectively (<xref ref-type="fig" rid="fig2">Figure 2</xref>).</p>
<fig id="fig1" position="float" orientation="portrait" fig-type="figure">
<label>Fig. 1.</label>
<caption><p>A local alignment depicting the inclusion of a length <italic>l</italic><sub>o</sub>/2 fragment of the query sequence.</p></caption>
<graphic xlink:href="259986_fig1.tif"/>
</fig>
<fig id="fig2" position="float" orientation="portrait" fig-type="figure">
<label>Fig. 2.</label>
<caption><p>Probability of mapping at least one seed fragment for two different error-rate thresholds &#x03F5;<sub><italic>max</italic></sub> = 10&#x0025;, 20&#x0025;. As true error rate &#x03F5; decreases, the probability values accordingly improve as expected. Similarly, longer alignments spanning more fragments are more likely to be reported. Most importantly, all the sensitivity scores are consistently above 90&#x0025;. To compute the probability values, sketch size for Minhash based Jaccard estimation was assumed as 200, and the <italic>k</italic>-mer size was set to 16. These parameters are internally set by Mashmap (<xref ref-type="bibr" rid="c12">Jain et al., 2017a</xref>).</p></caption>
<graphic xlink:href="259986_fig2.tif"/>
</fig>
<p>The above seed matches and their alignment identity estimates are further processed to compute approximate local boundaries and their scores. After computing all seed matches, matches which involve consecutive query sequence fragments are merged together if they are mapped closely in the same order on the reference sequence. Suppose mappings from the consecutive query fragments <italic>q</italic><sub><italic>i</italic></sub>,<italic>q</italic><sub><italic>i</italic>&#x002B;1</sub>,&#x2026;, <italic>q</italic><sub><italic>j</italic></sub> are mapped to reference positions with begin positions <italic>p</italic><sub>0</sub>, <italic>p</italic><sub>1</sub>,&#x2026;, <italic>P</italic><sub><italic>j-i</italic></sub> respectively, then they are grouped together as a local alignment segment if <inline-formula><alternatives><inline-graphic xlink:href="259986_inline3.gif"/></alternatives></inline-formula>, and <inline-formula><alternatives><inline-graphic xlink:href="259986_inline4.gif"/></alternatives></inline-formula>. The alignment boundaries are estimated as the first and last mapping offsets of the group. The corresponding alignment scores are estimated as their average identity estimate multiplied by the sum of the fragment lengths. We use these alignment boundaries and the scores as input to a subsequent filtering algorithm.</p>
</sec>
<sec id="s2b">
<label>2.2</label>
<title>A Geometric Algorithm for Filtering Alignments</title>
<p>Large mammalian genomes and plant genomes have abundant repetitive sequences. As a consequence, a large fraction of inferior mappings are reported due to paralogous genomic segments or false positive mappings resulting from simple sequence repeats. Furthermore, from a biological perspective, closely examining all alternative mappings may not be feasible. Therefore, different strategies are adopted to identify biologically relevant outputs. We formulate a filtering heuristic for our mapping application, and develop an optimal <italic>O</italic>(<italic>n</italic> log <italic>n</italic>) algorithm to solve it. We also prove that &#x03A9;(<italic>&#x03B7;</italic> log <italic>n</italic>) runtime is necessary to solve this problem. The effectiveness of this algorithm on real genomic data is demonstrated later, in the Results section.</p>
<sec id="s2b1">
<label>2.2.1</label>
<title>Problem Formulation</title>
<p>Suppose all output mappings of a query sequence are laid out as weighted segment intervals, with the alignment scores used as weights (<xref ref-type="fig" rid="fig3">Figure 3</xref>). We propose the following filtering heuristic: a segment is termed redundant if and only if it is subsumed by higher scoring segments at all of its positions. In practice, there can be multiple alignments with equal scores. Therefore, segment scores are allowed to be non-unique.</p>
<fig id="fig3" position="float" orientation="portrait" fig-type="figure">
<label>Fig. 3.</label>
<caption><p>Left figure is a toy example to illustrate line segments corresponding to multiple local alignments obtained between query and reference sequence, similar to a dot-plot. Each alignment segment is labeled with an alignment score. Now, suppose we wish to filter best mappings for the query sequence. These segments can be considered as weighted intervals over the query sequence (right figure). In the above case, two intervals marked with a cross are completely subsumed by higher scoring intervals, and therefore, will be labeled as redundant by our filtering heuristic.</p></caption>
<graphic xlink:href="259986_fig3.tif"/>
</fig>
<p>A sub-optimal <italic>O</italic>(<italic>n</italic><sup>2</sup>) algorithm for solving the above problem can be readily developed by doing an all to all comparison among the segments. However, it would lead to practically slow implementation for typical input sizes. The formulated filtering problem bears resemblance to the line segment intersection test problem for which <xref ref-type="bibr" rid="c28">Shamos and Hoey (1976)</xref> gave a classic <italic>O</italic>(<italic>n</italic> log <italic>n</italic>) algorithm using plane-sweep technique. Accordingly, we summarize their algorithm next, and subsequently describe the modifications made to solve the above filtering problem.</p>
</sec>
<sec id="s2b2">
<label>2.2.2</label>
<title>The Shamos-Hoey Algorithm</title>
<p>Similar to the filtering problem, the problem of detecting whether n segments have an intersecting pair has a trivial <italic>O</italic>(<italic>n</italic><sup>2</sup>) solution. Shamos and Hoey solved this problem using a plane-sweep based <italic>O</italic>(<italic>n</italic> log <italic>n</italic>) algorithm. The algorithm defines an ordering between segments in the 2D plane. The main loop of the algorithm conceptually <italic>sweeps</italic> a vertical line from left to right, and while doing so, the sweep-line status data-structure <inline-formula><alternatives><inline-graphic xlink:href="259986_inline5.gif"/></alternatives></inline-formula> dynamically holds segments which intersect the sweep-line. The sweep-line halts at 2n endpoints of the input segments, and the order of segments in <inline-formula><alternatives><inline-graphic xlink:href="259986_inline6.gif"/></alternatives></inline-formula> is evaluated to detect any intersection. For efficiency, this algorithm chooses a balanced tree to implement the sweep-line status <inline-formula><alternatives><inline-graphic xlink:href="259986_inline7.gif"/></alternatives></inline-formula>. As such, it spends <italic>O</italic>(log <italic>n</italic>) time at each halting point, and therefore, the total runtime is bounded by <italic>O</italic>(<italic>n</italic> log <italic>n</italic>). This algorithm is popular not only for its theoretical and practical efficiency, but also for ease of implementation.</p>
<p>In our problem as well, evaluating segments which intersect the vertical sweep-line at 2<italic>n</italic> endpoints is sufficient to identify all <italic>good</italic> (non-redundant) segments. However, evaluating all intersecting segments at each endpoint is inefficient, and again leads to a quadratic algorithm. Therefore, we devise a new ordering scheme among segments which will enable us to evaluate only a subset of intersecting segments at each endpoint to bound the runtime.</p>
</sec>
<sec id="s2b3">
<label>2.2.3</label>
<title>Proposed Algorithm for Alignment Filtering</title>
<p>The Shamos-Hoey algorithm requires several modifications for solving the filtering problem. We define an order between segments as following: Between two segments, the segment with higher score is considered as greater, but if the scores are equal, then the segment with the larger starting position is considered as greater. This particular ordering helps avoid redundant computations, and will be crucial for bounding the runtime later.</p>
<p>Similar to the Shamos-Hoey algrithm, we also use a height-balanced Binary Search Tree (BST) as the data-structure for the sweep-line status <inline-formula><alternatives><inline-graphic xlink:href="259986_inline8.gif"/></alternatives></inline-formula>, which tracks the segments that intersect the vertical sweep line. <inline-formula><alternatives><inline-graphic xlink:href="259986_inline9.gif"/></alternatives></inline-formula> is required to support the following operations in our algorithm:
<list list-type="order">
<list-item><p><italic>insert</italic>(<italic>s</italic>). Insert segment s into <inline-formula><alternatives><inline-graphic xlink:href="259986_inline10.gif"/></alternatives></inline-formula></p></list-item>
<list-item><p><italic>delete</italic>(<italic>s</italic>). Delete segment s from <inline-formula><alternatives><inline-graphic xlink:href="259986_inline11.gif"/></alternatives></inline-formula>.</p></list-item>
<list-item><p><italic>mark_good</italic>(). Mark all segments with highest score as good in <inline-formula><alternatives><inline-graphic xlink:href="259986_inline12.gif"/></alternatives></inline-formula>.</p></list-item>
</list>
</p>
<p>Note that the <italic>insert</italic> and <italic>delete</italic> operations are naturally supported in <italic>O</italic>(logn) time in BSTs, whereas the <italic>mark_good</italic> function can be realized as a sequence of <italic>maximum</italic> and <italic>predecessor</italic> operations. If there are <italic>k</italic> segments with equal and highest scores in <inline-formula><alternatives><inline-graphic xlink:href="259986_inline13.gif"/></alternatives></inline-formula>, the function <italic>mark_good</italic> uses <italic>O</italic>(<italic>k</italic> log <italic>n</italic>) time. With the data-structures and the operations defined above, we give an outline of the complete filtering procedure in Algorithm 1. The main loop of the algorithm iterates over the 2<italic>n</italic> segment endpoints, which is analogous to the sweep line moving from left to right, halting at the 2<italic>n</italic> points. In each iteration, we update the sweep-line status <inline-formula><alternatives><inline-graphic xlink:href="259986_inline14.gif"/></alternatives></inline-formula> so that it holds the segments which intersect the sweep line, and mark the highest-scoring segments as <italic>good</italic> using the <italic>mark_good</italic> function.</p>
<statement>
<label>Lemma 1.</label>
<p><italic>Algorithm 1 solves the filtering problem correctly.</italic></p>
<p>Proof. Consider a function <italic>S</italic>: &#x2115; &#x2192; {0,1}<sup><italic>N</italic></sup> from positions in the query sequence to subsets of segments {1, 2,&#x2026;, <italic>N</italic>}. A segment <italic>s</italic><sub><italic>i</italic></sub> <italic>&#x2208;</italic> {<italic>S</italic>(<italic>pos</italic>)} if and only if it is among the highest scoring segments which overlap with the query sequence at position <italic>pos</italic>. Clearly, a union of all subsets in the domain of function S equals the set of <italic>good</italic> segments. If we perform a linear scan on the domain, from begin to end position of the query sequence, then value of S can change only at the 2<italic>n</italic> endpoints of the segments. Therefore, the highest scoring segments overlapping at the 2n endpoints constitute the set of <italic>good</italic> segments, which is precisely what Algorithm 1 computes.&#x25A1;</p>
</statement>
<statement><label>Algorithm 1:</label>
<p>Plane-sweep based alignment filtering algorithm
<fig id="ufig1" position="float" orientation="portrait" fig-type="figure">
<graphic xlink:href="259986_ufig1.tif"/>
</fig></p>
</statement>
<p>We make a minor modification to the above described algorithm for efficiency, specifically in the <italic>mark_good</italic> function. In this function, we mark the highest scoring segments in the tree <inline-formula><alternatives><inline-graphic xlink:href="259986_inline15.gif"/></alternatives></inline-formula> as <italic>good</italic>. We execute this by traversing the segments in decreasing order in <inline-formula><alternatives><inline-graphic xlink:href="259986_inline16.gif"/></alternatives></inline-formula>, starting from the maximum. However, we terminate the traversal if a segment is observed as marked <italic>good</italic> already. This helps avoid redundant computations, and the algorithm still remains correct due to the following property:</p>
<statement>
<label>Lemma 2.</label>
<p><italic>Consider all the segments with equal and highest scores in</italic> <inline-formula><alternatives><inline-graphic xlink:href="259986_inline17.gif"/></alternatives></inline-formula>: <italic>s</italic><sub>1</sub>, <italic>s</italic><sub>2</sub>,&#x2026;, <italic>s</italic><sub><italic>j</italic></sub>,&#x2026;, <italic>s</italic><sub><italic>k</italic></sub>, <italic>ordered in non-increasing manner. Suppose segment sj has been marked good in one of the previous iterations of the algorithm, then the segments s</italic><sub><italic>j</italic>&#x002B;1</sub>, <italic>s</italic><sub><italic>j</italic>&#x002B;2</sub>,&#x2026; <italic>s</italic><sub><italic>k</italic></sub> <italic>must have already been marked good as well</italic>.</p>
<p>Proof. The aforementioned property is satisfied by default during the first iteration of the algorithm because there cannot be any previously marked segments. Suppose this property remains true till iteration <italic>i</italic>, and we are currently executing iteration <italic>i</italic> &#x002B;1. Segments <italic>s</italic><sub>1</sub>, <italic>s</italic><sub>2</sub>,&#x2026; <italic>s</italic><sub><italic>k</italic></sub> &#x2208; <inline-formula><alternatives><inline-graphic xlink:href="259986_inline18.gif"/></alternatives></inline-formula>, so we know that the sweep line intersects these segments. Also, the ordering of the segments is maintained based on their scores and begin positions, and since the scores of these segments are equal, therefore <italic>begin_pos</italic>(<italic>s</italic><sub>1</sub>) &#x2265; <italic>begin_pos</italic>(<italic>s</italic><sub>2</sub>) &#x2265;&#x2026; &#x2265; <italic>begin_pos</italic>(<italic>s</italic><sub><italic>k</italic></sub>). Now consider the iteration when segment <italic>s</italic><sub><italic>j</italic></sub> was marked <italic>good</italic>. Then, the sweep line must have intersected the segments <italic>s</italic><sub><italic>j</italic>&#x002B;1</sub>, <italic>s</italic><sub><italic>j</italic>&#x002B;2</sub>,&#x2026; <italic>s</italic><sub><italic>k</italic></sub> as well. Therefore, if the segment <italic>s</italic><sub><italic>j</italic></sub> was marked, then the segments <italic>s</italic><sub><italic>j</italic>&#x002B;1</sub>, <italic>s</italic><sub><italic>j</italic>&#x002B;2</sub>,&#x2026; <italic>s</italic><sub><italic>k</italic></sub> must have been marked within or before the same iteration.&#x25A1;</p>
</statement>
<p>The total cost of sorting, <italic>insert</italic> and <italic>delete</italic> operations in Algorithm 1 is clearly <italic>O</italic>(<italic>n</italic> log <italic>n</italic>). Because the revised <italic>mark_good</italic> function marks at most <italic>n</italic> segments throughout the algorithm, its runtime is also bounded by <italic>O</italic>(<italic>n</italic> log <italic>n</italic>). Thus, we conclude that the runtime complexity of our alignment filtering algorithm is bounded by <italic>O</italic>(<italic>n</italic> log <italic>n</italic>) which is restated as a theorem below.</p>
<statement>
<label>Theorem 1.</label>
<p><italic>Given n alignment segments, Algorithm 1 solves the alignment filtering problem in O</italic>(<italic>n</italic> log <italic>n</italic>) <italic>time</italic>.</p>
</statement>
<statement>
<label>Theorem 2.</label>
<p><italic>The above proposed filtering algorithm is optimal</italic>.</p>
<p>Proof. The INTEGER ELEMENT UNIQUENESS problem (given <italic>n</italic> integers, decide whether they are all unique) is known to have a lower bound of &#x03A9;(<italic>n</italic> log <italic>n</italic>) assuming the algebraic decision-tree model (<xref ref-type="bibr" rid="c21">Lubiw and R&#x00E1;cz, 1991</xref>). A simple transformation can be designed to show that</p>
<p>INTEGER ELEMENT UNIQUENESS &#x221D;<sub><italic>N</italic></sub> ALIGNMENT FILTERING</p>
<p>Let {<italic>x</italic><sub>1</sub>, <italic>x</italic><sub>2</sub>,&#x2026;,<italic>x</italic><sub>n</sub>} be a set of <italic>n</italic> integer elements. For each element <italic>x</italic><sub><italic>i</italic></sub>, construct a segment with begin position, end position, and score as <italic>x</italic><sub><italic>i</italic></sub>, <italic>x</italic><sub><italic>i</italic></sub>, and <italic>i</italic> respectively. Because each segment is assigned a unique score, all the <italic>n</italic> elements are unique if and only if the filtering algorithm reports all the segments as <italic>good</italic>.&#x25A1;</p>
</statement>
</sec>
</sec>
<sec id="s2c">
<label>2.3</label>
<title>Related Work for Filtering Alignments</title>
<p>There can be many alternative formulations of the filtering criteria. For instance, BLAST (<xref ref-type="bibr" rid="c1">Altschul <italic>et al</italic>., 1997</xref>) filters out alignments if they are fully contained in &#x2265; <italic>K</italic> alignments of higher scores (<xref ref-type="bibr" rid="c4">Berman <italic>et al</italic>., 1999</xref>). Berman <italic>et al</italic>. also discussed a weaker alternative filtering condition where a match is filtered out if each position in a segment is covered by &#x2265; <italic>K</italic> segments of higher score. Note that our filtering formulation is its special case with <italic>K</italic> =1. They discussed a different <italic>O(n</italic> logn) algorithm to solve the problem based on interval-tree of all input segments. Although a direct performance comparison is not possible due to unavailability of their implementation, note that the tree size in our plane-sweep based algorithm is limited by the number of overlapping segments which intersect the vertical sweep-line, which can be (and typically is) orders of magnitude smaller than the total count for large datasets. As such, even with the same theoretical complexity, we expect our algorithm to perform faster with less memory usage in practice.</p>
</sec>
<sec id="s2d">
<label>2.4</label>
<title>Execution for Mapping Applications</title>
<p>The above filtering criteria is useful to identify the promising alignments between query and reference genomes. For the genome-to-genome mapping application, we execute the filtering algorithm twice, once to filter best alignments for query sequence, followed by filtering best alignments for reference sequence. Mappings which pass both filters constitute the orthologous matches, required for building a one-to-one homology map. For read mapping however, filtering on just the query sequence is appropriate. Accordingly, Mashmap2 provides two filtering modes: one-to-one and map for the two applications respectively.</p>
</sec>
</sec>
<sec id="s3">
<label>3</label>
<title>Results</title>
<p>We assess the performance of Mashmap2 for genome-to-genome and split-read mapping in comparison to recent versions of state-of-the-art software Minimap2 (<xref ref-type="bibr" rid="c20">Li, 2017</xref>) and Nucmer (<xref ref-type="bibr" rid="c23">Mar&#x00E7;ais G <italic>et al</italic>., 2018</xref>). Results indicate that Mashmap2 provides output of comparable quality, and can yield more than an order of magnitude gain in run-time and memory-usage. Subsequently, we demonstrate the utility of Mashmap2 in accurately computing all 1 Kbp long duplications in the human genome.</p>
<sec id="s3a">
<label>3.1</label>
<title>Genome-to-Genome Mapping</title>
<sec id="s3a1">
<label>3.1.1</label>
<title>Datasets</title>
<p>To evaluate and compare Mashmap2 for mapping genome assemblies, we used four datasets D1-D4 listed in <xref ref-type="table" rid="tbl1">Table 1</xref>. Dataset D1 includes comparison between microbial genomes E. <italic>cali</italic> O157:H7 and E. <italic>cali</italic> K12. The two instances D2 and D3 require mapping of NA12878 human reference genome assemblies to the hg38 human reference genome. Query genome assemblies in both instances D2 and D3 are the recently published assemblies by Canu (<xref ref-type="bibr" rid="c17">Koren <italic>et al</italic>.,2017</xref>) using ultra-long Oxford Nanopore Technology (ONT) reads (<xref ref-type="bibr" rid="c14">Jain <italic>et al</italic>., 2017c</xref>). Dataset D3 includes a long-read only Canu assembly whereas assembly in dataset D2 is also error-corrected using Illumina reads. Additionally, to evaluate Mashmap2 for the split-read mapping task, D4 includes ultra-long human ONT reads, generated using a single flowcell (<xref ref-type="bibr" rid="c14">Jain <italic>et al</italic>., 2017c</xref>).</p>
<table-wrap id="tbl1" orientation="portrait" position="float">
<label>Table 1.</label>
<caption><p>List of datasets used for evaluation. Datasets D1-D3 are included to evaluate Mashmap2 for genome-to-genome mapping application, and D4 for long read mapping application. We discarded a small fraction of contigs and reads which were shorter than 10 Kbp.</p></caption>
<graphic xlink:href="259986_tbl1.tif"/>
</table-wrap>
</sec>
<sec id="s3a2">
<label>3.1.2</label>
<title>Defining Baseline and Methodology</title>
<p>For the purpose of evaluating output accuracy, we used MUMmer package (v4.0.0.beta2), which includes the Nucmer4 alignment program for comparing DNA sequences (<xref ref-type="bibr" rid="c23">Mar&#x00E7;ais G <italic>et al</italic>., 2018</xref>). Nucmer4 is sensitive enough to report alignments for both assembly and read mapping tasks, therefore we considered its output as truth while evaluating accuracy. Note that computing truth using an exact alignment algorithm is not feasible for the datasets used. We also used Minimap2 (v2.7-r659) (<xref ref-type="bibr" rid="c20">Li, 2017</xref>) as a baseline for various performance metrics. Minimap2 executes chaining algorithm on fixed-length exact matches to compute alignment boundaries. To our knowledge, it is among the fastest tools available to map DNA sequences in an alignment-free fashion.</p>
<p>Each software, including ours exposes many parameters (e.g., <italic>k</italic>-mer or seed length). Default <italic>k</italic>-mer size in Mashmap2 is 16. We mostly conform to default parameters with all software tested, except as noted below. Mashmap2 mainly requires a minimum length and identity for the desired local alignments. In this analysis, we targeted long alignments, and accordingly fixed the minimum alignment length requirement as 10 Kbp. We set the minimum alignment identity requirement for the four datasets based on their input characteristics as {D1: 95&#x0025;, D2: 95&#x0025;, D3: 90&#x0025;, D4: 85&#x0025;}. Accordingly, we tested Mashmap2 for reporting the alignment boundaries as per the provided requirements. Filtering modes were set to <monospace>one-to-one</monospace> and <monospace>map</monospace> for datasets D1-D3 and D4 respectively. Nucmer4 was run with default parameters, followed by running <italic>delta-filter</italic>, both components of the MUMmer package. Following its user documentation, <italic>delta-filter</italic> was executed with-1 parameter to construct one-to-one alignment map in datasets D1-D3 and <monospace>-q</monospace> parameter for read mapping in D4. Finally, Minimap2 supports genome-to-genome mapping mode using <monospace>-x asm5</monospace> flag, and nanopore read mapping mode using <monospace>-x map-ont</monospace>. We executed all three software in multi-threaded mode using 8 CPU threads. All comparisons were done on an Intel Xeon E5-2680 platform with 28 physical cores and 256 GB RAM.</p>
</sec>
<sec id="s3a3">
<label>3.1.3</label>
<title>Runtime and Memory Usage</title>
<p>The wall-clock runtime and memory-usage of Mashmap2, Minimap2 and Nucmer4 using datasets D1-D4 are shown in <xref ref-type="table" rid="tbl2">Table 2</xref>. The runtimes represent end-to-end time, from reading input sequences to generating the final output. Minimap2 can report base-to-base alignments but does not by default. Thus, the final output of Mashmap2 and Minimap2 are alignment boundaries and scores, whereas Nucmer4 outputs base-to-base alignments. We observe that Mashmap2 used significantly less time and an order of magnitude less memory than Minimap2 for datasets D1-D3. It achieves 1.6x, 26x, 5.4x speedups, and improves memory-usage by 7.1x, 14x, 11x for the three datasets respectively. The improvement gap against Nucmer4 is even wider. Mashmap2 can also be used for mapping long reads, although performance gains are not as dramatic. Compared to Minimap2, Mashmap2 improves runtime and memory-usage by 36&#x0025; and 50&#x0025; respectively on dataset D4. Minimap2 is well tuned for mapping nanopore reads, and therefore achieves competitive performance.</p>
<table-wrap id="tbl2" orientation="portrait" position="float">
<label>Table 2.</label>
<caption><p>Total execution time and memory usage comparison of Mashmap2 against Minimap2 and alignment-based tool Nucmer4. All software were run in parallel using 8 CPU threads.</p></caption>
<graphic xlink:href="259986_tbl2.tif"/>
</table-wrap>
<p>The primary contributors to the performance obtained by Mashmap2 are its efficient mechanism to estimate Jaccard similarity and auto-tuning of the internal parameters (e.g., <italic>k</italic>-mer sampling rate, Jaccard similarity threshold) based on the local alignment identity and length requirements provided by user. These results demonstrate that auto-tuning can help achieve faster performance with increasing identity and length thresholds. It is also intuitive to expect better performance on dataset D2 than D3 because the error-rate of input sequences in D2 is lower due to the error-correction using Illumina reads. Based on results of <xref ref-type="bibr" rid="c14">Jain <italic>et al</italic>. (2017c</xref>), the error-correction phase improved average alignment identity from 95&#x0025; to 99.3&#x0025; <italic>w.r.t</italic>. the hg38 reference. The competing methods, however, do not follow this trend (<xref ref-type="table" rid="tbl2">Table 2</xref>). The parameters for fc-mer sampling in Minimap2 can be tuned manually to achieve better runtime for these datasets, but it does not provide minimum length and identity threshold parameters like Mashmap2. It is important to maintain high accuracy while being fast, therefore we next evaluate the quality of output.</p>
</sec>
<sec id="s3a4">
<label>3.1.4</label>
<title>Accuracy</title>
<p>Accuracy evaluation of Mashmap2 and Minimap2 in comparison with alignments produced by Nucmer4 is shown in <xref ref-type="table" rid="tbl3">Table 3</xref>. Recall was measured against Nucmer4 output alignments which satisfy the alignment requirements in terms of minimum length and identity provided to Mashmap2. We also expected Minimap2 to report these alignments because it is designed to compute matches in these identity ranges.</p>
<table-wrap id="tbl3" orientation="portrait" position="float">
<label>Table 3.</label>
<caption><p>Accuracy evaluation of Mashmap2 and Minimap2 to do an alignment-free computation of mapping boundaries. Recall was measured while assuming Nucmer4 output alignments as truth.</p></caption>
<graphic xlink:href="259986_tbl3.tif"/>
</table-wrap>
<p>A reported local alignment boundary estimate by Mashmap2 or Minimap2 was assumed to recall a Nucmer4 alignment if it overlapped with the alignment on both query and reference sequences, and if the mapping strand matched. From <xref ref-type="table" rid="tbl3">Table 3</xref>, we observe that both Mashmap2 and Minimap2 consistently achieved high recall scores, with Minimap2 performing slightly better. Obtaining high recall scores by itself is not sufficient, because it can be achieved by mapping a query sequence to all possible positions. In parallel to achieving high recall scores, both Mashmap2 and Minimap2 mapped a large fraction of query genome assemblies to unique mapping positions in the reference genomes. To show this, we computed the fraction of base-pairs of the query sequence that are mapped to a single position on the reference genome (<xref ref-type="table" rid="tbl3">Table 3</xref>). Finally, Mashmap2 provides a script to visualize its output as dot-plots, similar to MUMmerplot. These dot-plots when visually inspected, appeared similar to Nucmer4&#x2019;s output. Here we show homology maps computed by Mashmap2 using datasets D1 and D2 (<xref ref-type="fig" rid="fig4">Figure 4</xref>).</p>
<fig id="fig4" position="float" orientation="portrait" fig-type="figure">
<label>Fig. 4.</label>
<caption><p>Dot plots for genome to genome mappings for datasets D1 and D2 generated using Mashmap2. Mashmap2 supports visualization using MUMmerplot tool, modified to be compatible with its output format.</p></caption>
<graphic xlink:href="259986_fig4.tif"/>
</fig>
</sec>
<sec id="s3a5">
<label>3.1.5</label>
<title>Efficacy of The Filtering Algorithm</title>
<p>Eukaryotic genomes tend to contain a lot of repetitive sequences, therefore, the motivation behind our plane-sweep based filtering heuristic is to discard noisy mappings, and compute promising matches between the query and reference genomes. We show the importance and effectiveness of our filtering strategy in <xref ref-type="table" rid="tbl4">Table 4</xref>. Note that a large fraction of mappings was pruned out by the filter. While doing so, high recall scores against Nucmer4 alignments were maintained (see <xref ref-type="table" rid="tbl4">Table 4</xref>). Although we do not present the contribution of this phase to the total runtime, our plane-sweep algorithm is fast in practice; it used an insignificant fraction of the total runtime.</p>
<table-wrap id="tbl4" orientation="portrait" position="float">
<label>Table 4.</label>
<caption><p>Effectiveness of the filtering algorithm in Mashmap2. A large fraction of mappings were filtered out by the algorithm, while the recall scores against the Nucmer4 alignments remained largely unaffected. Last column in this table is copied from <xref ref-type="table" rid="tbl3">Table 3</xref> for convenience.</p></caption>
<graphic xlink:href="259986_tbl4.tif"/>
</table-wrap>
</sec>
</sec>
<sec id="s3b">
<label>3.2</label>
<title>Computing Duplications in the Human Genome</title>
<p>Soon after the publication of the human genome, it was realized that the genome is replete with repetitive sequences (<xref ref-type="bibr" rid="c11">International Human Genome Sequencing Consortium, 2004</xref>). Intra- and inter-chromosomal duplications have been found to play a vital role in genome evolution, its stability, and diseases (<xref ref-type="bibr" rid="c8">Emanuel and Shaikh, 2001</xref>), and knowing the location of such repeats can be important for many genomic analyses. Yet, fully annotating all repeats in a genome can be computationally intensive. To demonstrate the scalability of Mashmap2, we computed all &#x2265; 1 Kbp duplications in the human genome (GRCh38, <xref ref-type="bibr" rid="c26">Schneider <italic>et al</italic>., 2017</xref>) with &#x2265; 90&#x0025; alignment identity. Due to probabilistic guarantees, we expect Mashmap2 to estimate the boundaries of all such duplications with a high recall value. The importance of these duplications has been known for a long time (<xref ref-type="bibr" rid="c8">Emanuel and Shaikh, 2001</xref>; <xref ref-type="bibr" rid="c3">Bailey <italic>et al</italic>., 2002</xref>); accordingly the UCSC genome browser (<xref ref-type="bibr" rid="c15">Kent <italic>et al</italic>., 2002</xref>) also maintains them in a database (named as segmental duplications) for the human genome. We summarize our method below and contrast our output with this database.</p>
<sec id="s3b1">
<label>3.2.1</label>
<title>Methodology</title>
<p>We used 24 chromosome sequences (1-22, X,Y) and mitochondrial DNA from the hg38 version of the human genome as our input sequence set. To compute all &#x2265; 1 Kbp, &#x2265;90&#x0025; identity duplications, we executed Mashmap2 with the same length and identity requirements, with filtering disabled. Mashmap2 reported 8.4 billion alignment boundaries for all duplications after finishing its run. The count of reported mappings is high due to several high-copy repeat families in the genome, not all of which exceed our minimum thresholds. To remove the shorter or lower identity mappings, each of the approximate alignments was processed using LAST (<xref ref-type="bibr" rid="c16">Kielbasa <italic>et al</italic>., 2011</xref>) to compute a base-level alignment. This resulted in 213.9 million validated alignments &#x2265; 1 Kbp in length and &#x2265; 90&#x0025; identity. Finally, we filtered out trivial duplications (i.e. regions matching with themselves), and were left with 213.8 million alignments. This experiment took 120 CPU hours for executing Mashmap2 and 175,000 CPU hours for validating all reported mappings using LAST. We converted these alignments into BED format to compare against the UCSC database using Bedtools (<xref ref-type="bibr" rid="c25">Quinlan and Hall, 2010</xref>); the results are discussed below.</p>
</sec>
<sec id="s3b2">
<label>3.2.2</label>
<title>Accuracy Evaluation and Insights</title>
<p>The UCSC Segmental Duplications database for the hg38 human genome was computed using a method proposed by <xref ref-type="bibr" rid="c2">Bailey <italic>et al</italic>. (2001</xref>), and was last updated in 2014. It is important to note that prior to computing genomic duplications, their method removed high-copy repeat elements (e.g., LINEs, Alus) from the genome. Therefore, this database does not constitute all &#x2265;1 Kbp, &#x2265;90&#x0025; identity duplications in the genome, but a significant fraction of them. Nevertheless, we should expect our output to have high recall against this database. To measure recall on each chromosome, we computed coverage of those UCSC duplication annotations that have overlap with Mashmap2 duplications, and divided it by the coverage of all UCSC duplication annotations. Therefore, a 100&#x0025; recall score would imply that all base-pairs which are annotated as segmental duplication in the UCSC database are part of one or more Mashmap2 alignments. We show these recall scores for each chromosome as well for the complete genome in <xref ref-type="fig" rid="fig5">Figure 5</xref>. Recall is consistently observed to be above 90&#x0025; for each chromosome, and the aggregate recall for the complete genome is 97.2&#x0025;. High recall scores achieved here, as well as in our prior experiments, demonstrate high sensitivity of our algorithm in practice.</p>
<fig id="fig5" position="float" orientation="portrait" fig-type="figure">
<label>Fig. 5.</label>
<caption><p>Recall scores of duplications computed using Mashmap2 against the UCSC segmental duplication database. Above 90&#x0025; recall scores are achieved on each chromosome consistently. The red dotted line shows the aggregate recall score of 97.2&#x0025; for the complete genome.</p></caption>
<graphic xlink:href="259986_fig5.tif"/>
</fig>
<p>Finally, we compared the coverage of our alignments versus the UCSC database. Since our method did an exhaustive search of all duplications with &#x2265; 1 Kbp length and &#x2265; 90&#x0025; identity without masking any genomic repeats, we observe that our algorithm attains either equal or higher coverage on each chromosome (<xref ref-type="fig" rid="fig6">Figure 6</xref>). For the complete genome, coverage of our alignments is 10.4&#x0025;; 5&#x0025; higher than the coverage of UCSC annotations. We examined the subset of our duplications which do not overlap with UCSC segmental duplications. Indeed a large coverage fraction (81&#x0025;) comprises of high-copy repeats (i.e, coverage depth &#x003E; 50), potentially due to common repeat elements. However, a significant coverage (1.03&#x0025; of complete genome) is composed of low-copy repeats, with coverage depth &#x2264; 50 indicating the potential to uncover novel segmental duplications. Validating this possibility requires a more careful inspection of the output, and will be our future work.</p>
<fig id="fig6" position="float" orientation="portrait" fig-type="figure">
<label>Fig. 6.</label>
<caption><p>Comparison of genomic coverage between the UCSC Segmental Duplication database and Mashmap2 output alignments. Both methods reported equal coverage 83&#x0025; on mitochondrial chromosome (not shown above to keep the plot legible). Coverage of duplications computed using our method is significantly higher, owing to its exhaustive search of all repeats with &#x2265; 1 Kbp length and &#x2265;90&#x0025; identity without repeat masking.</p></caption>
<graphic xlink:href="259986_fig6.tif"/>
</fig>
</sec>
</sec>
</sec>
<sec id="s4">
<label>4</label>
<title>Discussion</title>
<p>In this work, we presented a fast algorithm for computing homology maps between whole genomes. We have given both theoretical and experimental evidence of the sensitivity provided, in terms of computing local alignment boundaries based on the minimum alignment length and identity parameters. This formulation grants a convenient mechanism for users to execute this algorithm based on the underlying applications, which can be (but not limited to) mapping genome assembly of variable quality, aligning long reads to reference genomes, or computing segmental duplications in large genomes. Additionally, we formulated a filtering heuristic, and proposed an optimal plane-sweep based filtering algorithm for prioritizing alignments based on their scores and locations. The filtering algorithm is practically fast, accurate, and easy to implement in few lines of code using standard libraries. When mapping a human genome assembly to the human reference genome, Mashmap2 takes only about a minute from reading input sequences to generating the final alignment boundaries, identity estimates, and a dot-plot for visualization. Because of the underlying auto-tuning mechanism in Mashmap2, performance depends on the sensitivity requirements provided to the algorithm. As the pace of whole-genome sequencing continues to increase, faster practical algorithms and theoretical advances will help analyze available and forthcoming data.</p>
<p>Although our algorithm accelerates mapping of a single genome assembly to a single reference genome, its runtime would scale linearly when mapping to multiple reference genomes. Future work will include development of sub-linear algorithms using existing ideas of non-linear reference genome representations. We also plan to evaluate biological novelty of the human segmental duplications computed in this work.</p>
</sec>
</body>
<back>
<ack>
<title>Acknowledgements</title>
<p>We thank Pavel Pevzner for motivating evaluation of segmental duplications. This research was supported in part by the Intramural Research Program of the National Human Genome Research Institute, National Institutes of Health, and the U.S. National Science Foundation under IIS-1416259. We also acknowledge the use of computing resources provided through the Partnership for an Advanced Computing Environment (PACE) at the Georgia Institute of Technology, and the Biowulf system at the National Institutes of Health, Bethesda, MD (<ext-link ext-link-type="uri" xlink:href="https://hpc.nih.gov/">https://hpc.nih.gov/</ext-link>).</p>
</ack>
<ref-list>
<title>References</title>
<ref id="c1"><mixed-citation publication-type="journal"><string-name><surname>Altschul</surname>, <given-names>S. F.</given-names></string-name>, <string-name><surname>Madden</surname>, <given-names>T. L.</given-names></string-name>, <string-name><surname>Schaffer</surname>, <given-names>A. A.</given-names></string-name>, <string-name><surname>Zhang</surname>, <given-names>J.</given-names></string-name>, <string-name><surname>Zhang</surname>, <given-names>Z.</given-names></string-name>, <string-name><surname>Miller</surname>, <given-names>W.</given-names></string-name>, and <string-name><surname>Lipman</surname>, <given-names>D. J.</given-names></string-name> (<year>1997</year>). <article-title>Gapped BLAST and PSI-BLAST: a new generation of protein database search programs</article-title>. <source>Nucleic acids research</source>, <volume>25</volume>(<issue>17</issue>), <fpage>3389</fpage>&#x2013;<lpage>3402</lpage>.</mixed-citation></ref>
<ref id="c2"><mixed-citation publication-type="journal"><string-name><surname>Bailey</surname>, <given-names>J. A.</given-names></string-name>, <string-name><surname>Yavor</surname>, <given-names>A. M.</given-names></string-name>, <string-name><surname>Massa</surname>, <given-names>H. F.</given-names></string-name>, <string-name><surname>Trask</surname>, <given-names>B. J.</given-names></string-name>, and <string-name><surname>Eichler</surname>, <given-names>E. E.</given-names></string-name> (<year>2001</year>). <article-title>Segmental duplications: organization and impact within the currenthuman genome project assembly</article-title>. <source>Genomeresearch</source>, <volume>11</volume>(<issue>6</issue>), <fpage>1005</fpage>&#x2013;<lpage>1017</lpage>.</mixed-citation></ref>
<ref id="c3"><mixed-citation publication-type="journal"><string-name><surname>Bailey</surname>, <given-names>J. A.</given-names></string-name>, <string-name><surname>Gu</surname>, <given-names>Z.</given-names></string-name>, <string-name><surname>Clark</surname>, <given-names>R. A.</given-names></string-name>, <string-name><surname>Reinert</surname>, <given-names>K.</given-names></string-name>, <string-name><surname>Samonte</surname>, <given-names>R. V.</given-names></string-name>, <string-name><surname>Schwartz</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>Adams</surname>, <given-names>M. D.</given-names></string-name>, <string-name><surname>Myers</surname>, <given-names>E. W.</given-names></string-name>, <string-name><surname>Li</surname>, <given-names>P. W.</given-names></string-name>, and <string-name><surname>Eichler</surname>, <given-names>E. E.</given-names></string-name> (<year>2002</year>). <article-title>Recent segmental duplications in the human genome</article-title>. <source>Science</source>, <volume>297</volume>(<issue>5583</issue>), <fpage>1003</fpage>&#x2013;<lpage>1007</lpage>.</mixed-citation></ref>
<ref id="c4"><mixed-citation publication-type="book"><string-name><surname>Berman</surname>, <given-names>P.</given-names></string-name>, <string-name><surname>Zhang</surname>, <given-names>Z.</given-names></string-name>, <string-name><surname>Wolf</surname>, <given-names>Y. I.</given-names></string-name>, <string-name><surname>Koonin</surname>, <given-names>E. V.</given-names></string-name>, and <string-name><surname>Miller</surname>, <given-names>W.</given-names></string-name> (<year>1999</year>). <chapter-title>Winnowing sequences from a database search</chapter-title>. In <source>Proceedings of the third annual international conference on Computational molecular biology</source>, pages <fpage>50</fpage>&#x2013;<lpage>58</lpage>. <publisher-name>ACM</publisher-name>.</mixed-citation></ref>
<ref id="c5"><mixed-citation publication-type="journal"><string-name><surname>Bray</surname>, <given-names>N.</given-names></string-name>, <string-name><surname>Dubchak</surname>, <given-names>I.</given-names></string-name>, and <string-name><surname>Pachter</surname>, <given-names>L.</given-names></string-name> (<year>2003</year>). <article-title>AVID: A global alignment program</article-title>. <source>Genome research</source>, <volume>13</volume>(<issue>1</issue>), <fpage>97</fpage>&#x2013;<lpage>102</lpage>.</mixed-citation></ref>
<ref id="c6"><mixed-citation publication-type="journal"><string-name><surname>Brudno</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Chapman</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Gottgens</surname>, <given-names>B.</given-names></string-name>, <string-name><surname>Batzoglou</surname>, <given-names>S.</given-names></string-name>, and <string-name><surname>Morgenstern</surname>, <given-names>B.</given-names></string-name> (<year>2003</year>). <article-title>Fast and sensitive multiple alignment of large genomic sequences</article-title>. <source>BMC bioinformatics</source>, <volume>4</volume>(<issue>1</issue>), <fpage>66</fpage>.</mixed-citation></ref>
<ref id="c7"><mixed-citation publication-type="journal"><string-name><surname>Delcher</surname>, <given-names>A. L.</given-names></string-name>, <string-name><surname>Kasif</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>Fleischmann</surname>, <given-names>R. D.</given-names></string-name>, <string-name><surname>Peterson</surname>, <given-names>J.</given-names></string-name>, <string-name><surname>White</surname>, <given-names>O.</given-names></string-name>, and <string-name><surname>Salzberg</surname>, <given-names>S. L.</given-names></string-name> (<year>1999</year>). <article-title>Alignment of whole genomes</article-title>. <source>Nucleic acids research</source>, <volume>27</volume>(<issue>11</issue>), <fpage>2369</fpage>&#x2013;<lpage>2376</lpage>.</mixed-citation></ref>
<ref id="c8"><mixed-citation publication-type="journal"><string-name><surname>Emanuel</surname>, <given-names>B. S.</given-names></string-name> and <string-name><surname>Shaikh</surname>, <given-names>T. H.</given-names></string-name> (<year>2001</year>). <article-title>Segmental duplications: an&#x2019;expanding&#x2019;role in genomic instability and disease</article-title>. <source>Nature Reviews Genetics</source>, <volume>2</volume>(<issue>10</issue>), <fpage>791</fpage>&#x2013;<lpage>800</lpage>.</mixed-citation></ref>
<ref id="c9"><mixed-citation publication-type="journal"><string-name><surname>Grabherr</surname>, <given-names>M. G.</given-names></string-name>, <string-name><surname>Russell</surname>, <given-names>P.</given-names></string-name>, <string-name><surname>Meyer</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Mauceli</surname>, <given-names>E.</given-names></string-name>, <string-name><surname>Alfoldi</surname>, <given-names>J.</given-names></string-name>, <string-name><surname>Di Palma</surname>, <given-names>F.</given-names></string-name>, and <string-name><surname>Lindblad-Toh</surname>, <given-names>K.</given-names></string-name> (<year>2010</year>). <article-title>Genome-wide synteny through highly sensitive sequence alignment: Satsuma</article-title>. <source>Bioinformatics</source>, <volume>26</volume>(<issue>9</issue>), <fpage>1145</fpage>&#x2013;<lpage>1151</lpage>.</mixed-citation></ref>
<ref id="c10"><mixed-citation publication-type="other"><string-name><surname>Haussler</surname>, <given-names>D.</given-names></string-name>, <string-name><surname>O&#x2019;Brien</surname>, <given-names>S. J.</given-names></string-name>, <string-name><surname>Ryder</surname>, <given-names>O. A.</given-names></string-name>, <string-name><surname>Barker</surname>, <given-names>F. K.</given-names></string-name>, <string-name><surname>Clamp</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Crawford</surname>, <given-names>A. J.</given-names></string-name>, <string-name><surname>Hanner</surname>, <given-names>R.</given-names></string-name>, <string-name><surname>Hanotte</surname>, <given-names>O.</given-names></string-name>, <string-name><surname>McGuire</surname>, <given-names>J. A.</given-names></string-name>, <string-name><surname>Miller</surname>, <given-names>W.</given-names></string-name>, <etal>et al.</etal> (<year>2009</year>). <source>Genome 10K: a proposal to obtain whole-genome sequence for 10 000 vertebrate species</source>.</mixed-citation></ref>
<ref id="c11"><mixed-citation publication-type="journal"><collab>International Human Genome Sequencing Consortium</collab> (<year>2004</year>). <article-title>Finishing the euchromatic sequence of the human genome</article-title>. <source>Nature</source>, <volume>431</volume>(<issue>7011</issue>), <fpage>931</fpage>&#x2013;<lpage>945</lpage>.</mixed-citation></ref>
<ref id="c12"><mixed-citation publication-type="book"><string-name><surname>Jain</surname>, <given-names>C.</given-names></string-name>, <string-name><surname>Dilthey</surname>, <given-names>A.</given-names></string-name>, <string-name><surname>Koren</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>Aluru</surname>, <given-names>S.</given-names></string-name>, and <string-name><surname>Phillippy</surname>, <given-names>A. M.</given-names></string-name> (<year>2017a</year>). <chapter-title>A fast approximate algorithm for mapping long reads to large reference databases</chapter-title>. In <source>International Conference on Research in Computational Molecular Biology</source>, pages <fpage>66</fpage>&#x2013;<lpage>81</lpage>. <publisher-name>Springer</publisher-name>.</mixed-citation></ref>
<ref id="c13"><mixed-citation publication-type="other"><string-name><surname>Jain</surname>, <given-names>C.</given-names></string-name>, <string-name><surname>Rodriguez-R</surname>, <given-names>L. M.</given-names></string-name>, <string-name><surname>Phillippy</surname>, <given-names>A. M.</given-names></string-name>, <string-name><surname>Konstantinidis</surname>, <given-names>K. T.</given-names></string-name>, and <string-name><surname>Aluru</surname>, <given-names>S.</given-names></string-name> (<year>2017b</year>). <article-title>High-throughput ANI analysis of 90K prokaryotic genomes reveals clear species boundaries</article-title>. <source>bioRxiv</source>, page <fpage>225342</fpage>.</mixed-citation></ref>
<ref id="c14"><mixed-citation publication-type="other"><string-name><surname>Jain</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Koren</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>Quick</surname>, <given-names>J.</given-names></string-name>, <string-name><surname>Rand</surname>, <given-names>A. C.</given-names></string-name>, <string-name><surname>Sasani</surname>, <given-names>T. A.</given-names></string-name>, <string-name><surname>Tyson</surname>, <given-names>J. R.</given-names></string-name>, <string-name><surname>Beggs</surname>, <given-names>A. D.</given-names></string-name>, <string-name><surname>Dilthey</surname>, <given-names>A. T.</given-names></string-name>, <string-name><surname>Fiddes</surname>, <given-names>I. T.</given-names></string-name>, <string-name><surname>Malla</surname>, <given-names>S.</given-names></string-name>, <etal>et al.</etal> (<year>2017c</year>). <article-title>Nanopore sequencing and assembly of a human genome with ultra-long reads</article-title>. <source>bioRxiv</source>, page <fpage>128835</fpage>.</mixed-citation></ref>
<ref id="c15"><mixed-citation publication-type="journal"><string-name><surname>Kent</surname>, <given-names>W. J.</given-names></string-name>, <string-name><surname>Sugnet</surname>, <given-names>C. W.</given-names></string-name>, <string-name><surname>Furey</surname>, <given-names>T. S.</given-names></string-name>, <string-name><surname>Roskin</surname>, <given-names>K. M.</given-names></string-name>, <string-name><surname>Pringle</surname>, <given-names>T. H.</given-names></string-name>, <string-name><surname>Zahler</surname>, <given-names>A. M.</given-names></string-name>, and <string-name><surname>Haussler</surname>, <given-names>D.</given-names></string-name> (<year>2002</year>). <article-title>The human genome browser at UCSC</article-title>. <source>Genome research</source>, <volume>12</volume>(<issue>6</issue>), <fpage>996</fpage>&#x2013;<lpage>1006</lpage>.</mixed-citation></ref>
<ref id="c16"><mixed-citation publication-type="journal"><string-name><surname>Kielbasa</surname>, <given-names>S. M.</given-names></string-name>, <string-name><surname>Wan</surname>, <given-names>R.</given-names></string-name>, <string-name><surname>Sato</surname>, <given-names>K.</given-names></string-name>, <string-name><surname>Horton</surname>, <given-names>P.</given-names></string-name>, and <string-name><surname>Frith</surname>, <given-names>M. C.</given-names></string-name> (<year>2011</year>). <article-title>Adaptive seeds tame genomic sequence comparison</article-title>. <source>Genome research</source>, <volume>21</volume>(<issue>3</issue>), <fpage>487</fpage>&#x2013;<lpage>493</lpage>.</mixed-citation></ref>
<ref id="c17"><mixed-citation publication-type="journal"><string-name><surname>Koren</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>Walenz</surname>, <given-names>B. P.</given-names></string-name>, <string-name><surname>Berlin</surname>, <given-names>K.</given-names></string-name>, <string-name><surname>Miller</surname>, <given-names>J. R.</given-names></string-name>, <string-name><surname>Bergman</surname>, <given-names>N. H.</given-names></string-name>, and <string-name><surname>Phillippy</surname>, <given-names>A. M.</given-names></string-name> (<year>2017</year>). <article-title>Canu: scalable and accurate long-read assembly via adaptive k-mer weighting and repeat separation</article-title>. <source>Genome research</source>, <volume>27</volume>(<issue>5</issue>), <fpage>722</fpage>&#x2013;<lpage>736</lpage>.</mixed-citation></ref>
<ref id="c18"><mixed-citation publication-type="journal"><string-name><surname>Kurtz</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>Phillippy</surname>, <given-names>A.</given-names></string-name>, <string-name><surname>Delcher</surname>, <given-names>A. L.</given-names></string-name>, <string-name><surname>Smoot</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Shumway</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Antonescu</surname>, <given-names>C.</given-names></string-name>, and <string-name><surname>Salzberg</surname>, <given-names>S. L.</given-names></string-name> (<year>2004</year>). <article-title>Versatile and open software for comparing large genomes</article-title>. <source>Genome biology</source>, <volume>5</volume>(<issue>2</issue>), <fpage>R12</fpage>.</mixed-citation></ref>
<ref id="c19"><mixed-citation publication-type="journal"><string-name><surname>Lander</surname>, <given-names>E. S.</given-names></string-name>, <string-name><surname>Linton</surname>, <given-names>L. M.</given-names></string-name>, <string-name><surname>Birren</surname>, <given-names>B.</given-names></string-name>, <string-name><surname>Nusbaum</surname>, <given-names>C.</given-names></string-name>, <string-name><surname>Zody</surname>, <given-names>M. C.</given-names></string-name>, <string-name><surname>Baldwin</surname>, <given-names>J.</given-names></string-name>, <string-name><surname>Devon</surname>, <given-names>K.</given-names></string-name>, <string-name><surname>Dewar</surname>, <given-names>K.</given-names></string-name>, <string-name><surname>Doyle</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>FitzHugh</surname>, <given-names>W.</given-names></string-name>, <etal>et al.</etal> (<year>2001</year>). <article-title>Initial sequencing and analysis of the human genome</article-title>. <source>Nature</source>, <volume>409</volume>(<issue>6822</issue>), <fpage>860</fpage>&#x2013;<lpage>921</lpage>.</mixed-citation></ref>
<ref id="c20"><mixed-citation publication-type="other"><string-name><surname>Li</surname>, <given-names>H.</given-names></string-name> (<year>2017</year>). <article-title>Minimap2: fast pairwise alignment for long DNA sequences</article-title>. <source>arXiv</source> preprint arXiv:<pub-id pub-id-type="arxiv">1708.01492</pub-id>.</mixed-citation></ref>
<ref id="c21"><mixed-citation publication-type="journal"><string-name><surname>Lubiw</surname>, <given-names>A.</given-names></string-name> and <string-name><surname>R&#x00E1;cz</surname>, <given-names>A.</given-names></string-name> (<year>1991</year>). <article-title>A lower bound for the integer element distinctness problem</article-title>. <source>Information and Computation</source>, <volume>94</volume>(<issue>1</issue>), <fpage>83</fpage>&#x2013;<lpage>92</lpage>.</mixed-citation></ref>
<ref id="c22"><mixed-citation publication-type="journal"><string-name><surname>Ma</surname>, <given-names>B.</given-names></string-name>, <string-name><surname>Tromp</surname>, <given-names>J.</given-names></string-name>, and <string-name><surname>Li</surname>, <given-names>M.</given-names></string-name> (<year>2002</year>). <article-title>Patternhunter: faster and more sensitive homology search</article-title>. <source>Bioinformatics</source>, <volume>18</volume>(<issue>3</issue>), <fpage>440</fpage>&#x2013;<lpage>45</lpage>.</mixed-citation></ref>
<ref id="c23"><mixed-citation publication-type="journal"><string-name><surname>Mar&#x00E7;ais</surname> <given-names>G</given-names></string-name>, <string-name><surname>Delcher</surname>, <given-names>A. L.</given-names></string-name>, <string-name><surname>Phillippy</surname>, <given-names>A. M.</given-names></string-name>, <string-name><surname>Rachel</surname>, <given-names>C.</given-names></string-name>, <string-name><surname>Salzberg</surname>, <given-names>S. L.</given-names></string-name>, and <string-name><surname>Aleksey</surname>, <given-names>Z.</given-names></string-name> (<year>2018</year>). <article-title>MUMmer4: A fast and versatile genome alignment system</article-title>. <source>PLoS Comput Biol</source>, <volume>14</volume>(<issue>1</issue>).</mixed-citation></ref>
<ref id="c24"><mixed-citation publication-type="journal"><string-name><surname>Ondov</surname>, <given-names>B. D.</given-names></string-name>, <string-name><surname>Treangen</surname>, <given-names>T. J.</given-names></string-name>, <string-name><surname>Melsted</surname>, <given-names>P.</given-names></string-name>, <string-name><surname>Mallonee</surname>, <given-names>A. B.</given-names></string-name>, <string-name><surname>Bergman</surname>, <given-names>N. H.</given-names></string-name>, <string-name><surname>Koren</surname>, <given-names>S.</given-names></string-name>, and <string-name><surname>Phillippy</surname>, <given-names>A. M.</given-names></string-name> (<year>2016</year>). <article-title>Mash: fast genome and metagenome distance estimation using MinHash</article-title>. <source>Genome biology</source>, <volume>17</volume>(<issue>1</issue>), <fpage>132</fpage>.</mixed-citation></ref>
<ref id="c25"><mixed-citation publication-type="journal"><string-name><surname>Quinlan</surname>, <given-names>A. R.</given-names></string-name> and <string-name><surname>Hall</surname>, <given-names>I. M.</given-names></string-name> (<year>2010</year>). <article-title>Bedtools: a flexible suite of utilities for comparing genomic features</article-title>. <source>Bioinformatics</source>, <volume>26</volume>(<issue>6</issue>), <fpage>841</fpage>&#x2013;<lpage>842</lpage>.</mixed-citation></ref>
<ref id="c26"><mixed-citation publication-type="journal"><string-name><surname>Schneider</surname>, <given-names>V. A.</given-names></string-name>, <string-name><surname>Graves-Lindsay</surname>, <given-names>T.</given-names></string-name>, <string-name><surname>Howe</surname>, <given-names>K.</given-names></string-name>, <string-name><surname>Bouk</surname>, <given-names>N.</given-names></string-name>, <string-name><surname>Chen</surname>, <given-names>H.-C.</given-names></string-name>, <string-name><surname>Kitts</surname>, <given-names>P. A.</given-names></string-name>, <string-name><surname>Murphy</surname>, <given-names>T. D.</given-names></string-name>, <string-name><surname>Pruitt</surname>, <given-names>K. D.</given-names></string-name>, <string-name><surname>Thibaud-Nissen</surname>, <given-names>F.</given-names></string-name>, <string-name><surname>Albracht</surname>, <given-names>D.</given-names></string-name>, <etal>et al.</etal> (<year>2017</year>). <article-title>Evaluation of grch38 and de novo haploid genome assemblies demonstrates the enduring quality of the reference assembly</article-title>. <source>Genome research</source>, <volume>27</volume>(<issue>5</issue>), <fpage>849</fpage>&#x2013;<lpage>864</lpage>.</mixed-citation></ref>
<ref id="c27"><mixed-citation publication-type="journal"><string-name><surname>Schwartz</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>Kent</surname>, <given-names>W. J.</given-names></string-name>, <string-name><surname>Smit</surname>, <given-names>A.</given-names></string-name>, <string-name><surname>Zhang</surname>, <given-names>Z.</given-names></string-name>, <string-name><surname>Baertsch</surname>, <given-names>R.</given-names></string-name>, <string-name><surname>Hardison</surname>, <given-names>R. C.</given-names></string-name>, <string-name><surname>Haussler</surname>, <given-names>D.</given-names></string-name>, and <string-name><surname>Miller</surname>, <given-names>W.</given-names></string-name> (<year>2003</year>). <article-title>Human-mouse alignments with BLASTZ</article-title>. <source>Genome research</source>, <volume>13</volume>(<issue>1</issue>), <fpage>103</fpage>&#x2013;<lpage>107</lpage>.</mixed-citation></ref>
<ref id="c28"><mixed-citation publication-type="book"><string-name><surname>Shamos</surname>, <given-names>M. I.</given-names></string-name> and <string-name><surname>Hoey</surname>, <given-names>D.</given-names></string-name> (<year>1976</year>). <chapter-title>Geometric intersection problems</chapter-title>. In <source>Foundations of Computer Science</source>, <conf-date>1976</conf-date>., <conf-name>17th Annual Symposium</conf-name> on, pages <fpage>208</fpage>&#x2013;<lpage>215</lpage>. <publisher-name>IEEE</publisher-name>.</mixed-citation></ref>
<ref id="c29"><mixed-citation publication-type="journal"><string-name><surname>Venter</surname>, <given-names>J. C.</given-names></string-name>, <string-name><surname>Adams</surname>, <given-names>M. D.</given-names></string-name>, <string-name><surname>Myers</surname>, <given-names>E. W.</given-names></string-name>, <string-name><surname>Li</surname>, <given-names>P. W.</given-names></string-name>, <string-name><surname>Mural</surname>, <given-names>R. J.</given-names></string-name>, <string-name><surname>Sutton</surname>, <given-names>G. G.</given-names></string-name>, <string-name><surname>Smith</surname>, <given-names>H. O.</given-names></string-name>, <string-name><surname>Yandell</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Evans</surname>, <given-names>C. A.</given-names></string-name>, <string-name><surname>Holt</surname>, <given-names>R. A.</given-names></string-name>, <etal>et al.</etal> (<year>2001</year>). <article-title>The sequence of the human genome</article-title>. <source>science</source>, <volume>291</volume>(<issue>5507</issue>), <fpage>1304</fpage>&#x2013;<lpage>1351</lpage>.</mixed-citation></ref>
<ref id="c30"><mixed-citation publication-type="journal"><string-name><surname>Vyverman</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>De Baets</surname>, <given-names>B.</given-names></string-name>, <string-name><surname>Fack</surname>, <given-names>V.</given-names></string-name>, and <string-name><surname>Dawyndt</surname>, <given-names>P.</given-names></string-name> (<year>2013</year>). <article-title>essamem: finding maximal exact matches using enhanced sparse suffix arrays</article-title>. <source>Bioinformatics</source>, <volume>29</volume>(<issue>6</issue>), <fpage>802</fpage>&#x2013;<lpage>804</lpage>.</mixed-citation></ref>
</ref-list>

</back>
</article>