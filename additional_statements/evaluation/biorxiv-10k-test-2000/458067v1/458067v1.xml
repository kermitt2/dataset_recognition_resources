<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.2d1 20170631//EN" "JATS-archivearticle1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" article-type="article" dtd-version="1.2d1" specific-use="production" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">BIORXIV</journal-id>
<journal-title-group>
<journal-title>bioRxiv</journal-title>
<abbrev-journal-title abbrev-type="publisher">bioRxiv</abbrev-journal-title>
</journal-title-group>
<publisher>
<publisher-name>Cold Spring Harbor Laboratory</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1101/458067</article-id>
<article-version>1.1</article-version>
<article-categories>
<subj-group subj-group-type="author-type">
<subject>Regular Article</subject>
</subj-group>
<subj-group subj-group-type="heading">
<subject>New Results</subject>
</subj-group>
<subj-group subj-group-type="hwp-journal-coll">
<subject>Evolutionary Biology</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>Inferring the ancestry of everyone</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes">
<contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-7894-5253</contrib-id><name><surname>Kelleher</surname><given-names>Jerome</given-names></name><xref ref-type="aff" rid="a1">1</xref></contrib>
<contrib contrib-type="author"><contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-3536-6411</contrib-id>
<name><surname>Wong</surname><given-names>Yan</given-names></name>
<xref ref-type="aff" rid="a1">1</xref></contrib>
<contrib contrib-type="author"><contrib-id contrib-id-type="orcid">http://orcid.org/0000-0003-2770-3729</contrib-id>
<name><surname>Albers</surname><given-names>Patrick K.</given-names></name>
<xref ref-type="aff" rid="a1">1</xref></contrib>
<contrib contrib-type="author"><contrib-id contrib-id-type="orcid">http://orcid.org/0000-0001-7353-1177</contrib-id>
<name><surname>Wohns</surname><given-names>Anthony W.</given-names></name>
<xref ref-type="aff" rid="a1">1</xref></contrib>
<contrib contrib-type="author"><contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-5012-4162</contrib-id>
<name><surname>McVean</surname><given-names>Gil</given-names></name>
<xref ref-type="aff" rid="a1">1</xref></contrib>
<aff id="a1"><label>1</label><institution>Big Data Institute, Li Ka Shing Centre for Health Information and Discovery, University of Oxford, Oxford</institution>, <country>United Kingdom</country>
</aff>
</contrib-group>
<pub-date pub-type="epub"><year>2018</year></pub-date>
<elocation-id>458067</elocation-id>
<history>
<date date-type="received">
<day>01</day>
<month>11</month>
<year>2018</year>
</date>
<date date-type="rev-recd">
<day>01</day>
<month>11</month>
<year>2018</year>
</date>
<date date-type="accepted">
<day>01</day>
<month>11</month>
<year>2018</year>
</date>
</history>
<permissions>
<copyright-statement>&#x00A9; 2018, Posted by Cold Spring Harbor Laboratory</copyright-statement>
<copyright-year>2018</copyright-year>
<license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by/4.0/"><license-p>This pre-print is available under a Creative Commons License (Attribution 4.0 International), CC BY 4.0, as described at <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link></license-p></license>
</permissions>
<self-uri xlink:href="458067.pdf" content-type="pdf" xlink:role="full-text"/>
<abstract>
<title>Abstract</title>
<p>A central problem in evolutionary biology is to infer the full genealogical history of a set of DNA sequences. This history contains rich information about the forces that have influenced a sexually reproducing species. However, existing methods are limited: the most accurate is unable to cope with more than a few dozen samples. With modern genetic data sets rapidly approaching millions of genomes, there is an urgent need for efficient inference methods to exploit such rich resources. We introduce an algorithm to infer whole-genome history which has comparable accuracy to the state-of-the-art but can process around four orders of magnitude more sequences. Additionally, our method results in an &#x201C;evolutionary encoding&#x201D; of the original sequence data, enabling efficient access to genealogies and calculation of genetic statistics over the data. We apply this technique to human data from the 1000 Genomes Project, Simons Genome Diversity Project and UK Biobank, showing that the genealogies we estimate are both rich in biological signal and efficient to process.</p>
</abstract>
<counts>
<page-count count="42"/>
</counts>
</article-meta>
</front>
<body>
<sec id="s1">
<title>Introduction</title>
<p>Using a tree to encode evolutionary relationships is a fundamental organising principle in biology. From Darwin&#x2019;s speculative sketches [<xref ref-type="bibr" rid="c9">Darwin, 1987</xref>] and Haeckel&#x2019;s phylogenetic imagery [<xref ref-type="bibr" rid="c20">Haeckel, 1866</xref>] to modern syntheses encompassing all species of life [<xref ref-type="bibr" rid="c22">Hinchliff et al., 2015</xref>], trees elegantly encode and summarise the outcomes of evolutionary processes. Many different methods now exist to infer these evolutionary trees from real-world data [<xref ref-type="bibr" rid="c11">Felsenstein, 2004</xref>] and such trees have many applications [<xref ref-type="bibr" rid="c52">Yang and Rannala, 2012</xref>]. However, a tree can only be used to describe the ancestry of a set of DNA sequences if these sequences are transmitted as a single unit down the generations. Anything that causes different parts of a sequence to come from different ancestors results in a history that cannot be described by a single tree, but instead requires a network [<xref ref-type="bibr" rid="c37">Morrison, 2016</xref>]. This presents difficulties when inferring ancestry within a sexually reproducing species, where DNA is inherited from both mother and father through recombination.</p>
<p>The need for structures more general than trees to describe ancestry has long been understood [<xref ref-type="bibr" rid="c44">Ragan, 2009</xref>]. Many different approaches to such &#x201C;phylogenetic networks&#x201D; exist, modelling the non-vertical transmission of genetic information such as horizontal gene transfer and hybridisation [<xref ref-type="bibr" rid="c37">Morrison, 2016</xref>]. The Ancestral Recombination Graph, or ARG [<xref ref-type="bibr" rid="c13">Griffiths, 1991</xref>, <xref ref-type="bibr" rid="c14">Griffiths and Marjoram, 1996</xref>], models the network arising from inheritance in sexually reproducing species, encoding the recombination and common ancestor events that occurred in the history of a sample. In principle, ARGs contain all the information knowable about genetic history, and are widely acknowledged as being centrally important to population genetics [<xref ref-type="bibr" rid="c35">Minichiello and Durbin, 2006</xref>, <xref ref-type="bibr" rid="c3">Arenas, 2013</xref>, <xref ref-type="bibr" rid="c16">Gusfield, 2014</xref>, <xref ref-type="bibr" rid="c45">Rasmussen et al., 2014</xref>]. However, practical applications have been limited by the fact that inferring ARGs from real data is a prohibitively expensive computational problem. Finding an ARG with the minimum number of recombination events required to explain a set of input sequences is NP hard [<xref ref-type="bibr" rid="c4">Bordewich and Semple, 2005</xref>, <xref ref-type="bibr" rid="c51">Wang et al., 2001</xref>], and the scope of methods computing such &#x2018;MinARGs&#x2019; is therefore severely limited [<xref ref-type="bibr" rid="c21">Hein, 1990</xref>, <xref ref-type="bibr" rid="c48">Song and Hein, 2005</xref>]. Without this minimality criterion, there exist both polynomial time algorithms [<xref ref-type="bibr" rid="c17">Gusfield et al., 2004</xref>, <xref ref-type="bibr" rid="c18">2007</xref>] and methods using various techniques to reduce the state space [<xref ref-type="bibr" rid="c14">Griffiths and Marjoram, 1996</xref>, <xref ref-type="bibr" rid="c29">Kuhner et al., 2000</xref>, <xref ref-type="bibr" rid="c10">Fearnhead and Donnelly, 2001</xref>], but in practice these are too slow to apply to even moderately sized data sets. Several heuristic methods have been explored [<xref ref-type="bibr" rid="c49">Song et al., 2005</xref>, <xref ref-type="bibr" rid="c35">Minichiello and Durbin, 2006</xref>, <xref ref-type="bibr" rid="c41">Parida et al., 2008</xref>, <xref ref-type="bibr" rid="c39">O&#x2019;Fallon, 2013</xref>, <xref ref-type="bibr" rid="c36">Mirzaei and Wu, 2016</xref>] but most are limited to tens of samples and a few thousand variant sites. The <monospace>ARGweaver</monospace> program [<xref ref-type="bibr" rid="c45">Rasmussen et al., 2014</xref>] is the current state-of-the-art and a substantial advance over earlier methods, as it performs statistically rigorous inference of ARGs over tens of thousands of variant sites. However, computational time grows very quickly with the number of input samples, and anything more than a few tens of sequences is infeasible. The widespread use of ARGs is also hindered by the lack of a standard means of interchange and toolkits to process such data. Despite several efforts to standardise [<xref ref-type="bibr" rid="c6">Cardona et al., 2008</xref>, <xref ref-type="bibr" rid="c34">McGill et al., 2013</xref>], adoption remains practically non-existent. Thus, the status of the ARG remains as it has been for many years: a structure that is widely agreed to be fundamental to our understanding of the ancestry of biological populations, but one which is practically never used.</p>
<p>Here we introduce a method, <monospace>tsinfer</monospace>, that removes these barriers to the adoption of ARGs in the analysis of genetic variation data. Crucially, <monospace>tsinfer</monospace> vastly expands the scale over which ancestry can be inferred, simultaneously increasing the number of variant sites and sample genomes that can be analysed by several orders of magnitude. In a simulation study, we show that this enormous increase in computational efficiency is not at the cost of accuracy: <monospace>tsinfer</monospace> infers ancestry with fidelity comparable to the state-of-the-art. Moreover, we show that the data structure produced by <monospace>tsinfer</monospace>, the <italic>succinct tree sequence</italic> (or tree sequence, for brevity) [<xref ref-type="bibr" rid="c25">Kelleher et al., 2016</xref>, <xref ref-type="bibr" rid="c26">2018</xref>] has the potential to store genetic data for entire populations using a fraction of the space that would be required by present-day methods. As an encoding of the data directly based on the evolutionary history of the samples, many statistics can be computed efficiently using this structure&#x2014;indeed, this efficiency is key to the scalability of <monospace>tsinfer</monospace> itself. The tree sequence toolkit (or <monospace>tskit</monospace>) is a free and open source library providing convenient access to these efficient algorithms. Thus, the two main practical obstacles to using ARGs (the lack of efficient inference methods and software to process the output) have been removed. We demonstrate this utility by applying <monospace>tsinfer</monospace> to three large-scale human data sets (1000 Genomes [<xref ref-type="bibr" rid="c1">1000 Genomes Project Consortium, 2015</xref>], the Simons Genomes Diversity Project [<xref ref-type="bibr" rid="c32">Mallick et al., 2016</xref>] and UK Biobank [<xref ref-type="bibr" rid="c5">Bycroft et al., 2018</xref>]) and show how biological signals can be easily inferred from the resulting genealogical representation.</p>
</sec>
<sec id="s2">
<title>Results</title>
<sec id="s2a">
<title>Succinct tree sequences</title>
<p>The tangled web of ancestry describing the genetic history of recombining organisms is conventionally encoded via common ancestor and recombination events in an ARG. An equivalent (and arguably simpler) way of viewing this process is to regard the ancestry of the sample as a sequence of marginal trees, each encoding the genealogy for a particular segment of DNA [<xref ref-type="bibr" rid="c21">Hein, 1990</xref>]. As we move along a chromosome, recombination events in the history of the sample alter the trees in a well-defined way [<xref ref-type="bibr" rid="c48">Song and Hein, 2005</xref>], and adjacent trees tend to be highly correlated. The <italic>succinct tree sequence</italic> is a recently introduced encoding for recombinant ancestry that takes advantage of the correlations between adjacent trees [<xref ref-type="bibr" rid="c25">Kelleher et al., 2016</xref>, <xref ref-type="bibr" rid="c26">2018</xref>]. This is done by recording edges that are shared by multiple adjacent trees once, rather than storing each tree independently. This simple device explicitly captures the shared structure among trees and leads to very efficient algorithms for processing them [<xref ref-type="bibr" rid="c25">Kelleher et al., 2016</xref>]. Although essentially equivalent, we avoid describing the succinct tree sequence as an ARG because there is an important distinction between the two structures: an ARG encodes the <italic>events</italic> that occurred in the history of a sample, whereas a tree sequence encodes the <italic>outcome</italic> of those events. In particular, recombination events are not explicitly recorded in a tree sequence.</p>
<p>One benefit of explicitly capturing the shared tree structure inherent in recombinant ancestry is the potential for a dramatic reduction in the space required to store genetic variation data. Such information is usually encoded as a matrix in which the columns correspond to samples (a human individual, for example) and the rows correspond to sites along the genome at which variation is observed (<xref ref-type="fig" rid="fig1">Fig 1A</xref>). If we have n samples and m sites we need <italic>O</italic>(<italic>nm</italic>) space to store the entire matrix. Studies such as the UK Biobank [<xref ref-type="bibr" rid="c5">Bycroft et al., 2018</xref>] already have data for hundreds of thousands of samples, and such large sample sizes are expected to become increasingly common [<xref ref-type="bibr" rid="c50">Stephens et al., 2015</xref>]. As many species have millions of variant sites per chromosome, storing and processing such huge matrices is a serious burden. Tree sequences provide an elegant solution. The variation that we observe in present-day samples is the result of mutations that occurred in the past, in the ancestors of our samples. If we know the genealogy at a particular variant site we can fully describe the variation at that site by recording the presence of these mutations in the ancestors in question (<xref ref-type="fig" rid="fig1">Fig. 1B</xref>). Mutations at a given site are typically rare, so we can encode the observed variation among millions of samples by storing the genealogy together with a relatively small number of mutations. The resulting savings in storage space are dramatic. <xref ref-type="fig" rid="fig1">Fig. 1C</xref> shows the space required to store variation data for simulations of up to 10 million human-like chromosomes, extrapolated out to 10 billion. In this idealised case, storing the genotype data in the most widely used format (VCF) would require 23PiB (i.e., approximately 23,000 1TiB hard disks) whereas the tree sequence encoding would require only around 1TiB. Thus, if we were able to store variation data using the tree sequence encoding we could store and process any conceivable data set on a present-day laptop.</p>
<fig id="fig1" position="float">
<label>Figure 1</label>
<caption><p>Comparison of tree sequences with standard methods for storing genetic variation data. A). The variant matrix which underlies conventional storage methods for genetic variation data. B). A genealogical encoding for data; if we know the tree we can store each variant site in constant space. C). Estimated sizes of files required to store the genetic variation data for a simulated human-like chromosome (100 megabases) for up to 10 billion haploid (5 billion diploid) samples. Simulations were run for 10<sup>1</sup> up to 10<sup>7</sup> haplotypes using <monospace>msprime</monospace> [<xref ref-type="bibr" rid="c25">Kelleher et al., 2016</xref>], and the sizes of the resulting files plotted (points). In each case we show the original tree sequence file uncompressed and compressed. We also show the corresponding variation data encoded in the standard VCF [<xref ref-type="bibr" rid="c8">Danecek et al., 2011</xref>] and compressed using gzip. The VCF files for 10<sup>7</sup> samples were too large and time-consuming to process. The projected file sizes for VCF/compressed VCF are based on fitting a simple exponential model. Projected files sizes for tree sequences are based on fitting a model based on the theoretical growth of tree sequences [<xref ref-type="bibr" rid="c25">Kelleher et al., 2016</xref>]. In all cases, the largest data point was withheld from fitting.</p>
</caption>
<graphic xlink:href="458067_fig1.tif"/></fig>
<p>Converting data into a highly compressed form usually requires costly decompression before use. A great advantage of the tree sequence encoding is that we can compute many statistics directly from the trees without decoding the genotypes. For example, computing the frequency of specific variants within subsets is a key building-block of many genetic statistics, and in particular is a fundamental operation when performing genome-wide association studies [<xref ref-type="bibr" rid="c33">Manolio, 2013</xref>]. The algorithm for recovering trees from the encoded tree sequence representation allows us to compute such allele frequencies far more efficiently than is possible when working with a raw matrix representation of the data [<xref ref-type="bibr" rid="c25">Kelleher et al., 2016</xref>]. Take, for example, the largest tree sequence simulated in <xref ref-type="fig" rid="fig1">Figure 1</xref>, which represents a simulated history of 10<sup>7</sup> chromosomes of 100Mb each. It takes about 2.2 seconds to load this 1.2GiB tree sequence; about 7.5 seconds to iterate over all 650K trees; and about 17 seconds to compute allele frequencies within an arbitrary subset of 10<sup>6</sup> samples at all 670K sites. In contrast, just decompressing and decoding the corresponding 6.1 TiB of genotype data from BCF (a more efficient binary compressed encoding of VCF) would require an estimated 1.8 hours (based on extracting the first 10K variants using cyvcf2 [<xref ref-type="bibr" rid="c42">Pedersen and Quinlan, 2017</xref>]). Moreover, BCF and other existing formats for storing variant data do not consider ancestry in any way. If we wished to store the actual trees from this simulation of 10<sup>7</sup> samples using the most efficient and popular interchange format (Newick), we would need approximately 256 TiB of space and it would take an estimated 5.3 CPU years to parse (based on BioPython&#x2019;s [<xref ref-type="bibr" rid="c7">Cock et al., 2009</xref>] Newick parser&#x2014;one of the most efficient available&#x2014;taking about 262 seconds per tree).</p>
</sec>
<sec id="s2b">
<title>Inference algorithm</title>
<p>DNA sequences can be considered mosaics of sequence fragments that have been inherited from recent ancestors via an error-prone copying process. Likewise, these recent ancestors are themselves mosaics, copied imperfectly from yet older ancestors. As we go further back in time these ancestral sequence fragments (or haplotypes) become shorter, as recombination randomly breaks up the contributions of different ancestors over the generations. Our method is based on the premise that if these ancestral haplotypes were known, it would be possible to infer a plausible copying history for large numbers of input DNA sequences. Critically, this approach means that we do not need to compare sample hap-lotypes with each other, and we avoid the quadratic time complexity that this implies (which for large data sets, is insurmountable).</p>
<p>We do not usually know these ancestral haplotypes, but we can attempt to infer them. If we assume that the contemporary variation we observe at each site on the genome is the result of a single mutation, then we know that every sample haplotype that has the mutated (or derived) state at this site must have inherited it from a single ancestor. Moreover, these samples will also have inherited some fragment of the ancestral haplotype <italic>around</italic> the focal site. For mutations that recently arose, this shared haplotype will tend to be long, as recombination will not have had time to break it up. Conversely, for ancient mutations the shared ancestral haplotype will tend to be rather short (<xref ref-type="fig" rid="fig2">Fig. 2</xref>).</p>
<fig id="fig2" position="float">
<label>Figure 2</label>
<caption><p>A schematic of the major steps of the inference algorithm. Starting from a set of sample haplotypes extending over the genome (1), we use the ancestral haplotype inference method (2) to reconstruct fragments of ancestral sequence (3), then infer copying paths among these ancestors (4). The ancestral copying process is shown on the right, using an arbitrary haplotype (<italic>p</italic>) for illustration. As we move from left to right along <italic>p</italic> we infer that it has most recently copied from <italic>j</italic>, <italic>e</italic>, <italic>c</italic> and then <italic>m</italic>. Incorporating the copying history of all older haplotypes (for example, <italic>m</italic> copied partly from <italic>c</italic> and partly from <italic>h</italic>), partial coalescent trees emerge in the bottom-right panel. Once copying paths have been found for all ancestors and samples, we output a <monospace>tskit</monospace> tree sequence(5).</p>
</caption>
<graphic xlink:href="458067_fig2.tif"/></fig>
<p>The first step in our algorithm is to generate ancestral haplotypes based on the variation present in the sample sequences. The approach that we use to estimate ancestors is a simple heuristic, which we describe in detail in the Methods. Briefly, we first use the frequency of the derived state at each site as an approximation of the relative age of the corresponding ancestor (we assume that the ancestral and derived states are known). Then, for each ancestor we work outwards from the focal site taking a consensus value among samples carrying the derived state at the focal site. Although heuristic, this method is reasonably accurate and robust to errors (<xref ref-type="fig" rid="figS3">Fig. S3</xref>). Furthermore, the approach for generating ancestors is independent of later steps in the algorithm and improved methods can be developed.</p>
<p>After we have estimated ancestral haplotypes, we must then infer how they relate to each other. We do this using a variation of the Li and Stephens (LS) model [<xref ref-type="bibr" rid="c30">Li and Stephens, 2003</xref>], one of the most important techniques in contemporary large-scale genomics [<xref ref-type="bibr" rid="c31">Lunter, 2018</xref>]. The LS model regards a haplotype as an imperfect mosaic of the haplotypes in a reference panel, and is defined using a Hidden Markov Model (HMM). The most likely path for a given hap-lotype through the reference panel is found using standard HMM algorithms, and the time required to find such paths scales linearly with the number of hap-lotypes in the reference panel. For a given ancestral haplotype, our reference panel consists of all older ancestral haplotypes. Because our reference haplo-types are ancestral rather than contemporary, we make a slight modification to the standard LS process: alongside the usual 0/1 states, a third haplotypic state is used to represent non-ancestral material from which copying can never occur. Computing the most likely path under the LS model allows us to estimate the immediate ancestor for each segment of DNA in the focal haplotype. <xref ref-type="fig" rid="fig2">Figure 2B</xref> shows an example of such a copying path for a focal haplotype and how it copies from different ancestors along its length. Once we have found copying paths for all of our ancestors and all of the input sample haplotypes, we are guaranteed to have complete genealogical trees for every position along the genome, albeit ones that may contain nonbinary nodes (&#x201C;polytomies&#x201D;). Furthermore, these copying paths map directly to &#x2018;edges&#x2019; in the tree sequence formulation [<xref ref-type="bibr" rid="c26">Kelleher et al., 2018</xref>], and so the copying process directly generates a succinct tree sequence. The output tree sequence may optionally be &#x201C;simplified&#x201D; [<xref ref-type="bibr" rid="c26">Kelleher et al., 2018</xref>] to remove any generated ancestral segments unreachable from the sample nodes. Representing the ancestral haplotypes as a tree sequence lends significant flexibility, as it allows us to combine information from diverse sources; for example, we can use a tree sequence estimated from one data set as ancestors for another (see Applications).</p>
<p>The correspondence between the output of the copying process and a tree sequence is also critical to scalability. Because each non-singleton input site usually corresponds to a single ancestor, the reference panel we match against may contain millions of ancestral haplotypes. Furthermore, this reference panel must be dynamically updated to include more and more ancestors, as our strict time ordering requirements result in haplotypes being able to copy from all older haplotypes. Such requirements are far beyond existing methods for finding likely paths under the LS model, which either require time that is linear in the reference panel size or a linear time preprocessing step [<xref ref-type="bibr" rid="c31">Lunter, 2018</xref>]. The key technical advance that makes our method feasible for large samples is an exact solution of the LS HMM that uses the partially built genealogies to greatly speed up calculations (see the Methods for details).</p>
</sec>
<sec id="s2c">
<title>Algorithm evaluation</title>
<p>We evaluate <monospace>tsinfer</monospace> for accuracy and scalability using simulated data. We perform population genetic simulations which output a tree sequence as a .trees file. These encode both the simulated genealogies, which we use as a ground-truth, and sample haplotypes, which we use for inference. We compare <monospace>tsinfer</monospace> to three other tools for ancestral inference. <monospace>ARGweaver</monospace> [<xref ref-type="bibr" rid="c45">Rasmussen et al., 2014</xref>] is the most statistically rigorous, and is considered state-of-the-art. Rent&#x002B; [<xref ref-type="bibr" rid="c36">Mirzaei and Wu, 2016</xref>] is a heuristic method that is considerably faster than <monospace>ARGweaver</monospace>. Finally, fastARG (<ext-link ext-link-type="uri" xlink:href="https://github.com/lh3/fastARG">https://github.com/lh3/fastARG</ext-link>) is an unpublished method using an approach similar to Margarita [<xref ref-type="bibr" rid="c35">Minichiello and Durbin, 2006</xref>]; we include fastARG in this analysis because it is by far the most scalable method currently available. A degree of error is inevitable in DNA sequence data and methods must be reasonably robust to be relevant to empirical data. We therefore impose a genotyping error process derived from an empirical analysis [<xref ref-type="bibr" rid="c2">Albers and McVean, 2018</xref>] on the simulated haplotypes (leading to an observed error of around 0.35&#x0025;), and assess the performance of tools with and without the presence of these simulated errors.</p>
<p>We evaluate the accuracy of the different methods by comparing estimated tree topologies with the original simulated trees. We use the Kendall-Colijn tree distance metric [<xref ref-type="bibr" rid="c27">Kendall and Colijn, 2016</xref>], as it is more sensitive than alternative metrics (<xref ref-type="fig" rid="figS5">Fig. S5</xref>) and is robust to the presence of non-binary nodes in trees (see Methods for details). As <monospace>tsinfer</monospace> does not currently try to estimate node times, we only consider topological similarity and disregard branch lengths. <xref ref-type="fig" rid="fig3">Fig. 3</xref> compares the accuracy of <monospace>tsinfer</monospace> against other tools on simulated data, with and without simulated genotyping error, for a variety of different mutation to recombination rate ratios. As we increase the mutation rate the accuracy of the inferred trees increases for all tools, because more mutations reveal more information about the underlying tree topologies (we generate mutations under the infinitely-many-sites model and so cannot have recurrent mutations). In this evaluation <monospace>tsinfer</monospace> is substantially more accurate than <monospace>Rent&#x002B;</monospace> and <monospace>fastARG</monospace>, both with and without error. We can also see that <monospace>tsinfer</monospace> produces more accurate topologies than <monospace>ARGweaver</monospace> when the mutation rate is lower than the recombination rate, and has comparable accuracy with higher mutation rates; however, <monospace>ARGweaver</monospace> is somewhat more robust to the presence of errors than <monospace>tsinfer</monospace>. Similar results are obtained when we simulate more complex demography in <xref ref-type="fig" rid="figS6">Fig. S6.</xref> In contrast, <xref ref-type="fig" rid="figS7">Fig. S7</xref> shows that <monospace>tsinfer</monospace>&#x2019;s inference accuracy is substantially higher than <monospace>ARGweaver</monospace>&#x2019;s in the presence of a selective sweep, suggesting that our nonparametric approach is more robust to such departures from the assumptions of the coalescent model.</p>
<fig id="fig3" position="float">
<label>Figure 3</label>
<caption><p>Accuracy of ancestry inference under different methods (lower values indicate greater accuracy). Coalescent simulations for 16 sample haplotypes of 1Mb in length under human-like parameters (<italic>N<sub>e</sub></italic> &#x003D; 5000, with recombination rate <italic>&#x03C1;</italic> &#x003D; 10<sup>&#x2212;8</sup> per base per generation) and an infinite sites model of mutation were simulated using <monospace>msprime</monospace> [<xref ref-type="bibr" rid="c25">Kelleher et al., 2016</xref>]. The reported tree topology distance is the Kendall-Colijn metric, weighted by the genomic distance spanned by each tree. Each point is the average of 100 independent replicates at a given mutation rate. The point where mutation rate equals recombination rate (similar to humans) is marked with a vertical dotted line. Standard errors are smaller than the plotted symbols in all cases.</p>
</caption>
<graphic xlink:href="458067_fig3.tif"/></fig>
<p>It is notable how small the data sets used to compare these tools are: we are using 8 diploid samples, and, where the mutation equals the recombination rate, an average of 662 variant sites. This is driven by necessity as <monospace>ARGweaver</monospace> is very CPU intensive. <xref ref-type="fig" rid="figS9">Supplementary Fig. S9</xref> shows how the CPU time scales for these tools for up to 100 samples, and illustrates the vast differences in processing time required: <monospace>ARGweaver</monospace> requires hours while <monospace>fastARG</monospace> and <monospace>tsinfer</monospace> require fractions of a second. <monospace>Rent&#x002B;</monospace> is substantially faster than <monospace>ARGweaver</monospace>, but is still orders of magnitude slower than <monospace>fastARG</monospace> and <monospace>tsinfer</monospace>. Although <monospace>fastARG</monospace> is slightly faster than <monospace>tsinfer</monospace> for tiny data sets, <xref ref-type="fig" rid="figS10">Fig. S10</xref> shows that <monospace>tsinfer</monospace> is far more efficient for inference involving tens of thousands of mammalian-scale chromosomes.</p>
<p>Succinct tree sequences have great potential as a means of storing genetic variation data, as simulated tree sequence files are many times smaller than the corresponding compressed genotype matrices for large sample sizes (<xref ref-type="fig" rid="fig1">Fig. 1</xref>). To evaluate <monospace>tsinfer</monospace>&#x2019;s compression performance on large-scale data we inferred tree sequences from simulated sequence data and compared the size of the inferred .trees files to the equivalent compressed VCF (<xref ref-type="fig" rid="figS11">Fig. S11</xref>). While compression performance varies with the ratio of mutation to recombination rate, in our example of 100K samples, sequences greater then 50Mb in length have inferred tree sequence files ranging from 10-20 times smaller than the corresponding compressed VCF. <xref ref-type="fig" rid="figS12">Fig. S12</xref> shows that in many cases <monospace>tsinfer</monospace> can estimate large-scale tree sequences that are even smaller that the original simulated files.</p>
</sec>
<sec id="s2d">
<title>Applications</title>
<p>To evaluate <monospace>tsinfer</monospace>&#x2019;s performance on empirical data we constructed tree sequences for three data sets on human chromosome 20: the 1000 Genomes Project (TGP), consisting of low-coverage whole genome sequencing data from 2504 individuals across 26 worldwide populations [<xref ref-type="bibr" rid="c1">1000 Genomes Project Consortium, 2015</xref>]; the Simons Genome Diversity Project (SGDP), consisting of high coverage sequencing data from 278 individuals from 142 worldwide populations [<xref ref-type="bibr" rid="c32">Mallick et al., 2016</xref>]; and the UK Biobank (UKB), consisting of SNP array data from 487,327 individuals within the UK [<xref ref-type="bibr" rid="c5">Bycroft et al., 2018</xref>]. <xref ref-type="table" rid="tbl1">Table 1</xref> summarises input data, inferred tree sequences and computing resources required. For UKB, we considered multiple strategies, augmenting the data with ancestors inferred from TGP and subsets of haplotypes from the UKB itself as potential ancestors. For each data set we used statistically inferred haplotypes as input.</p>
<table-wrap id="tbl1" position="float">
<label>Table 1</label>
<caption><p>Summary of input data, output tree sequences and computing resources required for TGP, SGDP and UKB chromosome 20. Input sizes reported are of <monospace>tsinfer</monospace>&#x2019;s input .samples files, which uses the Zarr library (<ext-link ext-link-type="uri" xlink:href="https://zarr.readthedocs.io/">https://zarr.readthedocs.io/</ext-link>) to achieve similar compression levels to BCF. File sizes are reported using binary multipliers (i.e., 1M &#x003D; 2<sup>20</sup> bytes); all other values use decimal multipliers (i.e., 1M &#x003D; 10<sup>6</sup>). The times reported are the total wall clock time required to produce the output tree sequence from the <monospace>.samples</monospace> file on a server with two Xeon Gold 6148 CPUs (40 cores in total; no hyperthreading) and 187GiB of RAM. For SGDP, TGP and UKB we used the standard <monospace>tsinfer</monospace> inference pipeline. In UKB&#x002B;TGP, we matched the UKB samples to the inferred TGP tree sequence (time reported is just for sample matching phase). In UKB&#x002B;UKB we incrementally added samples from UKB to the ancestors inferred from UKB (see text).</p></caption>
<graphic xlink:href="458067_tbl1.tif"/>
</table-wrap>
<p>Across chromosome 20, the TGP data consisted of 860K sites after filtering (see Methods for details). After inferring ancestors and matching sample haplotypes to these ancestors, we obtain a 297MiB tree sequence (109MiB compressed, compared to the 141MiB BCF encoding of the same genotypes). Loading the tree sequence required c. 3 seconds; iterating over all 550K trees c. 0.6 seconds; and decoding all genotypes c. 9 seconds. In comparison, decoding the same genotypes from BCF required c. 15 seconds using cyvcf2. The SGDP data consisted of 348K sites after filtering, and this resulted in an 83MiB tree sequence (28MiB compressed, compared to 11MiB BCF encoding of the same genotypes). Loading the tree sequence required c. 1.6 seconds; iterating over all 196K trees c. 0.1 seconds; and decoding all genotypes c. 1.8 seconds. These results demonstrate the feasibility of representing existing data sets through tree sequences, with file sizes comparable to current standards and excellent analytical accessibility.</p>
<p>To assess the validity of the inferred tree sequences we computed a series of metrics summarising reconstructed ancestral relationships. We first calculated the number of edges for each sample, which measures the extent to which an individual&#x2019;s genome can be compressed against the inferred ancestors. In TGP, samples have an average of 648 edges (with a median length of 44kb and an average N50 of 236kb), with those of African ancestry having a greater number (750) than those of European (551) or Asian (665) ancestry (<xref ref-type="fig" rid="figS13">Fig. S13A</xref> and <xref ref-type="fig" rid="figS14">Fig. S14</xref>). These findings are likely to primarily reflect known differences in the long-term effective population size, though will also be affected by sampling strategy and error modes. We find higher values in SGDP reflecting the lower sample sizes (overall average: 1113 edges, African ancestry: 2178, European ancestry: 803 and Asian ancestry: 879; <xref ref-type="fig" rid="figS13">Fig. S13B</xref> and <xref ref-type="fig" rid="figS15">Fig. S15</xref>). In both data sets we identified a few outlier samples with very high edge counts, suggesting error (see Methods).</p>
<p>We next considered whether the inferred tree sequences could be used to characterise ancestral relationships in TGP and SGDP by computing, for each individual, the population distribution of their genealogical nearest neighbours</p>
<p>(GNN). Given <italic>K</italic> sets of reference nodes (e.g., the samples for each of the 26 TGP populations), the GNN statistic for a specific node is a <italic>K</italic>-vector describing the proportion of its immediate neighbours within the tree from each of these reference sets (see Methods). We find that, despite the noise generated by uncertainty in tree reconstruction (manifest as polytomies), the chance nature of the genealogical process and data error, the tree sequences can characterise global population structure (<xref ref-type="fig" rid="fig4">Fig. 4A, B</xref>), within-population relatedness (<xref ref-type="fig" rid="fig4">Fig. 4C</xref>) and identify regions of differential ancestry within an individual (<xref ref-type="fig" rid="fig4">Fig. 4D</xref>). These analyses demonstrate the potential of interrogating the inferred genealogical structure at different resolutions to describe both broad and fine-scale patterns in contemporary human genomic diversity. The statistics involved can be calculated very efficiently: using 8 threads, computing GNNs for every sample required c. 16 and 30s, respectively, for the SGDP and TGP data sets (Xeon Gold 6148 CPU).</p>
<fig id="fig4" position="float">
<label>Figure 4</label>
<caption><p>Tree sequence characterisation of global genome diversity. A). Z-score normalised GNN proportions for SGDP by population. The GNN matrix was first z-score normalised by column and the rows then hierarchically clustered. See <xref ref-type="fig" rid="figS16">Fig. S16</xref> for a larger version with population labels. B). As for (A), but for the TGP data. C). Average GNN proportions for all individuals within the PEL population in TGP. Colours indicate continental-level groupings. D). The approximate GNN proportions across the chromosome for the two haplotypes of HG01933, from the PEL population in TGP. HG01933 was chosen as an example of an individual showing evidence of very recent admixture.</p>
</caption>
<graphic xlink:href="458067_fig4.tif"/></fig>
<p>Finally, to assess the performance of <monospace>tsinfer</monospace> on vast data sets we analysed the &#x223C;500K individuals within UK Biobank. The sparsity of variant sites and inherent lack of rare variants in the UKB SNP array data is insufficient for accurate ancestor inference directly. However, we considered two alternative strategies: using ancestors estimated from other data and using subsets of the sample to act as proxies for ancestors. In the first approach, we matched the UKB haplotypes to the tree sequence inferred for the TGP, generating a 5.8GiB tree sequence (2.1GiB compressed). <xref ref-type="fig" rid="fig5">Fig 5A</xref> shows the self-reported ancestry in UKB tallies with TGP GNN values and adds granularity. Furthermore, by analysing the copying patterns in this tree sequence, we found 9 individuals that are likely to be in both the TGP and UKB data sets (see Methods).</p>
<fig id="fig5" position="float">
<label>Figure 5</label>
<caption><p>Tree sequence characterisation of the UK Biobank data. A). Ancestral relationships captured from GNN proportions in the tree sequence constructed from TGP data, relative to TGP populations, organised by self-reported ancestry. Rows are clustered hierarchically. B). Z-score normalised GNN proportions in the tree sequence constructed by iteratively augmenting UKB derived ancestors with sample haplotypes for 629,246 haplotypes self-reported as of British ancestry (the 262,142 sample haplotypes used for ancestor augmentation were removed from this analysis). The GNN proportions here were calculated relative to sample enrolment centre, i.e., reporting the fraction of each sample&#x2019;s genealogical nearest neighbours that enrolled at a given centre. The columns in the GNN matrix were z-score normalised before the rows were hierarchically clustered.</p>
</caption>
<graphic xlink:href="458067_fig5.tif"/></fig>
<p>Our second strategy for improving ancestor inference involves sequentially adding subsets of the sample itself as potential ancestors, which we deployed to investigate structure within the UKB. By iteratively adding more and more samples, our method of generating putative ancestors from shared recombination breakpoints (&#x201C;path compression&#x201D;; see Methods) is able to construct many more ancestors that would be possible if we added all of the extra samples at once. Thus, we began by updating the ancestor&#x2019;s tree sequence with the paths for two arbitrarily chosen samples; then updating the resulting tree sequence with the paths taken for four other samples; and then again for eight; and so on up to 131,072. After matching all 1M sample haplotypes against these augmented ancestors we obtained a 2.1GiB tree sequence (928MiB compressed, compared to the equivalent 1.4GiB BCF file). Loading this tree sequence required c. 9 seconds and iterating over all 15.8K trees c. 11 seconds. Decoding genotypes for the first 1000 sites required 9.5 seconds; in comparison, decoding the genotypes for the first 1000 sites in the original BGEN file using the bgen C library required 49 seconds. Analysis of the GNN structure of the tree sequence demonstrates strong geographical clustering of relatedness at this level of resolution, with connections between enrolment centres reflecting geographical proximity (for example connections between centres within Scotland and Wales; <xref ref-type="fig" rid="fig5">Fig. 5B</xref>). Although signals of population structure are evident here, further work is required to understand the implications for statistical analysis of association.</p>
</sec>
</sec>
<sec id="s3">
<title>Discussion</title>
<p>Inferring genealogical relationships among individuals from patterns of genomic variation is a long-standing problem in evolutionary biology that connects to many of the fundamental forces and events that shape a species, including mutation, recombination, demographic processes and natural selection. However, our ability to infer such histories has, to date, been limited by the computational complexity of the problem. The work presented here represents a major advance by providing a principled, yet scalable approach that can be applied to data sets of unprecedented size. While the algorithms presented are both heuristic and deterministic, the approach of breaking down the problem into inferring relative variant age, ancestral haplotypes and the genealogical relationships between these ancestors results in a modular framework that scales to vast sample sizes (<xref ref-type="fig" rid="figS10">Fig. S10</xref>). Moreover, each component can be improved independently, even potentially accommodating uncertainty through stochastic approaches.</p>
<p>Nevertheless, the method does make a number of fundamental assumptions. First, we assume that each variant in a population has a single mutational origin. While this is unlikely to be true in practice (particularly in large samples), our ancestor estimation method is likely to find the dominant ancestral hap-lotype. Recurrent and back mutations will therefore not be handled well by the current algorithm, though in principle could be addressed by iterative approaches. Second, we assume that frequency is a proxy for relative variant age. Importantly, our algorithms only require accuracy about relative age within genealogically connected parts of the tree sequence. Under simple demographic models, we estimate that relative frequency indicates relative age for roughly 90&#x0025; of closely located pairs of variants (<xref ref-type="fig" rid="figS1">Fig. S1</xref>). In theory, methods for dating genomic variants could be used to improve ancestor estimation and also assign dates to nodes within the tree sequence, though these remain open problems. Third, we assume that the ratio of mutation to recombination is sufficiently high to use mutations as the starting point for ancestor inference. However, the path compression approach used here (see Methods) essentially identifies additional ancestors through shared recombination events and, within the SNP array analysis on UKB, has been shown to perform well, compensating for the low variant density and lack of rare variants. Finally, the current methodology works well for low error rates, but its performance is degraded by genotyping and, in particular, haplotype phasing error. In the future, population-scale high coverage and routine long-read genome sequencing will reduce the source of such errors and it may be feasible to construct steps of the algorithm that are more robust than those currently implemented.</p>
<p>Tree sequences have multiple potential applications. The most obvious is as an efficient lossless storage format for population-scale data sets. While compression performance on simulated data (<xref ref-type="fig" rid="figS11">Fig. S11</xref>) is close to the theoretical possibilities shown in <xref ref-type="fig" rid="fig1">Fig. 1</xref>, <monospace>tsinfer</monospace>&#x2019;s compression of real data does not currently fulfil this great potential. More careful modelling of the complexities of genetic data&#x2014;in particular the various error modes&#x2014;will likely be required to effectively compress millions of whole genomes. Nonetheless, compression performance is comparable to existing formats while providing exceptional analytical accessibility. The integration of genealogical relationships with genomic variation data has value beyond population and personal genetics, for example in potentially correcting for the differential geographical confounding of rare and common variants in genetic association. However, the combined analysis of the UKB and TGP data sets demonstrates the potential of also using tree sequences to integrate data sources and, more generally, to build a reference tree sequence structure for human genomic variation that can be updated as new variants are discovered. Such a structure, coupled with efficient algorithms that make use of the tree structure, such as the LS algorithm deployed here, could enable (and make optimally powerful) diverse statistical genetic operations including genotype refinement, genotype imputation and haplotype phasing. It could also be used to share data effectively and in a manner that preserves privacy, by describing data sets in terms of representation of ancestors rather than individual samples.</p>
</sec>
<sec id="s4">
<title>Methods</title>
<sec id="s4a">
<title>Age of alleles</title>
<p>The first step in our algorithm is to estimate the relative time at which the mutation for each variant arose (we are assuming a single origin for each mutation). Classical results in population genetics provide a theoretical expectation for the age of an allele based on its frequency [<xref ref-type="bibr" rid="c28">Kimura and Ota, 1973</xref>, <xref ref-type="bibr" rid="c15">Griffiths and Tavare, 1998</xref>]. There are several existing methods for estimating allele age, but are either computationally expensive or require detailed knowledge about historical population processes [<xref ref-type="bibr" rid="c40">Ormond et al., 2015</xref>, <xref ref-type="bibr" rid="c38">Nakagome et al., 2016</xref>, <xref ref-type="bibr" rid="c47">Smith et al., 2018</xref>], although a more efficient non-parametric method has recently been introduced [<xref ref-type="bibr" rid="c2">Albers and McVean, 2018</xref>].</p>
<p>For our purposes, frequency provides a computationally inexpensive and surprisingly accurate proxy for relative allele age (<xref ref-type="fig" rid="figS1">Fig. S1</xref>). This is because we only need the age ordering of alleles to be <italic>locally</italic> accurate: if variants on opposite ends of a chromosome are incorrectly ordered it makes little difference to the outcome of our algorithms, since the ancestral haplotypes involved are unlikely to overlap. Although these estimates could certainly be improved by using the methods mentioned above, our current algorithms for inferring ancestral hap-lotypes and computing copying paths require a single origin for each mutation. The frequency estimate coupled with our algorithm for generating ancestral haplotypes (see the next subsection) guarantees this property, simplifying the overall process.</p>
</sec>
<sec id="s4b">
<title>Inferring ancestral haplotypes</title>
<p>Once we have assigned an age order to sites, the next step in our inference process is to generate a set of putative ancestral haplotypes. We assume that there are two alleles at every site: the &#x2018;ancestral state&#x2019;, which was inherited from the ancestor of the entire population and the &#x2018;derived state&#x2019; which is the result of a mutation that occurred on the ancestor of the samples carrying this allele. We assume that these ancestral and derived states have been identified via existing methods (e.g., <xref ref-type="bibr" rid="c24">Keightley and Jackson [2018]</xref>). Each variant site is therefore the result of a mutation that occurred on an ancestor: samples that inherit from this ancestor have the derived state, and the rest carry the ancestral state. By definition this ancestor carries the derived state at the site in question; our task then is to reconstruct the state of the ancestor <italic>around</italic> this focal site.</p>
<p>For a given focal site <italic>l</italic> let <italic>S</italic> be the set of samples that carry the derived state. We are attempting to reconstruct the ancestral haplotype <italic>a</italic> on which the mutation occurred, and so we begin by setting <italic>a<sub>l</sub></italic> &#x003D; 1, following the usual convention of labelling the ancestral state for a site 0 and the derived state 1. For all other sites 1 &#x2264; <italic>k</italic> &#x2264; <italic>m</italic>, <italic>k</italic> &#x2260; <italic>l</italic> we set <italic>a<sub>k</sub></italic> &#x003D; &#x2212;1, indicating non-ancestral material that cannot be copied from; these non-ancestral values will be overwritten for sites around <italic>l</italic> where we can estimate the state of the ancestor. We then work leftwards and rightwards from <italic>l</italic> independently, computing the state of the ancestor at each site. The set <italic>S</italic> initially contains the samples that we believe descend from the current ancestor (assuming infinite sites and no error), and we use this set to compute a plausible state at other sites. As recombination modifies the tree topology, we update <italic>S</italic> to remove samples that are no longer in the clade induced by the focal site. We stop moving left or right from the focal site when we judge that we no longer have sufficient information to construct the ancestral haplotype. We use heuristics to determine when to remove a particular sample from <italic>S</italic> and when to end the ancestral haplotype.</p>
<p><xref ref-type="fig" rid="figS2">Figure S2</xref> illustrates a simplified example of this process, showing the ancestral haplotype estimated at the focal site 8. We begin by setting <italic>S</italic> &#x003D; &#x007B;<italic>e</italic>, <italic>f</italic>, <italic>g</italic>, <italic>h</italic>&#x007D;, i.e. the set of samples that carry the derived allele at site 8. We then proceed rightwards, considering each site in turn. For younger sites, the corresponding mutation cannot have occurred yet by definition, and so we always set the ancestor to 0 at these sites (e.g. 9 and 10). When we reach a site that is older than the focal one, we compute a plausible value for our ancestor by taking the consensus among the samples in <italic>S</italic>. For example, at site 11 the estimated value for the ancestor is 1 because all haplotypes in <italic>S</italic> carry 1; similarly, at site 13, three of four samples in S carry 1, and so the consensus is 1 (the consensus can also be 0, as in site 4). We interpret disagreement with the consensus value as evidence that the samples in question have recombined away to another part of the tree. Thus, after we have computed the ancestor&#x2019;s state at a site remove any samples from S (&#x201C;evict&#x201D;) that conflict with this consensus (but see below for a slight modification used in practise). In the example, we therefore evict <italic>h</italic> at site 13 and <italic>g</italic> at site 17. We continue rightwards in this way until we determine that we have insufficient information to accurately estimate ancestors. The heuristic we have chosen is to stop when the size of <italic>S</italic> is &#x2264; half of its original size. After completing the rightwards scan, we then repeat the process independently leftwards.</p>
<p>Variants with an age equal to the focal mutation are considered to be younger than the focal site (and hence always assigned the ancestral state) except in one special case. If several sites exist with precisely equal distribution of genotypes, we assume that these all arose on a single branch of the tree and that no recombination occurred between these sites. We therefore compute consensus values for older sites between these identical focal sites in the usual way, but we do not update <italic>S</italic> when conflicts occur (assuming these to be caused by error). Once outside of the region enclosed by the identical sites, the process outlined above resumes and we update <italic>S</italic> in the usual way.</p>
<p>Although this method is approximate and heuristic, it generates surprisingly accurate ancestors. <xref ref-type="fig" rid="figS3">Fig. S3</xref> shows a plot of the lengths of the estimated vs true ancestors from simulations, colour-coded by the accuracy of the estimated states. We see that there is a strong bias towards ancestral haplotypes being longer than the truth; this is by design, as long haplotypes can be compensated for by the copying process, but short haplotypes cannot. Inferred haplotypes are also quite accurate, with many ancestors being inferred perfectly. The process is reasonably robust to genotyping errors, but these can create one notable issue for the algorithm illustrated in <xref ref-type="fig" rid="figS2">Figure S2</xref>: some generated ancestors are too short, because errors can lead to samples being prematurely evicted from <italic>S</italic>. To add some resilience to this, we include a slight &#x201C;dampening&#x201D; to our eviction rule: we remove a sample from <italic>S</italic> only if it disagrees with the consensus at two consecutive older sites.</p>
</sec>
<sec id="s4c">
<title>Copying process</title>
<p>Given an input haplotype with <italic>m</italic> sites and a reference panel of <italic>n</italic> haplotypes, the most likely path under the Li and Stephens (LS) model is found using the Viterbi algorithm. In the first phase of this process we proceed site-by-site from left to right. At each site, we compute the likelihood that the input haplotype has copied from a particular reference haplotype given their states and the most likely haplotype at the previous site. Once we have reached the last site and we know the most likely reference haplotype at the end of the sequence, we then trace back through the sites, switching to other haplotypes where required. The overall time complexity is therefore <italic>O</italic>(<italic>nm</italic>) to find a copying path for an input haplotype, since we must compare with all <italic>n</italic> reference haplotypes at each of the m sites. In <monospace>tsinfer</monospace> the reference panel is the set of inferred ancestral haplotypes. Because we may have a different ancestor for every site, n &#x2248; m, and the time complexity of finding a copying path for an ancestor is therefore <italic>O</italic>(<italic>m</italic><sup>2</sup>). Modern sequencing data sets contain millions of variant sites and standard LS methods are therefore not feasible.</p>
<p>In <monospace>tsinfer</monospace> we use the LS model to find a Viterbi path for an input haplotype through the set of ancestors. Each copying path generated is equivalent to a set of edges in a tree sequence [<xref ref-type="bibr" rid="c26">Kelleher et al., 2018</xref>] where the child is the focal haplotype and the parents are copied ancestors. Therefore, as we go forwards in time finding copying paths for younger and younger ancestors, we are also incrementally building a tree sequence encoding the state of these ancestors. We use this partially built tree sequence representing a subset of the ancestors as the substrate for computing LS copying paths for subsequent ancestors. The powerful computational properties of the tree sequence data structure allow us to find exact copying paths far more efficiently than is possible using standard methods.</p>
<p>The algorithm for computing Viterbi paths using a tree sequence works in the same way as the standard method. We first proceed from left-to-right, computing a likelihood of copying from each ancestor at every site and recording the locations of potential recombination events. Once we have reached the last site, we trace back as before, resolving a full copying path from the stored information. The difference in our method is that we avoid needing to compute and store a likelihood for each reference haplotype by using the tree sequence to compress the associated likelihoods. Each ancestor corresponds to a node in the marginal tree at a given site, and we compress the likelihoods by marking any node that has the same likelihood as its parent with a special value. The number of distinct likelihoods on the tree is then small, and we can store a list of the nodes that represent whole subtrees. Updating the likelihoods at a given site is then straightforward. We compute the likelihood for each node by reasoning about the state of the input haplotype and the location of the site&#x2019;s mutation in the tree. Having updated the likelihoods for the nodes corresponding to the compressed subtrees, we can then recompress to take into account the new likelihood values and proceed to the next site. In many cases, moving to the next site will also involve a change in the tree topology and we redistribute the compressed likelihoods accordingly using logic common to other tree sequence algorithms [<xref ref-type="bibr" rid="c25">Kelleher et al., 2016</xref>, <xref ref-type="bibr" rid="c26">2018</xref>]. In the interest of simplicity our current implementation does not include a &#x2018;mismatch&#x2019; term and only allows for exact haplotype matching. Under these assumptions, we need only five discrete values to encode the node likelihoods in our LS Viterbi algorithm, simplifying the logic considerably. Adding the mismatch term is not difficult (it was present in earlier versions of the algorithm) and we plan to include it in subsequent versions of <monospace>tsinfer</monospace>. This overview of the LS model on tree sequences is necessarily brief and imprecise, as a full treatment is beyond the scope of this paper. A detailed description and analysis of the generalised model is planned for future work, along with an efficient implementation in <monospace>tskit</monospace>.</p>
<p>To validate the correctness of our implementation of the copying process, we devised a strong test which we call &#x2018;perfect inference&#x2019;. In this test we begin with a simulated tree sequence with no mutations and derive the true ancestral segments from it. We then add a specific pattern of mutations that are designed to precisely identify the endpoints of each ancestor and use the resulting ancestral haplotypes as input to <monospace>tsinfer</monospace>. We then find copying paths for these ancestors and samples in the usual way. Remarkably, using this method we are able to perfectly reproduce the input tree sequence topology, recovering every marginal tree and recombination breakpoint exactly for arbitrarily large inputs. Indeed, the numerical tables [<xref ref-type="bibr" rid="c26">Kelleher et al., 2018</xref>] representing the input and output tree sequences are byte-for-byte identical. This is both a strong test for the correctness of our implementation and a reassuring validation of the overall method: if we have accurate ancestors we converge on the true ancestry.</p>
</sec>
<sec id="s4d">
<title>Path compression</title>
<p>The algorithm for inferring ancestors discussed above is mainly based on the signal arising from mutations, and is only weakly informed by recombination. However, we can also derive information about the ancestors of our sample from recombination events. If we assume that each recombination event is unique, i.e., that all samples that inherit the local haplotype resulting from a breakpoint did so from a single ancestor, we can then estimate the state of this ancestor. Note that this is equivalent to assuming an &#x2018;infinite-sites&#x2019; like model for recombinations, an idea with a long history [<xref ref-type="bibr" rid="c12">Fisher, 1954</xref>]. We use this signal of shared recombination breakpoints in a specific way, which we refer to as &#x2018;path compression&#x2019;.</p>
<p>When generating copying paths for successive ancestors, we will often find that subsets of two or more paths are identical. Such identical path subsets is strong evidence for the existence of a single ancestor that consisted of the concatenation of the corresponding haplotype segments. We therefore add this &#x2018;synthetic&#x2019; ancestor, and adjust the original identical path subsets to copy from the newly inserted ancestor. Ancestors corresponding to a given allele age are inserted at the same time, and path compression is run at the end of each of these time slices.</p>
<p><xref ref-type="fig" rid="figS4">Fig. S4</xref> shows a simple example of this process where we compress the shared path subset for the ancestors <italic>g</italic>, <italic>h</italic>, <italic>i</italic>, and <italic>j</italic> into single edges pointing to a new synthetic ancestor. In the top panel we can see (e.g.) that <italic>g</italic> has the copying path (5,12, <italic>c</italic>), (12, 22, <italic>d</italic>), (22, 28, <italic>b</italic>) and <italic>h</italic>, <italic>i</italic> and <italic>j</italic> also contain this path. We therefore create a new ancestor <italic>s</italic> which consists of this path and replace the mappings for <italic>g</italic>, <italic>h</italic>, <italic>i</italic>, and <italic>j</italic> with the single edge (5, 28, <italic>s</italic>). In this way we reduce the overall number of edges required to represent the history, and also provide an extra ancestor for subsequent haplotypes to match against.</p>
</sec>
<sec id="s4e">
<title>Inference accuracy</title>
<p>We compare the accuracy of <monospace>tsinfer</monospace> against other inference methods using simulation. We begin by simulating a set of tree sequences which provide the ground-truth topologies. We assess the effect of genotyping errors on inference accuracy by simulating errors on the haplotypes using an empirically determined genotyping error profile [<xref ref-type="bibr" rid="c2">Albers and McVean, 2018</xref>]. We then input the corresponding haplotypes (with and without simulated genotyping errors) to the various tools, and measure the difference between the estimated and true tree topologies using tree distance metrics. We repeat this process independently for four tools: <monospace>tsinfer</monospace>, <monospace>ARGweaver</monospace>, <monospace>Rent&#x002B;</monospace> and <monospace>fastARG</monospace>. <monospace>ARGweaver</monospace> requires several parameters to be specified: in all cases we use the known simulation values for the effective population size, mutation and recombination rates. We use the default number of timesteps for time discretisation (20) and for each simulation sample 10 ARGs (one every 20 MCMC cycles) after a burn-in period of 1000 cycles.</p>
<p>Although the succinct tree sequence data structure can fully represent node timing (and hence branch length) information, <monospace>tsinfer</monospace> does not currently attempt to accurately infer the times of ancestors. Therefore, we limit our investigation of the accuracy of inference to assessing the quality of the inferred topologies, and do not consider timing information in any way. <xref ref-type="fig" rid="figS5">Fig. S5</xref> compares the accuracy of the tools over a number of tree topology distance metrics. For each replicate simulation we compute the average distance between pairs of true and inferred trees along the sequence, weighted by the distance along the sequence that these trees persist. We then report the average distance over the replicate simulations. Metrics are calculated using the R packages <monospace>treespace</monospace> [<xref ref-type="bibr" rid="c23">Jombart et al., 2017</xref>] and <monospace>phangorn</monospace> [<xref ref-type="bibr" rid="c46">Schliep, 2011</xref>]. Some metrics (such as Robinson-Foulds) are undefined for trees that contain non-binary nodes (&#x201C;polytomies&#x201D;), which indicate uncertainty in <monospace>tsinfer</monospace> and therefore occur frequently. To use these metrics in a well-defined way, we also show results where <monospace>tsinfer</monospace> trees have been randomly resolved into fully bifurcating trees (taking the mean distance over 10 replicates). The Kendall-Colijn (KC) metric provides the greatest discrimination and is well defined for all tree topologies, and so we use this metric exclusively in subsequent analyses. At low mutation rates, there is a notable difference between the accuracy of <monospace>tsinfer</monospace>&#x2019;s inferred trees when we use the standard KC metric and when we randomly break polytomies before measuring the distance between the trees. This is because there is little information available to resolve the nodes, and generating a random binary subtree on average results in something that is further from the truth than the original polytomy. Thus, <monospace>tsinfer</monospace>&#x2019;s innate strategy of using polytomies to indicate uncertainty in a principled and systematic way has a significant advantage over methods that always fully resolve trees.</p>
<p>To evaluate the sensitivity of <monospace>tsinfer</monospace> to changes in the underlying simulation model, we also tested accuracy on more complex simulations. In <xref ref-type="fig" rid="figS6">Fig. S6</xref> we show results of simulations of the three population Out-of-Africa model of human demography [<xref ref-type="bibr" rid="c19">Gutenkunst et al., 2009</xref>]. In this case, <monospace>tsinfer</monospace> does not seem to be affected by the underlying population structure and is a little more accurate than <monospace>ARGweaver</monospace> (although <monospace>ARGweaver</monospace> is less affected by error). In <xref ref-type="fig" rid="figS7">Fig. S7</xref> we show inference accuracy on a simulated selective sweep, where we performed forward time simulations using simuPop [<xref ref-type="bibr" rid="c43">Peng and Kimmel, 2005</xref>] and ftprime [<xref ref-type="bibr" rid="c26">Kelleher et al., 2018</xref>]. In this case, <monospace>tsinfer</monospace> is substantially more accurate than the other tools after the advantageous mutation has swept to a reasonable frequency and also for many generations after fixation. In <xref ref-type="fig" rid="figS8">Fig. S8</xref> we show the effect of running inference on a subset of the available haplotypes on <monospace>tsinfer</monospace>&#x2019;s accuracy. We see that in the absence of error, having extra samples has little effect on the accuracy of inferences, but that larger samples can potentially help to correct for the presence of genotyping errors. This provides additional justification for using large sample sizes for ancestral inference.</p>
<p>To evaluate the computational performance of the different inference methods we measured the total user time and maximum memory usage (taking the mean over replicates). All experiments were run on a server with two Xeon E5-2680 CPUs and 256GiB of RAM. <xref ref-type="fig" rid="figS9">Fig. S9</xref> shows the CPU time required for all four tools for varying sample sizes. The disparity in the running times is too large to show on a single scale, and <monospace>tsinfer</monospace> and <monospace>fastARG</monospace> are many times faster than <monospace>ARGweaver</monospace> and <monospace>Rent&#x002B;</monospace>. <xref ref-type="fig" rid="figS10">Fig. S10</xref> compares <monospace>tsinfer</monospace> and <monospace>fastARG</monospace> at a much larger scale, where <monospace>tsinfer</monospace> shows far better scaling in terms of CPU time and memory when increasing both sequence length and sample size. Empirically, <monospace>tsinfer</monospace>&#x2019;s running time grows approximately linearly with sample size and super-linearly with sequence length on simulated data (<xref ref-type="fig" rid="figS10">Fig. S10</xref>).</p>
<p>All code for running the evaluations, including the precise version of each tool used, is included in the accompanying GitHub repository (<ext-link ext-link-type="uri" xlink:href="https://github.com/mcveanlab/treeseq-inference/">https://github.com/mcveanlab/treeseq-inference/</ext-link>).</p>
</sec>
<sec id="s4f">
<title>Genealogical nearest neighbours</title>
<p>In our analysis of human data sets we use the genealogical nearest neighbours (GNN) statistic, which we define here. Let &#x1D54B; be a tree sequence where each tree <italic>t</italic> &#x220A; &#x1D54B; covers a length <italic>L<sup>t</sup></italic> units of genetic sequence. Define <italic>L</italic> &#x003D; &#x03A3;<sub><italic>t</italic>&#x220A;&#x1D54B;</sub> <italic>L<sup>t</sup></italic>. Let <italic>R</italic> be a list of <italic>K</italic> sets of &#x201C;reference nodes&#x201D;, and let <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458067_inline1.gif"/></alternatives></inline-formula> be the number of nodes ancestral to (and including) <italic>u</italic> in tree <italic>t</italic> from the set <italic>R<sub>k</sub></italic>, with CU <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458067_inline2.gif"/></alternatives></inline-formula>. Then define
<disp-formula id="ueqn1">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458067_ueqn1.gif"/></alternatives>
</disp-formula>
where <italic>v</italic> is the first node in <italic>t</italic> on the path to root from <italic>u</italic> such that <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458067_inline3.gif"/></alternatives></inline-formula>, and [x] is an Iversonian condition such that [x] &#x003D; 0 if x is false and [x] &#x003D; 1 otherwise.</p>
</sec>
<sec id="s4g">
<title>Empirical data preparation</title>
<p>All human data used is relative to the GRCh37 reference. We used ancestral states from Ensembl release 75, as this is the most recent version available for GRCh37. For each data set we processed the downloaded variation data to produce a .samples file used as input to <monospace>tsinfer</monospace>. In this preprocessing step we kept only biallelic SNPs with a high-confidence ancestral state and with phased calls for all samples. Any singleton or invariant sites were discarded as these provide no information about topology. Sites with frequency (<italic>n</italic> &#x2014; 1) were also discarded as these are likely to be highly enriched for miscalled ancestral states. Details of the data sources used and a fully automated pipeline for obtaining public data sets, preprocessing the variation data and constructing the tree sequences are included in the accompanying GitHub repository (<ext-link ext-link-type="uri" xlink:href="https://github.com/mcveanlab/treeseq-inference/">https://github.com/mcveanlab/treeseq-inference/</ext-link>).</p>
</sec>
<sec id="s4h">
<title>Outlier samples</title>
<p>We observed two particularly large outliers when considering the number of sample edges per individual in the TGP data set: NA20289 from the ASW population and HG02789 from PJL (see <xref ref-type="fig" rid="figS13">Figs. S13</xref> and <xref ref-type="fig" rid="figS14">S14</xref>). Both parental nodes for NA20289 have roughly double the number of sample edges as the population mean. The physical position of the breakpoints of the parental nodes of NA20289 seemingly reflects an abundance of phasing switch errors, potentially explaining this finding. At the location of a phasing switch error, the parental nodes of a sample would swap the ancestors they were copying from, resulting in a far greater number of sample edges than if phasing error had not occurred. When considering all TGP samples, the average paternal and maternal node breakpoints were within 100 base pairs of each other only 32 times in the unsimplified tree sequence, while in NA20289 this occurred approximately 551 times. HG02789 showed only 30 breakpoints within 100 base pairs of one another, which is unsurprising since only one parental node exhibited a high number of sample edges.</p>
<p>In the SGDP data set we observed the S-Naxi-2 had a highly elevated sample edge count. Since this sample also had no associated metadata, we removed it from the analysis.</p>
</sec>
<sec id="s4i">
<title>Duplicate UKB/TGP samples</title>
<p>We observed 9 individuals in the UKB data set that are likely to also be in TGP. Using the (unsimplified) UKB&#x002B;TGP tree sequence, we first found outliers with low numbers of sample edges. Then, from the pool of samples with fewer than 50 edges where they are children, we extracted those for which both nodes in an individual were present (i.e., both maternal and paternal nodes have unusually low sample edge counts). This left a total of 9 candidate individuals; for 8 of these, both nodes of the UKB individual copied from a single node of a TGP individual over 97&#x0025; of the sequence length (mostly &#x003E; 99&#x0025;). The nodes in the UKB and TGP individuals paired up exactly, signifying that the phasing for these individuals is in agreement in the two data sets. In the 9th individual we observed very high copying (&#x003E; 97&#x0025;) from a single TGP individual, but with switches between the two nodes. Let <italic>p</italic><sub>1</sub> and <italic>p</italic><sub>2</sub> are the parental nodes in the TGP individual; we observed 61&#x0025; copying from pi and 37&#x0025; from <italic>p</italic><sub>2</sub> in the first node of the UKB individual, and 60&#x0025; copying from <italic>p</italic><sub>2</sub> and 38&#x0025; from <italic>p</italic><sub>1</sub> in the second. This is likely to indicate phasing errors for this individual in one of the data sets.</p>
<p>This analysis required 42 seconds of CPU time to run using simple Python code.</p>
</sec>
</sec>
</body>
<back>
<ack>
<p><bold>Acknowledgements</bold></p>
<p>This work was supported by the Wellcome Trust [100956/Z/13/Z]. We would like to thank John Novembre and Peter Ralph for helpful comments on earlier drafts of this manuscript. Thanks also to Peter Ralph and Kevin Thornton for many useful discussions on tree sequence algorithms.</p>
</ack>
<sec id="s5" sec-type="availability">
<title>Availability</title>
<p>All code used to run evaluations in this paper is available at <ext-link ext-link-type="uri" xlink:href="https://github.com/mcveanlab/treeseq-inference">https://github.com/mcveanlab/treeseq-inference</ext-link>. <monospace>Tsinfer</monospace> is freely available under the terms of the GNU GPL; see the documentation at <ext-link ext-link-type="uri" xlink:href="https://tsinfer.readthedocs.io/">https://tsinfer.readthedocs.io/</ext-link> for further details.</p>
</sec>
<ref-list>
<title>References</title>
<ref id="c1"><mixed-citation publication-type="other"><collab>1000 Genomes Project Consortium</collab>. <article-title>A global reference for human genetic variation</article-title>. <source>Nature</source>, <volume>526</volume>(<issue>7571</issue>):<fpage>68</fpage>&#x2013;<lpage>74</lpage>, <year>2015</year>.</mixed-citation></ref>
<ref id="c2"><mixed-citation publication-type="website"><string-name><given-names>P. K.</given-names> <surname>Albers</surname></string-name> and <string-name><given-names>G.</given-names> <surname>McVean</surname></string-name>. <article-title>Dating genomic variants and shared ancestry in population-scale sequencing data</article-title>. <source>bioRxiv</source>, <year>2018</year>. doi: <pub-id pub-id-type="doi">10.1101/416610</pub-id>. URL <ext-link ext-link-type="uri" xlink:href="https://www.biorxiv.org/content/early/2018/09/13/416610">https://www.biorxiv.org/content/early/2018/09/13/416610</ext-link>.</mixed-citation></ref>
<ref id="c3"><mixed-citation publication-type="journal"><string-name><given-names>M.</given-names> <surname>Arenas</surname></string-name>. <article-title>The importance and application of the ancestral recombination graph</article-title>. <source>Fron Genet</source>, <volume>4</volume>:<fpage>206</fpage>, <year>2013</year>.</mixed-citation></ref>
<ref id="c4"><mixed-citation publication-type="journal"><string-name><given-names>M.</given-names> <surname>Bordewich</surname></string-name> and <string-name><given-names>C.</given-names> <surname>Semple</surname></string-name>. <article-title>On the computational complexity of the rooted subtree prune and regraft distance</article-title>. <source>Annals of combinatorics</source>, <volume>8</volume>(<issue>4</issue>):<fpage>409</fpage>&#x2013;<lpage>423</lpage>, <year>2005</year>.</mixed-citation></ref>
<ref id="c5"><mixed-citation publication-type="journal"><string-name><given-names>C.</given-names> <surname>Bycroft</surname></string-name>, <string-name><given-names>C.</given-names> <surname>Freeman</surname></string-name>, <string-name><given-names>D.</given-names> <surname>Petkova</surname></string-name>, <string-name><given-names>G.</given-names> <surname>Band</surname></string-name>, <string-name><given-names>L. T.</given-names> <surname>Elliott</surname></string-name>, <string-name><given-names>K.</given-names> <surname>Sharp</surname></string-name>, <string-name><given-names>A.</given-names> <surname>Motyer</surname></string-name>, <string-name><given-names>D.</given-names> <surname>Vukcevic</surname></string-name>, <string-name><given-names>O.</given-names> <surname>Delaneau</surname></string-name>, <string-name><given-names>J.</given-names> <surname>O&#x2019;Connell</surname></string-name>, <etal>et al.</etal> <article-title>The UK Biobank resource with deep phenotyping and genomic data</article-title>. <source>Nature</source>, (<issue>562</issue>):<fpage>203</fpage>&#x2013;<lpage>209</lpage>, <year>2018</year>.</mixed-citation></ref>
<ref id="c6"><mixed-citation publication-type="journal"><string-name><given-names>G.</given-names> <surname>Cardona</surname></string-name>, <string-name><given-names>F.</given-names> <surname>Rossell&#x00F3;</surname></string-name>, and <string-name><given-names>G.</given-names> <surname>Valiente</surname></string-name>. <article-title>Extended Newick: it is time for a standard representation of phylogenetic networks</article-title>. <source>BMC Bioinformatics</source>, <volume>9</volume>: <fpage>532</fpage>, <year>2008</year>.</mixed-citation></ref>
<ref id="c7"><mixed-citation publication-type="journal"><string-name><given-names>P. J. A.</given-names> <surname>Cock</surname></string-name>, <string-name><given-names>T.</given-names> <surname>Antao</surname></string-name>, <string-name><given-names>J. T.</given-names> <surname>Chang</surname></string-name>, <string-name><given-names>B. A.</given-names> <surname>Chapman</surname></string-name>, <string-name><given-names>C. J.</given-names> <surname>Cox</surname></string-name>, <string-name><given-names>A.</given-names> <surname>Dalke</surname></string-name>, <string-name><given-names>I.</given-names> <surname>Friedberg</surname></string-name>, <string-name><given-names>T.</given-names> <surname>Hamelryck</surname></string-name>, <string-name><given-names>F.</given-names> <surname>Kauff</surname></string-name>, <string-name><given-names>B.</given-names> <surname>Wilczynski</surname></string-name>, and <string-name><given-names>M. J. L. de</given-names> <surname>Hoon</surname></string-name>. <article-title>Biopython: freely available Python tools for computational molecular biology and bioinformatics</article-title>. <source>Bioinformatics</source>, <volume>25</volume>(<issue>11</issue>):<fpage>1422</fpage>&#x2013;<lpage>1423</lpage>, <year>2009</year>.</mixed-citation></ref>
<ref id="c8"><mixed-citation publication-type="journal"><string-name><given-names>P.</given-names> <surname>Danecek</surname></string-name>, <string-name><given-names>A.</given-names> <surname>Auton</surname></string-name>, <string-name><given-names>G.</given-names> <surname>Abecasis</surname></string-name>, <string-name><given-names>C. A.</given-names> <surname>Albers</surname></string-name>, <string-name><given-names>E.</given-names> <surname>Banks</surname></string-name>, <string-name><given-names>M. A.</given-names> <surname>DePristo</surname></string-name>, <string-name><given-names>R. E.</given-names> <surname>Handsaker</surname></string-name>, <string-name><given-names>G.</given-names> <surname>Lunter</surname></string-name>, <string-name><given-names>G. T.</given-names> <surname>Marth</surname></string-name>, <string-name><given-names>S. T.</given-names> <surname>Sherry</surname></string-name>, <etal>et al.</etal> <article-title>The variant call format and vcftools</article-title>. <source>Bioinformatics</source>, <volume>27</volume>(<issue>15</issue>):<fpage>2156</fpage>&#x2013;<lpage>2158</lpage>, <year>2011</year>.</mixed-citation></ref>
<ref id="c9"><mixed-citation publication-type="book"><string-name><given-names>C.</given-names> <surname>Darwin</surname></string-name>. <source>Charles Darwins notebooks, 1836-1844: Geology, transmutation of species, metaphysical enquiries</source>. <publisher-loc>Ithaca</publisher-loc>: <publisher-name>Cambridge University Press</publisher-name>, <year>1987</year>.</mixed-citation></ref>
<ref id="c10"><mixed-citation publication-type="journal"><string-name><given-names>P.</given-names> <surname>Fearnhead</surname></string-name> and <string-name><given-names>P.</given-names> <surname>Donnelly</surname></string-name>. <article-title>Estimating recombination rates from population genetic data</article-title>. <source>Genetics</source>, <volume>159</volume>(<issue>3</issue>):<fpage>1299</fpage>&#x2013;<lpage>1318</lpage>, <year>2001</year>.</mixed-citation></ref>
<ref id="c11"><mixed-citation publication-type="book"><string-name><given-names>J.</given-names> <surname>Felsenstein</surname></string-name>. <source>Inferring phylogenies</source>. <publisher-name>Sinauer Associates, Inc</publisher-name>., <year>2004</year>.</mixed-citation></ref>
<ref id="c12"><mixed-citation publication-type="journal"><string-name><given-names>R. A.</given-names> <surname>Fisher</surname></string-name>. <article-title>A fuller theory of &#x201C;junctions&#x201D; in inbreeding</article-title>. <source>Heredity</source>, <volume>8</volume>:<fpage>187</fpage>&#x2013;<lpage>197</lpage>, <year>1954</year>.</mixed-citation></ref>
<ref id="c13"><mixed-citation publication-type="journal"><string-name><given-names>R. C.</given-names> <surname>Griffiths</surname></string-name>. <article-title>The two-locus ancestral graph</article-title>. <source>Lecture Notes-Monograph Series</source>, pages <fpage>100</fpage>&#x2013;<lpage>117</lpage>, <year>1991</year>.</mixed-citation></ref>
<ref id="c14"><mixed-citation publication-type="journal"><string-name><given-names>R. C.</given-names> <surname>Griffiths</surname></string-name> and <string-name><given-names>P.</given-names> <surname>Marjoram</surname></string-name>. <article-title>Ancestral inference from samples of dna sequences with recombination</article-title>. <source>Journal of Computational Biology</source>, <volume>3</volume>(<issue>4</issue>):<fpage>479</fpage>&#x2013;<lpage>502</lpage>, <year>1996</year>.</mixed-citation></ref>
<ref id="c15"><mixed-citation publication-type="journal"><string-name><given-names>R. C.</given-names> <surname>Griffiths</surname></string-name> and <string-name><given-names>S.</given-names> <surname>Tavare</surname></string-name>. <article-title>The age of a mutation in a general coalescent tree</article-title>. <source>Communications in Statistics. Stochastic Models</source>, <volume>14</volume>(<issue>1-2</issue>):<fpage>273</fpage>&#x2013;<lpage>295</lpage>, <month>Jan</month>. <year>1998</year>.</mixed-citation></ref>
<ref id="c16"><mixed-citation publication-type="book"><string-name><given-names>D.</given-names> <surname>Gusfield</surname></string-name>. <source>ReCombinatorics: the algorithmics of ancestral recombination graphs and explicit phylogenetic networks</source>. <publisher-name>MIT Press</publisher-name>, <year>2014</year>.</mixed-citation></ref>
<ref id="c17"><mixed-citation publication-type="journal"><string-name><given-names>D.</given-names> <surname>Gusfield</surname></string-name>, <string-name><given-names>S.</given-names> <surname>Eddhu</surname></string-name>, and <string-name><given-names>C.</given-names> <surname>Langley</surname></string-name>. <article-title>Optimal, efficient reconstruction of phylogenetic networks with constrained recombination</article-title>. <source>Journal of bioinformatics and computational biology</source>, <volume>2</volume>(<issue>01</issue>):<fpage>173</fpage>&#x2013;<lpage>213</lpage>, <year>2004</year>.</mixed-citation></ref>
<ref id="c18"><mixed-citation publication-type="journal"><string-name><given-names>D.</given-names> <surname>Gusfield</surname></string-name>, <string-name><given-names>V.</given-names> <surname>Bansal</surname></string-name>, <string-name><given-names>V.</given-names> <surname>Bafna</surname></string-name>, and <string-name><given-names>Y. S.</given-names> <surname>Song</surname></string-name>. <article-title>A decomposition theory for phylogenetic networks and incompatible characters</article-title>. <source>Journal of Computational Biology</source>, <volume>14</volume>(<issue>10</issue>):<fpage>1247</fpage>&#x2013;<lpage>1272</lpage>, <year>2007</year>.</mixed-citation></ref>
<ref id="c19"><mixed-citation publication-type="journal"><string-name><given-names>R. N.</given-names> <surname>Gutenkunst</surname></string-name>, <string-name><given-names>R. D.</given-names> <surname>Hernandez</surname></string-name>, <string-name><given-names>S. H.</given-names> <surname>Williamson</surname></string-name>, and <string-name><given-names>C. D.</given-names> <surname>Bustamante</surname></string-name>. <article-title>Inferring the joint demographic history of multiple populations from multidimensional snp frequency data</article-title>. <source>PLOS Genetics</source>, <volume>5</volume>(<issue>10</issue>):<fpage>1</fpage>&#x2013;<lpage>11</lpage>, <year>2009</year>.</mixed-citation></ref>
<ref id="c20"><mixed-citation publication-type="book"><string-name><given-names>E.</given-names> <surname>Haeckel</surname></string-name>. <source>Generelle morphologie der organismen</source>., volume <volume>II</volume>. <publisher-name>Berlin, G. Reimer</publisher-name>, <year>1866</year>.</mixed-citation></ref>
<ref id="c21"><mixed-citation publication-type="journal"><string-name><given-names>J.</given-names> <surname>Hein</surname></string-name>. <article-title>Reconstructing evolution of sequences subject to recombination using parsimony</article-title>. <source>Mathematical biosciences</source>, <volume>98</volume>(<issue>2</issue>):<fpage>185</fpage>&#x2013;<lpage>200</lpage>, <year>1990</year>.</mixed-citation></ref>
<ref id="c22"><mixed-citation publication-type="journal"><string-name><given-names>C. E.</given-names> <surname>Hinchliff</surname></string-name>, <string-name><given-names>S. A.</given-names> <surname>Smith</surname></string-name>, <string-name><given-names>J. F.</given-names> <surname>Allman</surname></string-name>, <string-name><given-names>J. G.</given-names> <surname>Burleigh</surname></string-name>, <string-name><given-names>R.</given-names> <surname>Chaudhary</surname></string-name>, <string-name><given-names>L. M.</given-names> <surname>Coghill</surname></string-name>, <string-name><given-names>K. A.</given-names> <surname>Crandall</surname></string-name>, <string-name><given-names>J.</given-names> <surname>Deng</surname></string-name>, <string-name><given-names>B. T.</given-names> <surname>Drew</surname></string-name>, <string-name><given-names>R.</given-names> <surname>Gazis</surname></string-name>, <string-name><given-names>K.</given-names> <surname>Gude</surname></string-name>, <string-name><given-names>D. S.</given-names> <surname>Hibbett</surname></string-name>, <string-name><given-names>L. A.</given-names> <surname>Katz</surname></string-name>, <string-name><given-names>H. D.</given-names> <surname>Laughinghouse</surname></string-name>, <string-name><given-names>E. J.</given-names> <surname>McTavish</surname></string-name>, <string-name><given-names>P. E.</given-names> <surname>Midford</surname></string-name>, <string-name><given-names>C. L.</given-names> <surname>Owen</surname></string-name>, <string-name><given-names>R. H.</given-names> <surname>Ree</surname></string-name>, <string-name><given-names>J. A.</given-names> <surname>Rees</surname></string-name>, <string-name><given-names>D. E.</given-names> <surname>Soltis</surname></string-name>, <string-name><given-names>T.</given-names> <surname>Williams</surname></string-name>, and <string-name><given-names>K. A.</given-names> <surname>Cranston</surname></string-name>. <article-title>Synthesis of phylogeny and taxonomy into a comprehensive tree of life</article-title>. <source>Proceedings of the National Academy of Sciences</source>, <volume>112</volume>(<issue>41</issue>):<fpage>12764</fpage>&#x2013;<lpage>12769</lpage>, <year>2015</year>. doi: <pub-id pub-id-type="doi">10.1073/pnas.1423041112</pub-id>.</mixed-citation></ref>
<ref id="c23"><mixed-citation publication-type="journal"><string-name><given-names>T.</given-names> <surname>Jombart</surname></string-name>, <string-name><given-names>M.</given-names> <surname>Kendall</surname></string-name>, <string-name><given-names>J.</given-names> <surname>Almagro-Garcia</surname></string-name>, and <string-name><given-names>C.</given-names> <surname>Colijn</surname></string-name>. <article-title><monospace>treespace</monospace>: Statistical exploration of landscapes of phylogenetic trees</article-title>. <source>Molecular Ecology Resources</source>, <volume>17</volume>:<fpage>1385</fpage>&#x2013;<lpage>1392</lpage>, <year>2017</year>.</mixed-citation></ref>
<ref id="c24"><mixed-citation publication-type="journal"><string-name><given-names>P. D.</given-names> <surname>Keightley</surname></string-name> and <string-name><given-names>B. C.</given-names> <surname>Jackson</surname></string-name>. <article-title>Inferring the probability of the derived versus the ancestral allelic state at a polymorphic site</article-title>. <source>Genetics</source>, pages genetics-301120, <year>2018</year>.</mixed-citation></ref>
<ref id="c25"><mixed-citation publication-type="journal"><string-name><given-names>J.</given-names> <surname>Kelleher</surname></string-name>, <string-name><given-names>A. M.</given-names> <surname>Etheridge</surname></string-name>, and <string-name><given-names>G.</given-names> <surname>McVean</surname></string-name>. <article-title>Efficient coalescent simulation and genealogical analysis for large sample sizes</article-title>. <source>PLoS computational biology</source>, <volume>12</volume>(<issue>5</issue>):<fpage>e1004842</fpage>, <year>2016</year>.</mixed-citation></ref>
<ref id="c26"><mixed-citation publication-type="journal"><string-name><given-names>J.</given-names> <surname>Kelleher</surname></string-name>, <string-name><given-names>K.</given-names> <surname>Thornton</surname></string-name>, <string-name><given-names>J.</given-names> <surname>Ashander</surname></string-name>, and <string-name><given-names>P.</given-names> <surname>Ralph</surname></string-name>. <article-title>Efficient pedigree recording for fast population genetics simulation</article-title>. <source>bioRxiv</source>, page <fpage>248500</fpage>, <year>2018</year>.</mixed-citation></ref>
<ref id="c27"><mixed-citation publication-type="journal"><string-name><given-names>M.</given-names> <surname>Kendall</surname></string-name> and <string-name><given-names>C.</given-names> <surname>Colijn</surname></string-name>. <article-title>Mapping phylogenetic trees to reveal distinct patterns of evolution</article-title>. <source>Molecular biology and evolution</source>, <volume>33</volume>(<issue>10</issue>):<fpage>2735</fpage>&#x2013;<lpage>2743</lpage>, <year>2016</year>.</mixed-citation></ref>
<ref id="c28"><mixed-citation publication-type="journal"><string-name><given-names>M.</given-names> <surname>Kimura</surname></string-name> and <string-name><given-names>T.</given-names> <surname>Ota</surname></string-name>. <article-title>The age of a neutral mutant persisting in a finite population</article-title>. <source>Genetics</source>, <volume>75</volume>(<issue>1</issue>):<fpage>199</fpage>&#x2013;<lpage>212</lpage>, <month>Sept</month>. <year>1973</year>.</mixed-citation></ref>
<ref id="c29"><mixed-citation publication-type="journal"><string-name><given-names>M. K.</given-names> <surname>Kuhner</surname></string-name>, <string-name><given-names>J.</given-names> <surname>Yamato</surname></string-name>, and <string-name><given-names>J.</given-names> <surname>Felsenstein</surname></string-name>. <article-title>Maximum likelihood estimation of recombination rates from population data</article-title>. <source>Genetics</source>, <volume>156</volume>(<issue>3</issue>):<fpage>1393</fpage>&#x2013;<lpage>1401</lpage>, <year>2000</year>.</mixed-citation></ref>
<ref id="c30"><mixed-citation publication-type="journal"><string-name><given-names>N.</given-names> <surname>Li</surname></string-name> and <string-name><given-names>M.</given-names> <surname>Stephens</surname></string-name>. <article-title>Modeling linkage disequilibrium and identifying recombination hotspots using single-nucleotide polymorphism data</article-title>. <source>Genetics</source>, <volume>165</volume>(<issue>4</issue>):<fpage>2213</fpage>&#x2013;<lpage>2233</lpage>, <year>2003</year>.</mixed-citation></ref>
<ref id="c31"><mixed-citation publication-type="website"><string-name><given-names>G.</given-names> <surname>Lunter</surname></string-name>. <article-title>Haplotype matching in large cohorts using the li and stephens model</article-title>. <source>Bioinformatics</source>, page bty735, <year>2018</year>. doi: <pub-id pub-id-type="doi">10.1093/bioinformatics/bty735</pub-id>. URL <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1093/bioinformatics/bty735">http://dx.doi.org/10.1093/bioinformatics/bty735</ext-link>.</mixed-citation></ref>
<ref id="c32"><mixed-citation publication-type="journal"><string-name><given-names>S.</given-names> <surname>Mallick</surname></string-name>, <string-name><given-names>H.</given-names> <surname>Li</surname></string-name>, <string-name><given-names>M.</given-names> <surname>Lipson</surname></string-name>, <string-name><given-names>I.</given-names> <surname>Mathieson</surname></string-name>, <string-name><given-names>M.</given-names> <surname>Gymrek</surname></string-name>, <string-name><given-names>F.</given-names> <surname>Racimo</surname></string-name>, <string-name><given-names>M.</given-names> <surname>Zhao</surname></string-name>, <string-name><given-names>N.</given-names> <surname>Chennagiri</surname></string-name>, <string-name><given-names>S.</given-names> <surname>Nordenfelt</surname></string-name>, <string-name><given-names>A.</given-names> <surname>Tandon</surname></string-name>, <etal>et al.</etal> <article-title>The simons genome diversity project: 300 genomes from 142 diverse populations</article-title>. <source>Nature</source>, <volume>538</volume>(<issue>7624</issue>):<fpage>201</fpage>, <year>2016</year>.</mixed-citation></ref>
<ref id="c33"><mixed-citation publication-type="journal"><string-name><given-names>T. A.</given-names> <surname>Manolio</surname></string-name>. <article-title>Bringing genome-wide association findings into clinical use</article-title>. <source>Nat Rev Genet</source>, <volume>14</volume>(<issue>8</issue>):<fpage>549</fpage>&#x2013;<lpage>558</lpage>, <year>2013</year>.</mixed-citation></ref>
<ref id="c34"><mixed-citation publication-type="journal"><string-name><given-names>J. R.</given-names> <surname>McGill</surname></string-name>, <string-name><given-names>E. A.</given-names> <surname>Walkup</surname></string-name>, and <string-name><given-names>M. K.</given-names> <surname>Kuhner</surname></string-name>. <article-title>GraphML specializations to codify ancestral recombinant graphs</article-title>. <source>Fron Genet</source>, <volume>4</volume>:<fpage>146</fpage>, <year>2013</year>.</mixed-citation></ref>
<ref id="c35"><mixed-citation publication-type="journal"><string-name><given-names>M. J.</given-names> <surname>Minichiello</surname></string-name> and <string-name><given-names>R.</given-names> <surname>Durbin</surname></string-name>. <article-title>Mapping trait loci by use of inferred ancestral recombination graphs</article-title>. <source>The American Journal of Human Genetics</source>, <volume>79</volume>(<issue>5</issue>): <fpage>910</fpage>&#x2013;<lpage>922</lpage>, <year>2006</year>.</mixed-citation></ref>
<ref id="c36"><mixed-citation publication-type="journal"><string-name><given-names>S.</given-names> <surname>Mirzaei</surname></string-name> and <string-name><given-names>Y.</given-names> <surname>Wu</surname></string-name>. <article-title><monospace>Rent&#x002B;</monospace>: an improved method for inferring local genealogical trees from haplotypes with recombination</article-title>. <source>Bioinformatics</source>, <volume>33</volume>(<issue>7</issue>): <fpage>1021</fpage>&#x2013;<lpage>1030</lpage>, <year>2016</year>.</mixed-citation></ref>
<ref id="c37"><mixed-citation publication-type="journal"><string-name><given-names>D. A.</given-names> <surname>Morrison</surname></string-name>. <article-title>Genealogies: Pedigrees and phylogenies are reticulating networks not just divergent trees</article-title>. <source>Evolutionary biology</source>, <volume>43</volume>(<issue>4</issue>):<fpage>456</fpage>&#x2013;<lpage>473</lpage>, <year>2016</year>.</mixed-citation></ref>
<ref id="c38"><mixed-citation publication-type="journal"><string-name><given-names>S.</given-names> <surname>Nakagome</surname></string-name>, <string-name><given-names>G.</given-names> <surname>Alkorta-Aranburu</surname></string-name>, <string-name><given-names>R.</given-names> <surname>Amato</surname></string-name>, <string-name><given-names>B.</given-names> <surname>Howie</surname></string-name>, <string-name><given-names>B. M.</given-names> <surname>Peter</surname></string-name>, <string-name><given-names>R. R.</given-names> <surname>Hudson</surname></string-name>, and <string-name><given-names>A. Di</given-names> <surname>Rienzo</surname></string-name>. <article-title>Estimating the Ages of Selection Signals from Different Epochs in Human History</article-title>. <source>Molecular Biology and Evolution</source>, <volume>33</volume>(<issue>3</issue>): <fpage>657</fpage>&#x2013;<lpage>669</lpage>, <month>Feb</month>. <year>2016</year>.</mixed-citation></ref>
<ref id="c39"><mixed-citation publication-type="journal"><string-name><given-names>B. D.</given-names> <surname>O&#x2019;Fallon</surname></string-name>. <article-title>ACG: rapid inference of population history from recombining nucleotide sequences</article-title>. <source>BMC bioinformatics</source>, <volume>14</volume>(<issue>1</issue>):<fpage>40</fpage>, <year>2013</year>.</mixed-citation></ref>
<ref id="c40"><mixed-citation publication-type="journal"><string-name><given-names>L.</given-names> <surname>Ormond</surname></string-name>, <string-name><given-names>M.</given-names> <surname>Foll</surname></string-name>, <string-name><given-names>G. B.</given-names> <surname>Ewing</surname></string-name>, <string-name><given-names>S. P.</given-names> <surname>Pfeifer</surname></string-name>, and <string-name><given-names>J. D.</given-names> <surname>Jensen</surname></string-name>. <article-title>Inferring the age of a fixed beneficial allele</article-title>. <source>Molecular Ecology</source>, <volume>25</volume>(<issue>1</issue>):<fpage>157</fpage>&#x2013;<lpage>169</lpage>, <month>Dec</month>. <year>2015</year>.</mixed-citation></ref>
<ref id="c41"><mixed-citation publication-type="journal"><string-name><given-names>L.</given-names> <surname>Parida</surname></string-name>, <string-name><given-names>M.</given-names> <surname>Mel&#x00E9;</surname></string-name>, <string-name><given-names>F.</given-names> <surname>Calafell</surname></string-name>, <string-name><given-names>J.</given-names> <surname>Bertranpetit</surname></string-name>, and <string-name><given-names>G.</given-names> <surname>Consortium</surname></string-name>. <article-title>Estimating the ancestral recombinations graph (arg) as compatible networks of snp patterns</article-title>. <source>Journal of Computational Biology</source>, <volume>15</volume>(<issue>9</issue>):<fpage>1133</fpage>&#x2013;<lpage>1153</lpage>, <year>2008</year>.</mixed-citation></ref>
<ref id="c42"><mixed-citation publication-type="journal"><string-name><given-names>B. S.</given-names> <surname>Pedersen</surname></string-name> and <string-name><given-names>A. R.</given-names> <surname>Quinlan</surname></string-name>. <article-title>cyvcf2: fast, flexible variant analysis with python</article-title>. <source>Bioinformatics</source>, <volume>33</volume>(<issue>12</issue>):<fpage>1867</fpage>&#x2013;<lpage>1869</lpage>, <year>2017</year>.</mixed-citation></ref>
<ref id="c43"><mixed-citation publication-type="journal"><string-name><given-names>B.</given-names> <surname>Peng</surname></string-name> and <string-name><given-names>M.</given-names> <surname>Kimmel</surname></string-name>. <article-title>simupop: a forward-time population genetics simulation environment</article-title>. <source>Bioinformatics</source>, <volume>21</volume>(<issue>18</issue>):<fpage>3686</fpage>&#x2013;<lpage>3687</lpage>, <year>2005</year>.</mixed-citation></ref>
<ref id="c44"><mixed-citation publication-type="journal"><string-name><given-names>M. A.</given-names> <surname>Ragan</surname></string-name>. <article-title>Trees and networks before and after darwin</article-title>. <source>Biology direct</source>, <volume>4</volume>(<issue>1</issue>): <fpage>43</fpage>, <year>2009</year>.</mixed-citation></ref>
<ref id="c45"><mixed-citation publication-type="journal"><string-name><given-names>M. D.</given-names> <surname>Rasmussen</surname></string-name>, <string-name><given-names>M. J.</given-names> <surname>Hubisz</surname></string-name>, <string-name><given-names>I.</given-names> <surname>Gronau</surname></string-name>, and <string-name><given-names>A.</given-names> <surname>Siepel</surname></string-name>. <article-title>Genome-wide inference of ancestral recombination graphs</article-title>. <source>PLoS genetics</source>, <volume>10</volume>(<issue>5</issue>):<fpage>e1004342</fpage>, <year>2014</year>.</mixed-citation></ref>
<ref id="c46"><mixed-citation publication-type="journal"><string-name><given-names>K. P.</given-names> <surname>Schliep</surname></string-name>. <article-title><monospace>phangorn</monospace>: phylogenetic analysis in R</article-title>. <source>Bioinformatics</source>, <volume>27</volume>(<issue>4</issue>): <fpage>592</fpage>&#x2013;<lpage>593</lpage>, <year>2011</year>.</mixed-citation></ref>
<ref id="c47"><mixed-citation publication-type="journal"><string-name><given-names>J.</given-names> <surname>Smith</surname></string-name>, <string-name><given-names>G.</given-names> <surname>Coop</surname></string-name>, <string-name><given-names>M.</given-names> <surname>Stephens</surname></string-name>, and <string-name><given-names>J.</given-names> <surname>Novembre</surname></string-name>. <article-title>Estimating Time to the Common Ancestor for a Beneficial Allele</article-title>. <source>Molecular Biology and Evolution</source>, <volume>35</volume>(<issue>4</issue>):<fpage>1003</fpage>&#x2013;<lpage>1017</lpage>, <month>Jan</month>. <year>2018</year>.</mixed-citation></ref>
<ref id="c48"><mixed-citation publication-type="journal"><string-name><given-names>Y. S.</given-names> <surname>Song</surname></string-name> and <string-name><given-names>J.</given-names> <surname>Hein</surname></string-name>. <article-title>Constructing minimal ancestral recombination graphs</article-title>. <source>Journal of Computational Biology</source>, <volume>12</volume>(<issue>2</issue>):<fpage>147</fpage>&#x2013;<lpage>169</lpage>, <year>2005</year>.</mixed-citation></ref>
<ref id="c49"><mixed-citation publication-type="journal"><string-name><given-names>Y. S.</given-names> <surname>Song</surname></string-name>, <string-name><given-names>Y.</given-names> <surname>Wu</surname></string-name>, and <string-name><given-names>D.</given-names> <surname>Gusfield</surname></string-name>. <article-title>Efficient computation of close lower and upper bounds on the minimum number of recombinations in biological sequence evolution</article-title>. <source>Bioinformatics</source>, <volume>21</volume>(<issue>suppl-1</issue>):<fpage>i413</fpage>&#x2013;<lpage>i422</lpage>, <year>2005</year>.</mixed-citation></ref>
<ref id="c50"><mixed-citation publication-type="journal"><string-name><given-names>Z. D.</given-names> <surname>Stephens</surname></string-name>, <string-name><given-names>S. Y.</given-names> <surname>Lee</surname></string-name>, <string-name><given-names>F.</given-names> <surname>Faghri</surname></string-name>, <string-name><given-names>R. H.</given-names> <surname>Campbell</surname></string-name>, <string-name><given-names>C.</given-names> <surname>Zhai</surname></string-name>, <string-name><given-names>M. J.</given-names> <surname>Efron</surname></string-name>, <string-name><given-names>R.</given-names> <surname>Iyer</surname></string-name>, <string-name><given-names>M. C.</given-names> <surname>Schatz</surname></string-name>, <string-name><given-names>S.</given-names> <surname>Sinha</surname></string-name>, and <string-name><given-names>G. E.</given-names> <surname>Robinson</surname></string-name>. <article-title>Big data: astronomical or genomical?</article-title> <source>PLoS biology</source>, <volume>13</volume>(<issue>7</issue>):<fpage>e1002195</fpage>, <year>2015</year>.</mixed-citation></ref>
<ref id="c51"><mixed-citation publication-type="journal"><string-name><given-names>L.</given-names> <surname>Wang</surname></string-name>, <string-name><given-names>K.</given-names> <surname>Zhang</surname></string-name>, and <string-name><given-names>L.</given-names> <surname>Zhang</surname></string-name>. <article-title>Perfect phylogenetic networks with recombination</article-title>. <source>Journal of Computational Biology</source>, <volume>8</volume>(<issue>1</issue>):<fpage>69</fpage>&#x2013;<lpage>78</lpage>, <year>2001</year>.</mixed-citation></ref>
<ref id="c52"><mixed-citation publication-type="journal"><string-name><given-names>Z.</given-names> <surname>Yang</surname></string-name> and <string-name><given-names>B.</given-names> <surname>Rannala</surname></string-name>. <article-title>Molecular phylogenetics: principles and practice</article-title>. <source>Nat. Rev. Genet</source>., <volume>13</volume>(<issue>5</issue>):<fpage>303</fpage>&#x2013;<lpage>314</lpage>, <month>Mar</month> <year>2012</year>.</mixed-citation></ref>
</ref-list>
<sec id="s6" sec-type="supplementary-material">
<title>Supplementary material</title>
<fig id="figS1" position="float">
<label>Figure S1:</label>
<caption><p>Accuracy of frequency as a proxy for relative age. 50 sample sequences of 100kb were simulated using <monospace>msprime</monospace> with <italic>N</italic><sub>e</sub> &#x003D; 5000 and <italic>&#x03BC;</italic> &#x003D; <italic>&#x03C1;</italic> &#x003D; 10<sup>&#x2212;8</sup>. For all pairs of variant sites, the difference in mutational age was compared to the difference in frequency between the two derived alleles. If <italic>T</italic>(<italic>a</italic><sub>1</sub>) and <italic>T</italic>(<italic>a</italic><sub>2</sub>) are the ages of the derived alleles at sites 1 and 2 respectively, and <italic>f</italic> (<italic>a</italic><sub>1</sub>) and <italic>f</italic> (<italic>a</italic><sub>2</sub>) are their current frequencies in the population, frequency is said to correctly predict age order if <italic>T</italic>(<italic>a</italic><sub>1</sub>) &#x003C; <italic>T</italic>(<italic>a</italic><sub>2</sub>) &#x003D;&#x003D; <italic>f</italic> (<italic>a</italic><sub>2</sub>) &#x003C; <italic>f</italic> (<italic>a</italic><sub>2</sub>). We show the proportion of pairs for which frequency provides the correct order of mutation age. Results were binned into 5kb intervals and averaged over 250,000 replicates. Correlation of adjacent tree topologies results in frequency being a better predictor of relative age when variants are physically close to one another. Note that singletons have been included when calculating the statistics in this figure; removing singletons (which are not used for <monospace>tsinfer</monospace> inference) results in an average accuracy roughly 5&#x0025; lower than shown here.</p>
</caption>
<graphic xlink:href="458067_figS1.tif"/></fig>
<fig id="figS2" position="float">
<label>Figure S2:</label>
<caption><p>Schematic of ancestral haplotype reconstruction. We are constructing an ancestral haplotype for the ancestor corresponding to site 8. The time of each site is approximated by its corresponding frequency value (referred to as allele count here). Note that this is a simplified schematic: the actual implementation includes a dampening effect such that haplotypes are evicted from S if they disagree with the consensus call at two adjacent sites.</p>
</caption>
<graphic xlink:href="458067_figS2.tif"/></fig>
<fig id="figS3" position="float">
<label>Figure S3:</label>
<caption><p>Accuracy of inferred ancestral haplotypes. True ancestral haplotypes were obtained from a single simulation of 100 sample sequences, each of 5Mb in length, using <monospace>msprime</monospace> with <italic>N</italic><sub>e</sub> &#x003D; 5000, and <italic>&#x03BC;</italic> &#x003D; <italic>&#x03C1;</italic> &#x003D; 10<sup>&#x2212;8</sup>. A typical result is shown here, with all &#x007E; 4300 separate ancestral haplotypes plotted as individual points. Accuracy measures the fraction of correctly reconstructed sites, the calculation being restricted to the region in which the true and reconstructed haplotypes overlap.</p>
</caption>
<graphic xlink:href="458067_figS3.tif"/></fig>
<fig id="figS4" position="float">
<label>Figure S4:</label>
<caption><p>Path compression schematic. In the top panel, the children <italic>g</italic>, <italic>h</italic>, <italic>i</italic> and <italic>j</italic> copy from ancestors above them (<italic>a</italic> through <italic>f</italic>). Several sets of edges point to the same parent in the same genomic location, but from different children (e.g. the edges from <italic>g</italic> &#x2192; <italic>c</italic>, <italic>h</italic> &#x2192; <italic>c</italic>, <italic>i</italic> &#x2192; <italic>c</italic>, and <italic>j</italic> &#x2192; <italic>c</italic>). If there are multiple such sets adjacent to each other, the number of edges can be reduced by inserting a synthetic ancestor <italic>s</italic>, to which the children all point (bottom panel). This compression of ancestral paths essentially treats shared recombination breakpoints as evidence of shared ancestry.</p>
</caption>
<graphic xlink:href="458067_figS4.tif"/></fig>
<fig id="figS5" position="float">
<label>Figure S5:</label>
<caption><p>Accuracy of ancestral inference according to different tree distance metrics. 16 sequences were simulated, each of 100kb in length, using <monospace>msprime</monospace> with <italic>N</italic><sub>e</sub> &#x003D; 5000 and <italic>&#x03C1;</italic> &#x003D; 10<sup>&#x2212;8</sup>. Simulations were replicated 100 times for each of seven different mutation rates. The region corresponding to human-like parameters, where <italic>&#x03BC;</italic> &#x2248; <italic>&#x03C1;</italic>, is marked by a vertical dotted line.</p></caption>
<graphic xlink:href="458067_figS5.tif"/></fig>
<fig id="figS6" position="float">
<label>Figure S6:</label>
<caption><p>Accuracy of inference for different tools under a three-population Out-of-Africa model, as implemented in <monospace>msprime</monospace>. 16 sample haplotypes (6 African, 6 European, and 4 Asian) were simulated, each of length 100kb, with <italic>&#x03C1;</italic> &#x003D; 10<sup>&#x2212;8</sup> under a variety of mutation rates. Each point represents an average over 100 replicates.</p>
</caption>
<graphic xlink:href="458067_figS6.tif"/></fig>
<fig id="figS7" position="float">
<label>Figure S7:</label>
<caption><p>Accuracy of inference at different points during and after a selective sweep. Forward-time simulations were performed for sequences of length 100kb, in a Wright-Fisher panmictic population of size <italic>N</italic><sub>e</sub> &#x003D; 5000, with a neutral mutation rate of <italic>&#x03BC;</italic> &#x003D; <italic>&#x03C1;</italic> &#x003D; 10<sup>&#x2212;8</sup>. A single advantageous mutation in the middle of the sequence was introduced and tracked until it went to fixation (or reintroduced if it became extinct). This allele was associated with a selection coefficient of <italic>s</italic> &#x003D; 0.1 in homozygotes, with a dominance coefficient of <italic>h</italic> &#x003D; 0.5. Inference was performed for 16 sample sequences when this allele first hit a frequency of 20, 50, and 80&#x0025;. The situation at fixation is highlighted in grey: lower rows show inference accuracy 200 and 1000 generations post-fixation. Each point is an average over 50 simulations.</p>
</caption>
<graphic xlink:href="458067_figS7.tif"/></fig>
<fig id="figS8" position="float">
<label>Figure S8:</label>
<caption><p>Effect of increased sample size on inference accuracy. Neutral simulations were replicated 100 times for each of three different sequence lengths using <monospace>msprime</monospace> with <italic>N<sub>e</sub></italic> &#x003D; 5000 and <italic>&#x03BC;</italic> &#x003D; <italic>&#x03C1;</italic> &#x003D; 10<sup>&#x2212;8</sup>, and a large initial sample size of 1000. To allow like-for-like comparison, the tree distance metric was restricted to comparisons involving the simulated and inferred ancestral topologies of the first 10 samples only. Tree sequence inference was based on the first 12, 50, 100, 500, or 1000 samples, out of the total simulated set of 1000 haplotypes.</p>
</caption>
<graphic xlink:href="458067_figS8.tif"/></fig>
<fig id="figS9" position="float">
<label>Figure S9:</label>
<caption><p>CPU time for ancestral inference as a function of sample size.Sequences of 200kb in length were simulated using <monospace>msprime</monospace> setting <italic>N<sub>e</sub></italic> &#x003D; 5000 and <italic>&#x03BC;</italic> &#x003D; <italic>&#x03C1;</italic> &#x003D;1 &#x00D7; 10<sup>&#x2212;8</sup>, then used for inference without imposing genotyping error. Each point represents an average over 10 replicates. <monospace>ARGweaver</monospace> requires over 3 orders of magnitude more CPU time than the other methods, hence a discontinuous y-axis is used to fit all tools onto the plot.</p>
</caption>
<graphic xlink:href="458067_figS9.tif"/></fig>
<fig id="figS10" position="float">
<label>Figure S10:</label>
<caption><p>CPU time and memory requirements for <monospace>tsinfer</monospace> and <monospace>fastARG</monospace>, as a function of sample size and sequence length. Sequences were simulated using <monospace>msprime</monospace>, setting <italic>N<sub>e</sub></italic> &#x003D; 5000 and <italic>&#x03BC;</italic> &#x003D; &#x03C1; &#x003D;1 &#x00D7; 10<sup>&#x2212;8</sup>, then used for inference without imposing genotyping error. Each point represents an average over 50 replicates. The scaling properties of <monospace>tsinfer</monospace> are hard to examine using the same y-axis scale as for <monospace>fastARG</monospace>, hence the inset plots show the <monospace>tsinfer</monospace> line only, with a rescaled y-axis.</p>
</caption>
<graphic xlink:href="458067_figS10.tif"/></fig>
<fig id="figS11" position="float">
<label>Figure S11:</label>
<caption><p>Mean compression factor achieved by <monospace>tsinfer</monospace> compared to gzipped VCF data for varying sequence lengths and sample sizes, under three different recombination rates. Sequences were simulated using <monospace>msprime</monospace>, setting <italic>N<sub>e</sub></italic> &#x003D; 5000 and <italic>&#x03BC;</italic> &#x003D; 10<sup>&#x2212;8</sup>, then used for inference without imposing genotyping error. Data are averages over 10 replicates for each combination of parameters.</p>
</caption>
<graphic xlink:href="458067_figS11.tif"/></fig>
<fig id="figS12" position="float">
<label>Figure S12:</label>
<caption><p>The relative filesize of tree sequences inferred by <monospace>tsinfer</monospace> relative to the original tree simulated sequence, for varying sequence lengths and sample sizes, under three different recombination rates. Sequences were simulated using <monospace>msprime</monospace>, setting <italic>N<sub>e</sub></italic> &#x003D; 5000 and <italic>&#x03BC;</italic> &#x003D; 10<sup>&#x2212;8</sup>, then used for inference without imposing genotyping error. Data are averages over 10 replicates for each combination of parameters.</p>
</caption>
<graphic xlink:href="458067_figS12.tif"/></fig>
<fig id="figS13" position="float">
<label>Figure S13:</label>
<caption><p>Summary of sample edges across all TGP and SGDP populations. The number of edges per sample for all individuals in TGP and SGDP, organised by population and continent.</p>
</caption>
<graphic xlink:href="458067_figS13.tif"/></fig>
<fig id="figS14" position="float">
<label>Figure S14:</label>
<caption><p>Sample edges for the TGP populations. The number of edges per sample for all individuals in TGP organised by population, with each continent plotted separately.</p>
</caption>
<graphic xlink:href="458067_figS14.tif"/></fig>
<fig id="figS15" position="float">
<label>Figure S15:</label>
<caption><p>Sample edges for the SGDP populations. The number of edges per sample for all individuals in SGDP organised by population, with each continent plotted separately.</p>
</caption>
<graphic xlink:href="458067_figS15.tif"/></fig>
<fig id="figS16" position="float">
<label>Figure S16:</label>
<caption><p>Z-score normalised GNN proportions for SGDP by population. The GNN matrix was first z-score normalised by column and the rows then hierarchically clustered.</p>
</caption>
<graphic xlink:href="458067_figS16.tif"/></fig>
</sec>
</back>
</article>