<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.2d1 20170631//EN" "JATS-archivearticle1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" article-type="article" dtd-version="1.2d1" specific-use="production" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">BIORXIV</journal-id>
<journal-title-group>
<journal-title>bioRxiv</journal-title>
<abbrev-journal-title abbrev-type="publisher">bioRxiv</abbrev-journal-title>
</journal-title-group>
<publisher>
<publisher-name>Cold Spring Harbor Laboratory</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1101/147777</article-id>
<article-version>1.1</article-version>
<article-categories>
<subj-group subj-group-type="author-type">
<subject>Regular Article</subject>
</subj-group>
<subj-group subj-group-type="heading">
<subject>New Results</subject>
</subj-group>
<subj-group subj-group-type="hwp-journal-coll">
<subject>Bioinformatics</subject>
</subj-group>
</article-categories>
<title-group><article-title>Integrating long-range connectivity information into de Bruijn graphs</article-title></title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes"><contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-2378-4886</contrib-id>
<name><surname>Turner</surname> <given-names>Isaac</given-names></name><xref ref-type="aff" rid="a1">1</xref><xref ref-type="author-notes" rid="n1">&#x002A;</xref></contrib>
<contrib contrib-type="author" corresp="yes"><contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-5054-3527</contrib-id>
<name><surname>Garimella</surname> <given-names>Kiran V</given-names></name><xref ref-type="aff" rid="a1">1</xref><xref ref-type="aff" rid="a2">2</xref><xref ref-type="author-notes" rid="n1">&#x002A;</xref></contrib>
<contrib contrib-type="author"><contrib-id contrib-id-type="orcid">http://orcid.org/0000-0001-8466-7547</contrib-id>
<name><surname>Iqbal</surname> <given-names>Zamin</given-names></name><xref ref-type="aff" rid="a1">1</xref><xref ref-type="aff" rid="a3">3</xref></contrib>
<contrib contrib-type="author"><contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-5012-4162</contrib-id>
<name><surname>McVean</surname> <given-names>Gil</given-names></name><xref ref-type="aff" rid="a1">1</xref><xref ref-type="aff" rid="a2">2</xref></contrib>
<aff id="a1"><label>1</label><institution>Wellcome Trust Centre for Human Genetics</institution>, Oxford, OX3 7BN, <country>UK</country></aff>
<aff id="a2"><label>2</label><institution>Big Data Institute, Li Ka Shing Centre for Health Information and Discovery</institution>, Oxford, OX3 7LF, <country>UK</country></aff>
<aff id="a3"><label>3</label><institution>European Bioinformatics Institute (EMBL-EBI), Wellcome Genome Campus</institution>, Hinxton, CB101SD, <country>UK</country></aff>
</contrib-group>
<author-notes>
<fn fn-type="equal" id="n1"><label>&#x002A;</label><p>These authors contributed equally to the work</p></fn>
</author-notes>
<pub-date pub-type="epub">
<year>2017</year>
</pub-date>
<elocation-id>147777</elocation-id>
<history>
<date date-type="received">
<day>08</day>
<month>6</month>
<year>2017</year>
</date>
<date date-type="rev-recd">
<day>08</day>
<month>6</month>
<year>2017</year>
</date>
<date date-type="accepted">
<day>08</day>
<month>6</month>
<year>2017</year>
</date>
</history>
<permissions>
<copyright-statement>&#x00A9; 2017, Posted by Cold Spring Harbor Laboratory</copyright-statement>
<copyright-year>2017</copyright-year><license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by/4.0/"><license-p>This pre-print is available under a Creative Commons License (Attribution 4.0 International), CC BY 4.0, as described at <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link></license-p></license></permissions>
<self-uri xlink:href="147777.pdf" content-type="pdf" xlink:role="full-text"/>
<abstract><title>Abstract</title>
<sec>
<title>Motivation</title>
<p>The de Bruijn graph is a simple and efficient data structure that is used in many areas of sequence analysis including genome assembly, read error correction and variant calling. The data structure has a single parameter <italic>k</italic>, is straightforward to implement and is tractable for large genomes with high sequencing depth. It also enables representation of multiple samples simultaneously to facilitate comparison. However, unlike the string graph, a de Bruijn graph does not retain long range information that is inherent in the read data. For this reason, applications that rely on de Bruijn graphs can produce sub-optimal results given their input.</p></sec>
<sec>
<title>Results</title>
<p>We present a novel assembly graph data structure: the <italic>Linked de Bruijn Graph (LdBG)</italic>. Constructed by adding annotations on top of a de Bruijn graph, it stores long range connectivity information through the graph. We show that with error-free data it is possible to losslessly store and recover sequence from a Linked de Bruijn graph. With assembly simulations we demonstrate that the LdBG data structure outperforms both the de Bruijn graph and the String Graph Assembler (SGA). Finally we apply the LdBG to <italic>Klebsiella pneumoniae</italic> short read data to make large (12 kbp) variant calls, which we validate using PacBio sequencing data, and to characterise the genomic context of drug-resistance genes.</p></sec>
<sec sec-type="availability">
<title>Availability</title>
<p>Linked de Bruijn Graphs and associated algorithms are implemented as part of McCortex, available under the MIT license at <ext-link ext-link-type="uri" xlink:href="http://https://github.com/mcvean/mccortex">https://github.com/mcvean/mccortex</ext-link>.</p></sec>
<sec>
<title>Contact</title>
<p><email>turner.isaac@gmail.com</email>.</p></sec>
</abstract>
<counts>
<page-count count="15"/>
</counts>
</article-meta>
</front>
<body>
<sec id="s1"><label>1</label><title>Introduction</title>
<p>Most efforts to discover genetic variation in populations begin with alignment of high-throughput sequencing (HTS) data to a high-quality reference genome for the organism under study. This approach works well for regions with low divergence from the reference haplotype. However, many biologically interesting loci reside in regions of high divergence. For example, antigenic genes in <italic>Plasmodium falciparum</italic>, <italic>Trypanosoma brucei</italic>, and other pathogens often exhibit non-allelic homologous recombination underlying mechanisms of immune escape (<xref ref-type="bibr" rid="c16">Freitas-Junior <italic>et al.</italic>, 2000</xref>; <xref ref-type="bibr" rid="c2">Artzy-Randrup <italic>et al.</italic>, 2012</xref>; <xref ref-type="bibr" rid="c22">Jackson <italic>et al.</italic>, 2012</xref>). Similarly, structural mutations, such as rearrangements and amplifications, can promote tumourigenesis through dysregulation of oncogenes or down-regulation of tumour suppressors (<xref ref-type="bibr" rid="c14">Difilippantonio <italic>et al.</italic>, 2002</xref>; <xref ref-type="bibr" rid="c1">Aguilera and G&#x00F3;mez-Gonz&#x00E1;lez, 2008</xref>). More generally, variants may be difficult to identify and characterise when the altered haplotype differs substantially from the reference, and other regions of interest reside in sequence absent from the reference sequence altogether. For example, in 13 isolates of the diploid coccolithophore <italic>Emiliania huxleyi</italic>, 8 to 40 Mbp of the approximately 142 Mbp genome were found to be isolate-specific; up to 25&#x0025; of genes were found to be absent from the reference sequence (<xref ref-type="bibr" rid="c36">Read <italic>et al.</italic>, 2013</xref>). In these scenarios, reads may fail to map to the reference, preventing the analyst from inspecting biologically interesting variation. Alternatively, reads may map incorrectly, misleading the analyst to consider variation where none exists (<xref ref-type="bibr" rid="c37">Ribeiro <italic>et al.</italic>, 2015</xref>).</p>
<p>One mitigation of this inadequate reference problem is to augment the reference with known variation and alternative alleles to improve read mapping (<xref ref-type="bibr" rid="c40">Schneeberger <italic>et al.</italic>, 2009</xref>; <xref ref-type="bibr" rid="c47">Huang <italic>et al.</italic>, 2013</xref>; <xref ref-type="bibr" rid="c44">Weisenfeld <italic>et al.</italic>, 2014</xref>; <xref ref-type="bibr" rid="c12">Dilthey <italic>et al.</italic>, 2015</xref>). Such approaches commonly convert flat reference genomes into a graph structure, effectively mapping reads to all references simultaneously and choosing the path that best fits the data. In a study mapping to a fragmented human assembly, <xref ref-type="bibr" rid="c28">Limasset <italic>et al.</italic> (2016)</xref> found that mapping to a reference graph instead of flat contigs led to a 22&#x0025; increase in the number of reads that map uniquely.</p>
<p><italic>De novo</italic> assembly offers a means to overcome some of the limitations of reference-based analyses. Rather than aligning reads to a reference, reads are aligned to one another. These alignments are encoded in a graph data structure, a collection of &#x201C;vertices&#x201D; encapsulating sequence data and &#x201C;edges&#x201D; representing overlaps of different sequences (<xref ref-type="bibr" rid="c32">Myers, 1995</xref>). Graphs from different samples (and any reference) can then be compared to discover variation directly (<xref ref-type="bibr" rid="c3">Bateman <italic>et al.</italic>, 2016</xref>). Should the variation be in a locus unrepresented in the reference genome, the graph-based comparison can still capture the event (<xref ref-type="bibr" rid="c20">Iqbal <italic>et al.</italic>, 2012</xref>).</p>
<p>The most common sequencers in use today (second-generation) produce tens of millions of short reads (typically 75 to 150 bp in length) per sequencing run (<xref ref-type="bibr" rid="c17">Goodwin <italic>et al.</italic>, 2016</xref>). It is common to assemble such data using a so-called &#x201C;de Bruijn&#x201D; graph approach (<xref ref-type="bibr" rid="c13">de Bruijn, 1946</xref>; <xref ref-type="bibr" rid="c34">Pevzner, 1989</xref>; <xref ref-type="bibr" rid="c19">Idury and Waterman, 1995</xref>). Vertices are constrained to be fixed-width substrings of length <italic>k</italic> (or &#x201C;<italic>k</italic>-mers&#x201D;). Edges represent observed sequence adjacencies in the reads. With sufficient coverage, overlaps are implicitly encoded because two reads which overlap will share <italic>k</italic>-mers. Thus the graph is built up one read at a time at the cost of storing the graph in memory. Graphs of multiple individuals can be compared in memory (<xref ref-type="bibr" rid="c20">Iqbal <italic>et al.</italic>, 2012</xref>). However, there is a penalty for this approach: long-range information in the read is sacrificed. This is particularly problematic as genomes tend to have many repetitive regions and without context it is often not possible to determine the origin of a random <italic>k</italic>-mer (<xref ref-type="bibr" rid="c35">Pevzner <italic>et al.</italic>, 2004</xref>; <xref ref-type="bibr" rid="c31">Miller <italic>et al.</italic>, 2010</xref>). However, as <italic>k</italic> increases, so does the specificity of its location. String graphs address the issue of storing long-range information by avoiding the read fragmentation step and instead find explicit overlaps between reads. Unfortunately string graphs are not well suited to multi-sample comparison and have a high per-sample memory cost (<xref ref-type="bibr" rid="c4">Bonizzoni <italic>et al.</italic>, 2016</xref>).</p>
<p>We start by describing the de Bruijn graph and its benefits compared to the string graph. We then describe an augmentation (LdBG) that allows long-range information to be kept. Theoretical results and simulations are used to characterise its properties. We demonstrate its value by application to variant discovery and characterisation of genomic context for drug resistance genes in <italic>Klebsiella pneumoniae</italic>. Finally, we consider the possibility of using such structures for regular analysis of human-scale genomes.</p>
</sec>
<sec id="s2"><label>2</label><title>Background</title>
<sec id="s2a"><label>2.1</label><title>Definitions and notation</title>
<p>DNA sequences are strings over the alphabet {<italic>A</italic>, <italic>C</italic>, <italic>G</italic>, <italic>T</italic>}. We denote a DNA sequence as <italic>S</italic> = <italic>S</italic><sub>1</sub>,&#x2026;,<italic>S<sub>S</sub></italic> where <italic>S</italic> is the length of the sequence. <italic>S</italic>[<italic>i,j</italic>] is sequence <italic>S<sub>i</sub></italic>,&#x2026;,<italic>S<sub>j</sub></italic>. <italic>S</italic><sup>&#x2032;</sup> is the reverse of <italic>S</italic> (<italic>S<sub>S</sub></italic>,&#x2026;,<italic>S</italic><sub>1</sub>). <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="147777_inline1.gif"/></alternatives></inline-formula> is the reverse complement of S. A <italic>k</italic>-mer is a sequence of length <italic>k</italic> over the alphabet {<italic>A</italic>, <italic>C</italic>, <italic>G</italic>, <italic>T</italic>}.</p>
</sec>
<sec id="s2b"><label>2.2</label><title>Assembly graphs</title>
<p>An assembly graph is any graph where the the vertices represent sequence and edges represent overlaps or adjacencies between those sequences. An assembly graph may not have parallel edges (not a multigraph). Traversing a vertex <italic>v</italic> backwards <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="147777_inline2.gif"/></alternatives></inline-formula> gives the reverse complement of the sequence it represents. <italic>deg</italic><sup>&#x2212;</sup>(<italic>v</italic>) is the indegree and <italic>deg</italic><sup>&#x002B;</sup>(<italic>v</italic>) is the outdegree of vertex <italic>v</italic>. A path through the graph is a list of adjacent vertices with edges between them. The reverse of path <italic>P</italic> = <italic>v</italic><sub>1</sub>,&#x2026;,<italic>v<sub>n</sub></italic> is <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="147777_inline3.gif"/></alternatives></inline-formula>. A <italic>unitig U</italic> = <italic>v</italic><sub>1</sub>,&#x2026;,<italic>v<sub>n</sub></italic>, is a maximal path such that <italic>deg</italic><sup>&#x2212;</sup>(<italic>v<sub>i</sub></italic>) = <italic>deg</italic><sup>&#x002B;</sup>(<italic>v<sub>i</sub></italic>) = 1 for 1 &#x003C; <italic>i</italic> &#x003C; <italic>n</italic> and <italic>deg</italic><sup>&#x002B;</sup>(<italic>v</italic><sub>1</sub>) = <italic>deg</italic><sup>&#x2212;</sup>(<italic>v<sub>n</sub></italic>) = 1 if <italic>n</italic> &#x003E; 1. The maximal property means the path cannot be extended without violating these conditions.</p>
</sec>
<sec id="s2c"><label>2.3</label><title>De Bruijn Graphs</title>
<p>A de Bruijn Graph <italic>G</italic>(<italic>k</italic>) is an assembly graph, constructed from a set of sequence reads <italic>R</italic> and defined by {<italic>V, E</italic>} where <italic>V</italic> is a set of vertices representing <italic>k</italic>-mers and <italic>E</italic> a set of edges between those <italic>k</italic>-mers. De Bruijn Graphs are constructed by breaking input reads into overlapping <italic>k</italic>-mers that are added to the graph. With one <italic>k</italic>-mer starting at every base, a read of length <italic>r<sub>i</sub></italic> will give <italic>r<sub>i</sub></italic> &#x2212; <italic>k</italic> &#x002B; 1 <italic>k</italic>-mers. A count is kept of how many times a given <italic>k</italic>-mer was seen in the input reads, called <italic>k</italic>-mer coverage. Edges are added between two <italic>k</italic>-mers if they share an overlap of <italic>k</italic> &#x2212; 1 bases. Some implementations additionally require that <italic>k</italic>-mers are seen overlapping by <italic>k</italic> &#x2212; 1 bases in the read data, in order to have an edge between them.</p>
<p>Due to the double stranded nature of DNA and the fact that we don&#x2019;t know which strand a read originated from, storing all <italic>k</italic>-mers from reads results in <italic>k</italic>-mers occurring separately in the graph in both their forward and reverse complement orientations. To overcome this it is common to store only the lexically lower of each <italic>k</italic>-mer <italic>X</italic> and its reverse-complement <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="147777_inline6.gif"/></alternatives></inline-formula> (<xref ref-type="bibr" rid="c45">Zerbino, 2010</xref>). Requiring that <italic>k</italic> is odd prevents a <italic>k</italic>-mer from being its own reverse complement (a DNA palindrome). When visiting a vertex in the de Bruijn graph we can visit it in its forward or reverse complement orientation. The orientation in which we arrive at it determines if we leave by its out- or in- edges (forward, reverse respectively).</p>
<p>A de Bruijn graph only stores connectivity information one base either side of a given <italic>k</italic>-mer. This means that for three adjacent <italic>k</italic>-mers in the graph (<italic>v<sub>a</sub>, v<sub>b</sub>, v<sub>c</sub></italic>), there is no information about how the first and third are connected if the middle <italic>k</italic>-mer has <italic>deg</italic><sup>&#x2212;</sup>(<italic>v<sub>b</sub></italic>) &#x003E; 1 and <italic>deg</italic><sup>&#x002B;</sup>(<italic>v<sub>b</sub></italic>) &#x003E; 1. This graph motif is known as a &#x2018;tangle&#x2019; and is caused by the graph collapsing down at a repeat and splitting out again afterwards. De Bruijn graphs collapse down at repeats in the genome of lengths &#x2265; <italic>k</italic>. It is not possible to traverse a dBG past a tangle, even if the input reads are long enough to resolve it (i.e. pair-up <italic>k</italic>-mers going-into and coming-out of it). This makes analyses that use a de Bruijn graph sensitive to the parameter <italic>k</italic>.</p>
<p>While increasing <italic>k</italic> can overcome the problem of short repeats, it also has the effect of reducing the number of <italic>k</italic>-mers given by each read and increases the number of <italic>k</italic>-mers lost to each sequencing error. Both these effects reduce <italic>k</italic>-mer coverage, which is determined by the <italic>k</italic>-mer size, the read length and the error rate (<xref ref-type="bibr" rid="c20">Iqbal <italic>et al.</italic>, 2012</xref>). As <italic>k</italic>-mer coverage drops, read overlaps are lost and gaps in coverage increase. Together with tangles, coverage gaps interrupt assembly and shorten contigs.</p>
<p>Picking a value for <italic>k</italic> is ultimately a trade-off. It is common to run analyses multiple times with different values of <italic>k</italic> and pick the best results according to a quality metric (e.g. assembly N50 or number of variants called) (<xref ref-type="bibr" rid="c21">Iqbal <italic>et al.</italic>, 2013</xref>). Alternatively the genome and read data can be sampled to estimate which value would be optimal (<xref ref-type="bibr" rid="c45">Zerbino, 2010</xref>).</p>
<p>The dBG can be augmented to support multiple data sets, providing a single data structure to describe and compare the genomes of many individuals (<xref ref-type="bibr" rid="c20">Iqbal <italic>et al.</italic>, 2012</xref>). Graphs are built separately for each data set <italic>c</italic> &#x220A; <italic>C</italic> and merged post-construction. The merge produces a union graph <italic>G<sub>u</sub></italic> = {<italic>V<sub>u</sub>, E<sub>u</sub></italic>}, where <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="147777_inline4.gif"/></alternatives></inline-formula> and <italic>E<sub>u</sub></italic> = {<italic>E<sub>c</sub></italic> : <italic>c</italic> &#x220A; <italic>C</italic>}. Each <italic>k</italic>-mer stores which samples it was seen in. We refer to <italic>c</italic> as <italic>colour</italic>, a generic term that can mean a distinct individual, pooled population or a specific data set on a single individual (e.g. tumour/normal), depending on analysis context. We shall refer to this structure as a <italic>multi-colour de Bruijn graph</italic>.</p>
<p>De Bruijn graphs are used in many areas of sequence analysis, including in mapping-based calling, as in the local alignment step of the variant caller Platypus (<xref ref-type="bibr" rid="c38">Rimmer <italic>et al.</italic>, 2014</xref>), in de novo assembly as in Velvet (<xref ref-type="bibr" rid="c46">Zerbino and Birney, 2008</xref>) and ABySS (<xref ref-type="bibr" rid="c43">Simpson <italic>et al.</italic>, 2009</xref>), and in de novo assembly for variant calling (<xref ref-type="bibr" rid="c20">Iqbal <italic>et al.</italic>, 2012</xref>).</p>
<p>Recently there has been work on implementing low memory dBG construction (<xref ref-type="bibr" rid="c10">Chikhi <italic>et al.</italic>, 2014</xref>) and representations (<xref ref-type="bibr" rid="c11">Conway and Bromage, 2011</xref>; <xref ref-type="bibr" rid="c39">Rizk <italic>et al.</italic>, 2013</xref>; <xref ref-type="bibr" rid="c9">Chikhi and Rizk, 2013</xref>; <xref ref-type="bibr" rid="c5">Bowe <italic>et al.</italic>, 2012</xref>). These have both provided great improvements over the naive hash table based implementation, extending the contexts in which dBGs can be used.</p>
</sec>
<sec id="s2d"><label>2.4</label><title>String graphs</title>
<p>A String graph is an assembly graph where the vertices represent the input reads and the edges are maximal non-transitive overlaps between them (<xref ref-type="bibr" rid="c33">Myers, 2005</xref>). The set of reads is reduced to remove reads contained within other reads. A naive String Graph implementation would take <italic>O</italic>(<italic>N</italic><sup>2</sup>) time to compare all pairs of reads to find overlaps, before removing contained reads and transitive edges. <xref ref-type="bibr" rid="c42">Simpson and Durbin (2010)</xref> showed that it is possible to construct a string graph in linear time, by first generating an FM-index of the input reads <italic>R</italic> and an FM-index of their reverse <italic>R</italic>&#x2032;. Alternatively a single index can be constructed containing <italic>R</italic> and <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="147777_inline5.gif"/></alternatives></inline-formula> (<xref ref-type="bibr" rid="c24">Li, 2012</xref>).</p>
<p>The FM-index (<xref ref-type="bibr" rid="c15">Ferragina and Manzini, 2000</xref>) is a data structure for compression and fast string searching. The FM-index of a set of strings <italic>S</italic> facilitates searching for a query <italic>Q</italic> in time <italic>O</italic>(&#x007C;<italic>Q</italic>&#x007C;). Construction of the index has time and memory complexity <italic>O</italic>(&#x007C;<italic>S</italic>&#x007C;). The final index has roughly the same size <italic>S</italic>, but can be efficiently compressed with run-length encoding.</p>
<p>FM-index construction has high memory requirements for high coverage data sets as all reads must be loaded into memory. This requires building indices for subsets of the reads and recursively merging the indices (<xref ref-type="bibr" rid="c25">Li, 2014a</xref>). In comparison, dBG memory is mostly determined by genome size, with only the errors in high coverage data causing a slower increase in memory requirements. Similar memory efficiency advantages are seen when building multi-colour dBGs from the same species.</p>
<p>Since it is constructed from the reads without breaking them up, a string graph is an assembly graph that stores all the connectivity information contained in the single-ended input reads (<xref ref-type="bibr" rid="c33">Myers, 2005</xref>). String graphs do not naturally lend themselves to storing information on read pairs, although one such data structure has been proposed (<xref ref-type="bibr" rid="c8">Chikhi and Lavenier, 2011</xref>).</p>
</sec>
<sec id="s2e"><label>2.5</label><title>The linked de Bruijn graph</title>
<p>We propose a new assembly graph data structure called the Linked de Bruijn Graph (LdBG). Defined as <italic>LG</italic>(<italic>k</italic>) = (<italic>V</italic>, <italic>E</italic>, <italic>L</italic>) where <italic>V</italic>, <italic>E</italic> are defined as in a de Bruijn graph. <italic>L</italic>(<italic>v</italic>) is a set of paths through the graph that start at vertex <italic>v</italic> &#x220A; <italic>V</italic>. We call these paths <italic>links</italic>. Each of these links <italic>l</italic> &#x220A; <italic>L</italic>(<italic>v</italic>) is stored as a list of junction choices that when followed, starting from vertex <italic>v</italic>, recreate the path. Graph traversal is the same as with a de Bruijn graph, with the extension that when we visit a vertex <italic>v</italic>, we pick up the links associated with it: <italic>L</italic>(<italic>v</italic>). The links held during traversal record how many edges ago they were picked up, a value we call link &#x201C;age&#x201D;. Only when we reach a bifurcation in the graph do we consult the links currently held. We follow the next junction choice of the oldest link as this provides the most context as to where we are in the genome. Should we have more than one oldest link and they disagree, we halt traversal. An illustration of links resolving a cycle is shown in <xref ref-type="fig" rid="fig1">Figure 1</xref>.</p>
<fig id="fig1" position="float" orientation="portrait" fig-type="figure"><label>Figure 1:</label><caption><p>Utility of link information in traversing a graph cycle. (a) A 32-bp genome and a 23-bp read, each containing three (colour-coded) repeats of the 5-mer, GATGC. (b) The resulting de Bruijn graph (<italic>k</italic> = 5) with a repeat cycle, constructed from the genome sequence. The <italic>k</italic>-mers grouped by dashed boxes indicate the result of graph traversals to emit contigs, with final sequences written below and positioned along the input genome for clarity. (c) Reads are &#x201C;threaded&#x201D; (aligned) through the graph (top); the repeated <italic>k</italic>-mers are colour-coded. The alignment information is distilled to a set of junction choices to make when navigating the graph and stored as annotations on <italic>k</italic>-mers preceding junctions (middle). Multiple links are separated by a comma. Uppercase (lowercase) links indicate the choices to be made when traversing forwards (backwards). A <italic>k</italic>-mer&#x2019;s links are picked up when we visit it. When we reach a junction, the next edge suggested by the oldest link(s) is taken, links that disagree are dropped, all remaining links trim off a junction choice and exhausted links are also dropped. The resultant contig recapitulating the entire genome is shown (bottom). Highlighted bases indicate the junction choices originating from the left-most link.</p></caption><graphic xlink:href="147777_fig1.tif"/></fig>
<p>As with a de Bruijn graphs we can look up any <italic>k</italic>-mer or edge between <italic>k</italic>-mers in time <italic>O</italic>(1) and we can start graph traversal from any <italic>k</italic>-mer. As in a multi-coloured dBG, a multi-coloured LdBG stores which samples have which <italic>k</italic>-mers and links.</p>
<p>A LdBG is a lossless representation of a genome when generated from error-free reads, as long as the genome starts and ends with unique <italic>k</italic>-mers, there are no <italic>k</italic>-mer coverage gaps and each repeat is spanned by at least one read (proof in online supplement). This is true regardless of the value of <italic>k</italic>.</p>
<p>In constructing a LdBG we are effectively compressing reads against the de Bruijn graph. However, since read start/end positions are not important for assembly we do not store them, so although it is possible to recover the underlying genome (losslessly) through assembly, it is not possible to recover the original set of input reads.</p>
<p>Reads used to annotate the graph do not need to have been used to construct the de Bruijn graph. Sets of links may be merged by loading them together at runtime. We give an example of the utility of such a construction in the applications section below.</p>
</sec>
</sec>
<sec id="s3"><label>3</label><title>Methods</title>
<sec id="s3a"><label>3.1</label><title>de Bruijn Graph construction</title>
<p>Each input read <italic>r</italic> is broken into <italic>r</italic> &#x2212; <italic>k</italic> &#x002B; 1 overlapping <italic>k</italic>-mers (<italic>v</italic><sub>1</sub>,&#x2026;, <italic>v<sub>n</sub></italic>) which are added to the graph. If a <italic>k</italic>-mer already exists in the graph, we increment its coverage. Edges are added between <italic>v<sub>i</sub></italic> and <italic>v<sub>i</sub></italic><sub>&#x002B;1</sub> for all 1 &#x2264; <italic>i</italic> &#x003C; <italic>n</italic>.</p>
<p>To remove <italic>k</italic>-mers due to sequencing error, unitigs with median <italic>k</italic>-mer coverage below <italic>T</italic> are removed, where <italic>T</italic> is a user-specified threshold. If not specified, a threshold <italic>T</italic> is picked such that the expectation of a <italic>k</italic>-mer with coverage <italic>T</italic> being an error is &#x003C; 10<sup>&#x2212;3</sup> (see online supplement).</p>
<p>Graph tips, that is unitigs (<italic>v<sub>i</sub>,</italic>&#x2026;,<italic>v<sub>j</sub></italic>) with <italic>deg</italic><sup>&#x2212;</sup>(<italic>v<sub>i</sub></italic>)&#x002B;<italic>deg</italic><sup>&#x002B;</sup>(<italic>v<sub>j</sub></italic>) &#x003C; 2, are the result of sequencing errors near the end of reads and gaps in coverage. Tips are removed if they are shorter than a user specified value, the default being <italic>k</italic>, the maximum number of erroneous <italic>k</italic>-mers generated by a single-base sequencing error near the end of a read.</p>
</sec>
<sec id="s3b"><label>3.2</label><title>Read-to-graph alignment</title>
<p>Reads are aligned to the de Bruijn graph one-at-a-time and in doing so are error-corrected. For a read <italic>r</italic>, we look up each of its <italic>k</italic>-mers, resulting in a list of <italic>k</italic>-mers that describe a path through the graph. There may be gaps in this path due to <italic>k</italic>-mers removed from the graph during <italic>k</italic>-mer error cleaning (or if the read was not used in dBG construction). Gaps are closed by walking the graph between the <italic>k</italic>-mers either side of the gap (<italic>v<sub>i</sub></italic> and <italic>v<sub>j</sub></italic>). If we cannot traverse from <italic>v<sub>i</sub></italic> to <italic>v<sub>j</sub></italic>, we attempt going from <italic>v<sub>j</sub></italic> to <italic>v<sub>i</sub></italic>. Should such a traversal succeed (giving <italic>k</italic>-mers <italic>v</italic><sub>1</sub>,&#x2026;,<italic>v<sub>k</sub></italic>) and <italic>k</italic> &#x007E; <italic>j</italic> &#x2212; <italic>i</italic>, the <italic>k</italic>-mers <italic>v</italic><sub>1</sub>,&#x2026;,<italic>v<sub>k</sub></italic> are used to fill in the gap in the path between <italic>v<sub>i</sub></italic> and <italic>v<sub>j</sub></italic>. This error step is sequence agnostic in that it does not compare the new <italic>k</italic>-mers (<italic>v</italic><sub>1</sub>,&#x2026;,<italic>v<sub>k</sub></italic>) to the read <italic>k</italic>-mers it is replacing (<italic>v<sub>i</sub></italic><sub>&#x002B;1</sub>, &#x2026;,<italic>v<sub>j</sub></italic><sub>&#x2212;1</sub>). This speeds up the error correction step and ensures it does not make assumptions about the error process of the input sequence data. The output of the alignment step is a set of sequences that perfectly match the de Bruijn graph <italic>k</italic>-mers i.e. they describe a path through the graph.</p>
<p>Gaps between paired-end reads are treated like gaps in reads caused by sequencing errors. LdBG naturally captures information from paired end reads once the insert gap is filled. Links can be generated in two passes: first with single-end reads against a dBG to create a LdBG; then with paired-end reads against the LdBG. This allows the single-ended read links to be used to aid traversal between read pairs.</p>
</sec>
<sec id="s3c"><label>3.3</label><title>Link annotation</title>
<p>A link is a path, starting from a given <italic>k</italic>-mer and stored as a series of junction choices. The function <italic>J</italic>(<italic>v<sub>i</sub></italic>,&#x2026;,<italic>v<sub>j</sub></italic>) takes a path and returns the junction choices it describes.</p>
<p>Given a path <italic>P</italic> = <italic>v</italic><sub>1</sub>,&#x2026;,<italic>v<sub>n</sub></italic> through the graph, we identify the maximum <italic>j</italic> such that <italic>deg</italic><sup>&#x002B;</sup>(<italic>v<sub>j</sub></italic>) &#x003E; 1; 1 &#x003C; <italic>j</italic> &#x003C; <italic>n</italic>. Then for each <italic>i</italic> such that <italic>deg</italic><sup>&#x2212;</sup>(<italic>v<sub>i</sub></italic>) &#x003E; 1; 1 <italic>&#x003C; i</italic> &#x2264; <italic>j</italic>, we add a link to vertex <italic>v<sub>i</sub></italic><sub>&#x2212;1</sub>: <italic>L</italic>(<italic>v<sub>i</sub></italic><sub>&#x2212;1</sub>) &#x2190; <italic>L</italic>(<italic>v<sub>i</sub></italic><sub>&#x2212;1</sub>) &#x222A; <italic>J</italic> (<italic>v<sub>i</sub></italic><sub>&#x2212;1</sub>,&#x2026;,<italic>v<sub>j</sub></italic><sub>&#x002B;1</sub>). Link annotation is repeated for the reverse path <italic>P</italic>. Link counts record how many times a given link is seen in a sample starting at a particular <italic>k</italic>-mer.</p>
<p>Links are cleaned by building a tree of links <italic>L</italic>(<italic>v</italic>), and trimming junction choices with coverage below threshold T. This link cleaning threshold is determined by applying the same model as used for <italic>k</italic>-mer cleaning to the link coverage distribution of the first junction choice of all links.</p>
</sec>
<sec id="s3d"><label>3.4</label><title>Implementation</title>
<p>We have implemented the LdBG data structure and associated algorithms as part of <monospace>McCortex</monospace>, a modular set of multi-threaded programs for manipulating assembly graphs written in C. McCortex supports FASTA, FASTQ, SAM, BAM &#x0026; CRAM file formats and is released under the MIT license. McCortex has been used as the backend for sequence analysis by <xref ref-type="bibr" rid="c6">Bradley <italic>et al.</italic> (2015)</xref>.</p>
</sec>
<sec id="s3e"><label>3.5</label><title>Multi-coloured linked de Bruijn graphs</title>
<p>Multi-colour LdBGs can be constructed by building single sample LdBGs and loading them together into McCortex. For graph traversal tasks, such as assembly, we only store a single bit per sample per <italic>k</italic>-mer and per sample per link to record which <italic>k</italic>-mers/links are present in each sample. These are stored in a packed bitset. Graph traversal of a colour through a multi-coloured LdBG proceeds as per for a single-sample LdBG, only using links and <italic>k</italic>-mers of the given colour. At coverage gaps, traversal can fall back to using any <italic>k</italic>-mers in the graph (but not other colour&#x2019;s links).</p>
</sec>
</sec>
<sec id="s4"><label>4</label><title>Results: simulations</title>
<sec id="s4a"><label>4.1</label><title>Equivalence of LdBG and input string</title>
<p>To test the lossless recovery of a genome from the LdBG we generated a random 10 kbp haploid genome, ensuring it started and ended with unique 7-mers. We identified the length of longest repeat (<italic>LR</italic>) in our genome. We generated perfect error-free coverage of the genome with a read length of <italic>LR</italic> &#x002B; 2 starting at each base. We then built a LdBG (<italic>k</italic> = 7) from the reads, assembled contigs and removed contained contigs (those that were substrings of other contigs). After checking that we were left with a single contig, we compared it for an exact match to the original genome. This simulation was run 100 times without fail. With <italic>k</italic> = 7, there are only 4<sup>7</sup> = 16384 possible <italic>k</italic>-mers, so a random 10 kbp genome will have many repeats that could not be traversed by the unannotated de Bruijn graph.</p>
</sec>
<sec id="s4b"><label>4.2</label><title>Correcting errors in reads</title>
<p>To assess the accuracy of our error correction step when aligning reads to the graph, we simulated a haploid 1 Mbp genome (from human GRCh37 chr22:28,000,000-28,999,999). Single-ended 250 bp reads with 50<italic>X</italic> coverage were simulated with a 0.49&#x0025; empirically distributed sequencing error (reads paired with real MiSeq data, FASTQ scores used as per base error rate). We built a dBG (<italic>k</italic> = 31) and removed tips and unitigs with coverage <italic>&#x003C;</italic> 7 (automatically chosen). Once reads were aligned to the graph we wrote them to disk instead of generating links. The input reads had 247, 075 (0.49&#x0025;) errors, the output had 30, 148 (0.06&#x0025;) errors. Of the bases changed by the error correction step, 99.19&#x0025; changes were correct.</p>
</sec>
<sec id="s4c"><label>4.3</label><title>Sensitivity to word length</title>
<p>Lowering the value of <italic>k</italic> in a dBG raises <italic>k</italic>-mer coverage and reduces coverage gaps but it also reduces the length of the longest repeats that can be traversed. If we improve the ability to resolve repeats with <italic>links</italic>, we hypothesised that we should reduce the assembly performance&#x2019;s sensitivity to the parameter <italic>k</italic>. Therefore we simulated an assembly task with different <italic>k</italic> values.</p>
<p>We simulated three haploid sequencing data sets from 1 Mbp of human (chr22:28,000,000-28,999,999) using 100 bp single ended reads, each giving 100<italic>X</italic> coverage. First, we generated &#x2018;perfect coverage&#x2019; &#x2013; an error-free read starting at every base. Second, we generated &#x2018;stochastic coverage&#x2019; &#x2013; read starts distributed uniformly across the 1 Mbp genome. Third, we generated &#x2018;reads with error&#x2019; &#x2013; stochastically sampled reads with a uniform 0.5&#x0025; rate of single base errors.</p>
<p>We assembled these three data sets using a dBG and LdBG at <italic>k</italic> = 21, 31,&#x2026;, 91. To compare assemblies we used the NG50 metric, defined as the contig length <italic>C</italic> such that contigs longer than <italic>C</italic> sum to at least half of the genome size. NG50 and assembly errors were counted by aligning the contigs to the truth sequence. Single base mismatches were allowed as long as they were flanked by 21 bases that match the graph. Breaks between two alignments were counted as misassemblies. The lengths of aligned sequences were used to calculate NG50.</p>
<p>The NG50 comparisons are shown in <xref ref-type="fig" rid="fig2">Figure 2</xref>. In the <italic>&#x201C;perfect&#x201D;</italic> data sets reconstructed without links, NG50 rises as <italic>k</italic>-mer size increases. This is to be expected as a longer <italic>k</italic>-mer size essentially encodes more connectivity information. Links, however, encode all available connectivity information at any value of <italic>k</italic>. Thus the linked NG50 value (solid green line) is equal to the best unlinked NG50 (dashed green line) over all values of <italic>k</italic>. The <italic>&#x201C;stochastic&#x201D;</italic> data sets (orange) follow a similar pattern, with the exception that the top value of <italic>k</italic> = 91 does not necessarily yield better NG50. As read starts are not available at every single base, some read overlaps are not present and the resulting contig is thus truncated. Finally, the <italic>&#x201C;error&#x201D;</italic> data set (blue) shows improved NG50 results when link information is used. When faced with sequencing error, our algorithms are not as readily capable of delivering <italic>k</italic>&#x2212;independent reconstructions, although using links does improve performance at all values of <italic>k</italic>.</p>
<fig id="fig2" position="float" orientation="portrait" fig-type="figure"><label>Figure 2:</label><caption><p>Assembly length metric NG50 on raw de Bruijn graphs (i.e. without links, dashed lines) and linked de Bruijn graphs (i.e. with links, solid lines), as a function of <italic>k</italic>-mer size. Assembling 1 Mbp of sequence (human GRCh37 chr22:28,000,000-28,999,999) with three simulated 100X read data sets: error free 100 bp reads, one read starting at every base (<italic>&#x201C;perfect&#x201D;, green</italic>); error free stochastic coverage (uniformly distributed read starts) (<italic>&#x201C;stochastic&#x201D;</italic>, orange); an error rate of 0.5&#x0025; and stochastic coverage (<italic>&#x201C;error&#x201D;</italic>, purple).</p></caption><graphic xlink:href="147777_fig2.tif"/></fig>
<p>To explain this behaviour, we note that at low <italic>k</italic>, sequencing errors introduce false edges between true <italic>k</italic>-mers. Since error correction on dBGs use <italic>k</italic>-mer counts rather than edge counts, these false edges do not get cleaned off. We estimated the number of false edges induced at various <italic>k</italic> to be 604, 139, 30, 7, 2, 1, 0, 0, 0 for <italic>k</italic> = 21, 31,&#x2026;, 91. Each false edge introduces a new bifurcation that may halt traversal. dBG implementations that use counts on edges instead of <italic>k</italic>-mers (as described in <xref ref-type="bibr" rid="c11">Conway and Bromage (2011)</xref>) may overcome this issue.</p>
</sec>
<sec id="s4d"><label>4.4</label><title>Comparison to string graph assembly</title>
<p>Next, we compared assembly performance between our LdBG implementation and the String Graph Assembler (<monospace>SGA</monospace>) (<xref ref-type="bibr" rid="c42">Simpson and Durbin, 2010</xref>). As stated above, string graphs are notable as their construction is based on the direct computation of read-to-read overlaps, facilitated by an FM-index on the reads. Similar to our work, <monospace>SGA</monospace> is able to use the full length of the read during assembly and should thus be able to assemble repeats shorter than a read length. However, <monospace>SGA</monospace> differs from our work in some key ways. Overlaps between reads need not be perfect, but rather are parametrised at run time to accept a minimum overlap of <italic>&#x03C4;<sub>min</sub></italic> bases and maximum error rate <italic>&#x03F5;<sub>max</sub></italic>. Additionally, SGA attempts to correct sequencing errors, rather than discarding them completely. In practice, these two factors may yield longer contigs, but at the expense of accuracy (<xref ref-type="bibr" rid="c7">Bradnam <italic>et al.</italic>, 2013</xref>).</p>
<p>The previous simulated haploid genome <italic>&#x201C;error&#x201D;</italic> read data set was used. As shown in <xref ref-type="fig" rid="fig2">Figure 2</xref>, <monospace>McCortex</monospace> is sensitive to sequencing error, so we ran bfc error correction (<xref ref-type="bibr" rid="c27">Li, 2015</xref>) on the reads before assembling. <monospace>bfc</monospace> error correction did not have a beneficial effect on <monospace>SGA</monospace> and was therefore not used. <monospace>SGA</monospace> was used to assemble at various values of <italic>&#x03C4;<sub>min</sub></italic>. While <italic>&#x03C4;<sub>min</sub></italic> and <italic>k</italic> are not identical parameters (without setting <italic>&#x03F5;<sub>max</sub></italic> = 0) they are still informative in terms of how many bases between reads are required to produce an overlap. Other <monospace>SGA</monospace> parameters were left to software defaults (most notable for <monospace>SGA&#x2019;s</monospace> error correction step, which learns the appropriate <italic>k</italic>-mer coverage cutoff threshold automatically). We did not carry out scaffolding or use paired end information in link construction.</p>
<p><monospace>SGA</monospace> and <monospace>McCortex</monospace> assemblies were compared using the same NG50 and assembly error metrics as above (see <xref ref-type="fig" rid="fig3">Figure 3</xref>). When compared to the the true genome, <monospace>McCortex&#x2019;s</monospace> NG50 is roughly the same as SGA at low and high <italic>k</italic>, but is much better at <italic>k</italic> = 41,&#x2026;,71. Assembly errors are about an order of magnitude lower.</p>
<fig id="fig3" position="float" orientation="portrait" fig-type="figure"><label>Figure 3:</label><caption><p>Assembly results for SGA and <monospace>McCortex</monospace> compared using a simulation on 1 Mbp of sequence (human GRCh37 chr22:28,000,000-28,999,999), using 100 bp reads with a per base error rate of 0.5&#x0025; and stochastic 100X coverage (&#x201C;<italic>error</italic>&#x201D; data set from <xref ref-type="fig" rid="fig2">Figure 2</xref>). Top panel: contig NG50 at different parameters of <italic>&#x03C4;<sub>min</sub></italic> (SGA) and <italic>k</italic> (LdBG). Bottom panel: number of assembly errors in contigs compared to truth.</p></caption><graphic xlink:href="147777_fig3.tif"/></fig>
</sec>
</sec>
<sec id="s5"><label>5</label><title>Results: applications</title>
<p>To assess LdBG on real data, we examined short read data from <italic>Klebsiella pneumoniae</italic>, a gram-negative bacteria that usually lives harmlessly in the mouth and gut of humans. However in the event of a weakened immune system, it can establish pathogenic colonies in the lung leading to inflammation and bleeding. It is also found in some cases of urinary tract infections. Antibiotic resistant strains of <italic>K. pneumoniae</italic> have been found in patients. We used McCortex for two tasks where long-range information is likely to be beneficial - finding large differences from a reference and analysis of genomic context for drug resistance genes, which we validated using a PacBio reference assembled for the sample (<xref ref-type="bibr" rid="c41">Sheppard <italic>et al.</italic>, 2016</xref>).</p>
<sec id="s5a"><label>5.1</label><title>Large-variant discovery</title>
<p>As links should provide useful guidance to navigating junctions in a graph, we examined their utility in calling large variants (insertions or deletions greater than 100 bp in length). We implemented a &#x201C;bubble caller&#x201D; (named for the characteristic motif produced by a biallelic mutation in a graph wherein paths diverge from one <italic>k</italic>-mer and rejoin at another) and tested it by calling variants in CAV1016, a <italic>K. pneumoniae</italic> isolate for which a high-quality PacBio sequence was available for validation. We constructed dBGs of the canonical reference sequence (GCF 000016305.1 ASM1630v1) and Illumina data for CAV1016. From these, we built LdBGs using the single-end Illumina reads for link construction. We applied our bubble caller to the dBG and LdBGs, allowing for a minimum event size of 100 bp and maximum of 200 kbp, and removing duplicate events. We validated called alleles by aligning the reference and alternate alleles to the canonical reference sequence and CAV1016 PacBio sequence, respectively. The resulting callsets without and with link information are presented in Supplementary <xref ref-type="table" rid="tbl1">Table 1</xref>.</p>
<table-wrap id="tbl1" position="float" orientation="landscape"><label>Table 1:</label><caption><p>Comparison of KPC-containing contigs to validation data, inferred with and without links</p></caption>
<graphic xlink:href="147777_tbl1.tif"/>
</table-wrap>
<p>Our bubble caller discovered 55 large indels in the dBG and 59 indels in the LdBG. All 55 variants from the dBG callset were recovered in the LdBG callset. The four remaining variants exclusive to the LdBG callset are all insertions of varying size (134, 246, 7, 952 and 11, 946 bp).</p>
<p>That the LdBG-exclusive events should all be insertions (particularly large ones) is perhaps not surprising; in a graphical framework, calling insertions against a high-quality reference sequence with comparatively lower quality Illumina data is expected to be more difficult than calling deletions. With insertions, sequencing error in the study sample will produce spurious paths in the graph, not all of which can be removed successfully, and thus graph traversal from the 5&#x2019; to the 3&#x2019; end of the alternate allele has many opportunities to fail. With deletions, the graph navigation burden is on the reference allele which should have substantially fewer errors (and thus fewer spurious paths) to confound traversal. Link-informed traversal helps alleviate this insertion/deletion detection bias, enabling the recovery of large events like the 8 and 12 kb events listed above. This improves our access to large variants underrepresented in current variant call sets (<xref ref-type="bibr" rid="c44">Weisenfeld <italic>et al.</italic>, 2014</xref>; <xref ref-type="bibr" rid="c26">Li, 2014b</xref>).</p>
</sec>
<sec id="s5b"><label>5.2</label><title>Reference-link guided assembly</title>
<p>Finally, we show that with links, we can use a panel of reference contigs derived from multiple sources to improve drug resistance locus characterisation in <italic>K. pneumoniae</italic> isolates. As the underlying graphs are considered immutable after construction, links derived from this panel cannot add <italic>k</italic>-mers to a sample. We hypothesised that the links panel could still provide valuable connectivity information where they were consistent with the graph without misleading the assembler in regions where they were divergent. We selected 21 <italic>K. pneumoniae</italic> isolates with known drug resistance status and that carry combinations of two alleles and two plasmid backgrounds at the <italic>K. pneumoniae</italic> carbapenemase (KPC) resistance locus, see <xref ref-type="table" rid="tbl1">Table 1</xref>. As references, we constructed links from a panel of four plasmid backgrounds carrying three different KPC alleles: PacBio sequences from two of the 21 isolates (carrying allele KPC-2), a KPC-harbouring plasmid from <italic>E. coli</italic> (carrying allele KPC-3), and a fourth <italic>K. pneumoniae</italic> plasmid known to harbour a resistance allele and background absent from the 21 isolates (carrying allele KPC-5). All accessions are described in Supplementary Table 2. Two assemblies were generated per isolate: one without links, and one with links.</p>
<p>Contigs harbouring the KPC sequence within the 21 isolates were identified by aligning to the KPC-2 allele sequence with LASTZ (<xref ref-type="bibr" rid="c18">Harris, 2007</xref>) and extracting the longest such contig from each assembly. These were aligned back to both the reference data sources and the validation data (<xref ref-type="bibr" rid="c29">Mathers <italic>et al.</italic>, 2015</xref>). For alignments that ran off the end of a sequence owing to the circular nature of the plasmids, we attempted to shift the contig sequence such that a linear alignment of maximum length was achieved; where this was not possible we have reported the length of the aligned region. The contig selected from each assembly was evaluated for correct KPC allele recovery, correct identification of plasmid background (i.e. sequence context of KPC allele), and mismatches/gaps to the relevant reference sequence. These results are shown in <xref ref-type="table" rid="tbl1">Table 1</xref>.</p>
<p>Without link information, we find that in 57&#x0025; of cases the plasmid background on which the KPC allele resides cannot be identified. In such cases, LASTZ reports alignments of the short contigs with 100&#x0025; sequence identity to plasmids 1 and 2. Moreover, for the CAV1360 isolate, the aligner determines the background incorrectly as the <italic>E. coli</italic> plasmid due to the presence of KPC-3.</p>
<p>Reconstruction with the link panel provides an order of magnitude increase in contig length over the link-uninformed reconstructions and the inferred plasmid membership matches the <xref ref-type="bibr" rid="c29">Mathers <italic>et al.</italic> (2015)</xref> determination in all 21 cases. Reconstructions from two isolates stand out. CAV1351 was known to carry the KPC-3 allele, while all other isolates carried the KPC-2 allele. The link-uninformed assembly produces a contig that maps to the <italic>E. coli</italic> KPC-3 sequence perfectly, but infers the wrong plasmid membership. The link-informed reconstruction, however, produces both the correct plasmid membership and correct allele. In another case, <xref ref-type="bibr" rid="c29">Mathers <italic>et al.</italic> (2015)</xref> reported CAV1077 to possess plasmid 1, but with an unspecified sequence alteration. Our reconstruction is able to establish both the correct plasmid membership and identify a 188 bp deletion in the intergenic region upstream from the transposase and downstream from the KPC genes (detected both with and without links). Combined, these analyses demonstrate how using external data sources as a means to guide assembly through &#x201C;reference links&#x201D; can lead to highly accurate reconstruction of even complex regions of the genome.</p>
</sec>
<sec id="s5c"><label>5.3</label><title>Scaling to human genomes</title>
<p>Finally, to assess the scalability of LdBG to large genomes, we constructed an LdBG (<italic>k</italic> = 31) from paired-end PCR-free human (NA12878) whole-genome Illumina data (2x150bp, 50X, accession ERR194147). Construction has a peak memory usage of 400 GiB; loading the cleaned LdBG into memory requires 70 GiB of RAM (50 GiB for the dBG, 20 GiB for links). Although the memory footprint of construction is high, there is large scope for improvement using compressed and/or disk-based methods (<xref ref-type="bibr" rid="c9">Chikhi and Rizk, 2013</xref>).</p>
</sec>
</sec>
<sec id="s6"><label>6</label><title>Discussion</title>
<p>We have presented a de novo assembly method that addresses the most important limitation of de Bruijn graphs: the ability to leverage long-range connectivity information inherent in read data. While cutting reads into small <italic>k</italic>-mers has long been a useful way of simultaneously computing read-to-read overlaps and overcoming high rates of sequencing error, increasing sequencing quality and read lengths have rendered de Bruijn assembly methods less attractive. String graphs have been successful in incorporating long-range data into assemblies, but sacrifice desirable computational properties of de Bruijn graphs. Our solution, Linked de Bruijn Graphs, combine the connectivity properties of string graphs with the rapid lookup of specific (multi-coloured) <italic>k</italic>-mers. Due to the wide range of uses of dBGs in sequence analysis, we believe this offers a potential improvement to many existing algorithms. Path encoding of reads has been suggested for read compression before (<xref ref-type="bibr" rid="c11">Conway and Bromage, 2011</xref>; <xref ref-type="bibr" rid="c23">Kingsford and Patro, 2015</xref>). However we believe this is the first implementation to use it for multi-colour assembly that can scale up to large mammalian genomes on modern computer hardware.</p>
<p>We have shown that read error correction and graph annotation can improve assembly performance of de Bruijn graphs and that this can be seen with the recovery of large (12kbp) events in short read sequences. Moreover, through application to real data we have shown that links can be generated from a wide range of sequencing technologies including data not used to construct the underlying dBG, and that this can be exploited to identify sequences of biological interest. LdBGs can also naturally represent paired-end connectivity information. We have proved that in the error-free setting, Linked de Bruijn Graphs losslessly store the genome sequence, even when constructed from short reads and agnostic of <italic>k</italic>.</p>
<p>Our method is useful for reconstructing complex loci across multiple samples using a common panel of pre-determined haplotypes. Link information derived from a haplotype panel cannot add <italic>k</italic>-mers or edges to the graph that were not observed in the original dataset. Nevertheless, assembly is enhanced in regions where the links are consistent with the graph, and naturally defaults to link-uninformed navigation in regions of discrepancy. Threading a panel of haplotypes from multiple samples through each graph thus identifies only the relevant sections of each donor haplotype.</p>
<p>One shortcoming of long links is the accumulated probability of encountering an error during traversal. If a link takes the wrong branch of an error-induced bubble, cleaning that junction choice trims off all the remaining information about the junction choices made beyond the bubble. This shortcoming results in link coverage dropping off quicker than expected as links get longer, resulting in truncated links. This could be addressed by error-correcting groups of links that start at the same <italic>k</italic>-mer.</p>
<p>We have implemented a very simple read mapping, which trusts all <italic>k</italic>-mers from a read if there is a perfect match in the graph, and which only attempts to fill gaps using linear time graph traversal. Optimal mapping is ultimately NP-hard, but more advanced heuristic methods are available which may perform better than our approach (<xref ref-type="bibr" rid="c28">Limasset <italic>et al.</italic>, 2016</xref>). Improvement may be most noticeable for high error rate sequencing data and in low complexity regions of the graph.</p>
<p>Finally, there is scope for reducing memory consumption, given very few <italic>k</italic>-mers actually have links attached (see Supplementary Figure 6) and could be further reduced with better encoding in memory of the junction choice tree held by a <italic>k</italic>-mer (i.e. <italic>L</italic>(<italic>v</italic>)). For example, using a binary encoding of the tree of junction choices, or generative path encoding proposed to compress sequence data (<xref ref-type="bibr" rid="c23">Kingsford and Patro, 2015</xref>).</p>
</sec>
</body>
<back>
<ack><title>Acknowledgements</title>
<p>We thank Jerome Kelleher for his many useful comments and edits, Rachel Norris for her pointers and insight into the <italic>K. pneumoniae</italic> dataset, and the other members of the McVean group for useful discussions during the preparation of this manuscript.</p>
</ack>
<sec id="s7" sec-type="funding"><title>Funding</title>
<p>This work was supported by the Wellcome Trust (grant numbers 090532/Z/09/Z and 100956/Z/13/Z). K.V.G. was supported by Wellcome Trust Research Studentship award (097310/Z/11/Z). I.T. was supported by a PhD studentship from the BBSRC. Z.I. was funded by a Wellcome Trust/Royal Society Sir Henry Dale Fellowship (grant 102541/Z/13/Z).</p>
</sec>
<sec sec-type="COI-statement"><title>Conflicts of interest</title>
<p>None.</p></sec>
<ref-list><title>References</title>
<ref id="c1"><mixed-citation publication-type="journal"><string-name><surname>Aguilera</surname>,<given-names>A.</given-names></string-name> and <string-name><surname>G&#x00F3;mez-Gonz&#x00E1;lez</surname>,<given-names>B.</given-names></string-name> (<year>2008</year>). <article-title>Genome instability: a mechanistic view of its causes and consequences</article-title>. <source>Nature Reviews Genetics</source>, <volume>9</volume> (<issue>3</issue>), <fpage>204</fpage>&#x2013;<lpage>217</lpage>.</mixed-citation></ref>
<ref id="c2"><mixed-citation publication-type="journal"><string-name><surname>Artzy-Randrup</surname>,<given-names>Y.</given-names></string-name> <etal>et al.</etal> (<year>2012</year>). <article-title>Population structuring of multi-copy, antigen-encoding genes in Plasmodium falciparum</article-title>. <source>eLife</source>, <volume>1</volume>, <fpage>e00093</fpage>&#x2013;<lpage>e00093</lpage>.</mixed-citation></ref>
<ref id="c3"><mixed-citation publication-type="book"><string-name><surname>Bateman</surname>,<given-names>A.</given-names></string-name> <etal>et al.</etal> (<year>2016</year>). <chapter-title>Limitations of Current Approaches for Reference-Free, Graph-Based Variant Detection</chapter-title>. In <source>Proceedings of the 7th ACM International Conference on Bioinformatics, Computational Biology, and Health Informatics</source>, pages <fpage>499</fpage>&#x2013;<lpage>500</lpage>, <publisher-loc>New York, NY, USA</publisher-loc>. ACM.</mixed-citation></ref>
<ref id="c4"><mixed-citation publication-type="journal"><string-name><surname>Bonizzoni</surname></string-name><etal>et al.</etal> (<year>2016</year>) <article-title>An external-memory algorithm for string graph construction</article-title>. <source>Algorithmica</source>, <volume>78</volume>(<issue>2</issue>):<fpage>394</fpage>&#x2013;<lpage>424</lpage>.</mixed-citation></ref>
<ref id="c5"><mixed-citation publication-type="book"><string-name><surname>Bowe</surname>,<given-names>A.</given-names></string-name> <etal>et al.</etal> (<year>2012</year>). <chapter-title>Succinct de Bruijn Graphs</chapter-title>. In <person-group person-group-type="editor"><string-name><given-names>B.</given-names> <surname>Raphael</surname></string-name> and <string-name><given-names>J.</given-names> <surname>Tang</surname></string-name>,</person-group> editors, <source>Algorithms in Bioinformatics</source>, pages <fpage>225</fpage>&#x2013;<lpage>235</lpage>. <publisher-name>Springer Berlin Heidelberg</publisher-name>, <publisher-loc>Berlin, Heidelberg</publisher-loc>.</mixed-citation></ref>
<ref id="c6"><mixed-citation publication-type="journal"><string-name><surname>Bradley</surname>,<given-names>P.</given-names></string-name> <etal>et al.</etal> (<year>2015</year>). <article-title>Rapid antibiotic-resistance predictions from genome sequence data for Staphylococcus aureus and Mycobacterium tuberculosis</article-title>. <source>Nature Communications</source>, <volume>6</volume>, <fpage>10063</fpage>&#x2013;<lpage>10063</lpage>.</mixed-citation></ref>
<ref id="c7"><mixed-citation publication-type="journal"><string-name><surname>Bradnam</surname>,<given-names>K.R.</given-names></string-name> <etal>et al.</etal> (<year>2013</year>). <article-title>Assemblathon 2: evaluating de novo methods of genome assembly in three vertebrate species</article-title>. <source>GigaScience</source>, <volume>2</volume>(<issue>1</issue>), <fpage>10</fpage>&#x2013;<lpage>10</lpage>.</mixed-citation></ref>
<ref id="c8"><mixed-citation publication-type="book"><string-name><surname>Chikhi</surname>,<given-names>R.</given-names></string-name> and <string-name><surname>Lavenier</surname>,<given-names>D.</given-names></string-name> (<year>2011</year>). <chapter-title>Localized Genome Assembly from Reads to Scaffolds: Practical Traversal of the Paired String Graph</chapter-title>. In <person-group person-group-type="editor"><string-name><given-names>T.</given-names> <surname>Przytycka</surname></string-name> and <string-name><given-names>M.-F.</given-names> <surname>Sagot</surname></string-name></person-group>, editors, <source>Algorithms in Bioinformatics</source>, pages <fpage>39</fpage>&#x2013;<lpage>48</lpage>. <publisher-name>Springer Berlin Heidelberg</publisher-name>, <publisher-loc>Berlin, Heidelberg</publisher-loc>.</mixed-citation></ref>
<ref id="c9"><mixed-citation publication-type="journal"><string-name><surname>Chikhi</surname>,<given-names>R.</given-names></string-name> and <string-name><surname>Rizk</surname>,<given-names>G.</given-names></string-name> (<year>2013</year>). <article-title>Space-efficient and exact de Bruijn graph representation based on a Bloom filter</article-title>. <source>Algorithms for Molecular Biology</source>, <volume>8</volume>(<issue>1</issue>), <fpage>22</fpage>&#x2013;<lpage>22</lpage>.</mixed-citation></ref>
<ref id="c10"><mixed-citation publication-type="journal"><string-name><surname>Chikhi</surname>,<given-names>R.</given-names></string-name> <etal>et al.</etal> (<year>2014</year>). <article-title>On the representation of de Bruijn graphs</article-title>. <source>Journal of Computational Biology</source>, <volume>22</volume>(<issue>5</issue>), <fpage>336</fpage>&#x2013;<lpage>352</lpage>.</mixed-citation></ref>
<ref id="c11"><mixed-citation publication-type="journal"><string-name><surname>Conway</surname>,<given-names>T.C.</given-names></string-name> and <string-name><surname>Bromage</surname>,<given-names>A.J.</given-names></string-name> (<year>2011</year>). <article-title>Succinct data structures for assembling large genomes</article-title>. <source>Bioinformatics</source>, <volume>27</volume>(<issue>4</issue>), <fpage>479</fpage>&#x2013;<lpage>486</lpage>.</mixed-citation></ref>
<ref id="c12"><mixed-citation publication-type="journal"><string-name><surname>Dilthey</surname>, <given-names>A.</given-names></string-name> <etal>et al.</etal> (<year>2015</year>) <article-title>Improved genome inference in the MHC using a population reference graph</article-title>. <source>Nat. Genet.</source> <volume>47</volume>, <fpage>682</fpage>&#x2013;<lpage>688</lpage>.</mixed-citation></ref>
<ref id="c13"><mixed-citation publication-type="journal"><string-name><surname>de Bruijn</surname>,<given-names>N.G.</given-names></string-name> (<year>1946</year>). <article-title>A Combinatorial Problem</article-title>. <source>Koninklijke Nederlandsche Akademie Van Wetenschappen</source>, <volume>49</volume>(<issue>6</issue>), <fpage>758</fpage>&#x2013;<lpage>764</lpage>.</mixed-citation></ref>
<ref id="c14"><mixed-citation publication-type="journal"><string-name><surname>Difilippantonio</surname>,<given-names>M.J.</given-names></string-name> <etal>et al.</etal> (<year>2002</year>). <article-title>Evidence for replicative repair of DNA double-strand breaks leading to oncogenic translocation and gene amplification</article-title>. <source>The Journal of Experimental Medicine</source>, <volume>196</volume>(<issue>4</issue>), <fpage>469</fpage>&#x2013;<lpage>480</lpage>.</mixed-citation></ref>
<ref id="c15"><mixed-citation publication-type="book"><string-name><surname>Ferragina</surname>,<given-names>P.</given-names></string-name> and <string-name><surname>Manzini</surname>,<given-names>G.</given-names></string-name> (<year>2000</year>). <chapter-title>Opportunistic data structures with applications</chapter-title>. In <source>Foundations of Computer Science, 2000. Proceedings. 41st Annual Symposium on</source>, pages <fpage>390</fpage>&#x2013;<lpage>398</lpage>, <publisher-loc>Los Alamitos, CA, USA</publisher-loc>. <publisher-name>IEEE</publisher-name>.</mixed-citation></ref>
<ref id="c16"><mixed-citation publication-type="journal"><string-name><surname>Freitas-Junior</surname>,<given-names>L.H.</given-names></string-name> <etal>et al.</etal> (<year>2000</year>). <article-title>Frequent ectopic recombination of virulence factor genes in telomeric chromosome clusters of P. falciparum</article-title>. <source>Nature</source>, <volume>407</volume>(<issue>6807</issue>), <fpage>1018</fpage>&#x2013;<lpage>1022.</lpage></mixed-citation></ref>
<ref id="c17"><mixed-citation publication-type="journal"><string-name><surname>Goodwin</surname>,<given-names>S.</given-names></string-name> <etal>et al.</etal> (<year>2016</year>). <article-title>Coming of age: ten years of next-generation sequencing technologies</article-title>. <source>Nature Reviews Genetics</source>, <volume>17</volume>(<issue>6</issue>), <fpage>333</fpage>&#x2013;<lpage>351</lpage>.</mixed-citation></ref>
<ref id="c18"><mixed-citation publication-type="book"><string-name><surname>Harris</surname>,<given-names>R.S.</given-names></string-name> (<year>2007</year>). <chapter-title>Improved Pairwise Alignment of Genomic DNA</chapter-title>. PhD thesis, <publisher-name>Pennsylvania State Univ</publisher-name>.</mixed-citation></ref>
<ref id="c47"><mixed-citation publication-type="journal"><string-name><surname>Huang</surname> <given-names>L.</given-names></string-name> <etal>et al.</etal> (<year>2013</year>). <article-title>Short read alignment with populations of genomes</article-title>. <source>Bioinformatics</source> <volume>29</volume>, <fpage>i361</fpage>&#x2013;<lpage>i370</lpage>.</mixed-citation></ref>
<ref id="c19"><mixed-citation publication-type="journal"><string-name><surname>Idury</surname>,<given-names>R.M.</given-names></string-name> and <string-name><surname>Waterman</surname>, <given-names>M.S.</given-names></string-name> (<year>1995</year>). <article-title>A new algorithm for DNA sequence assembly</article-title>. <source>Journal of Computational Biology</source>, <volume>2</volume>(<issue>2</issue>), <fpage>291</fpage>&#x2013;<lpage>306</lpage>.</mixed-citation></ref>
<ref id="c20"><mixed-citation publication-type="journal"><string-name><surname>Iqbal</surname>,<given-names>Z.</given-names></string-name> <etal>et al.</etal> (<year>2012</year>). <article-title>De novo assembly and genotyping of variants using colored de Bruijn graphs</article-title>. <source>Nature Genetics</source>, <volume>44</volume>(<issue>2</issue>), <fpage>226</fpage>&#x2013;<lpage>232</lpage>.</mixed-citation></ref>
<ref id="c21"><mixed-citation publication-type="journal"><string-name><surname>Iqbal</surname>,<given-names>Z.</given-names></string-name> <etal>et al.</etal> (<year>2013</year>). <article-title>High-throughput microbial population genomics using the Cortex variation assembler</article-title>. <source>Bioinformatics</source>, <volume>29</volume>(<issue>2</issue>), <fpage>275</fpage>&#x2013;<lpage>276</lpage>.</mixed-citation></ref>
<ref id="c22"><mixed-citation publication-type="journal"><string-name><surname>Jackson</surname>,<given-names>A.P.</given-names></string-name> <etal>et al.</etal> (<year>2012</year>). <article-title>Antigenic diversity is generated by distinct evolutionary mechanisms in African trypanosome species</article-title>. <source>Proceedings of the National Academy of Sciences</source>, <volume>109</volume>(<issue>9</issue>), <fpage>3416</fpage>&#x2013;<lpage>3421</lpage>.</mixed-citation></ref>
<ref id="c23"><mixed-citation publication-type="journal"><string-name><surname>Kingsford</surname>,<given-names>C.</given-names></string-name> and <string-name><surname>Patro</surname>,<given-names>R.</given-names></string-name> (<year>2015</year>). <article-title>Reference-based compression of short-read sequences using path encoding</article-title>. <source>Bioinformatics</source>, <volume>31</volume>(<issue>12</issue>), <fpage>1920</fpage>&#x2013;<lpage>1928</lpage>.</mixed-citation></ref>
<ref id="c24"><mixed-citation publication-type="journal"><string-name><surname>Li</surname>,<given-names>H.</given-names></string-name> (<year>2012</year>). <article-title>Exploring single-sample SNP and INDEL calling with whole-genome de novo assembly</article-title>. <source>Bioinformatics</source>, <volume>28</volume>(<issue>14</issue>), <fpage>1838</fpage>&#x2013;<lpage>1844</lpage>.</mixed-citation></ref>
<ref id="c25"><mixed-citation publication-type="journal"><string-name><surname>Li</surname>,<given-names>H.</given-names></string-name> (<year>2014a</year>). <article-title>Fast construction of FM-index for long sequence reads</article-title>. <source>Bioinformatics</source>, <volume>30</volume>(<issue>22</issue>), <fpage>3274</fpage>&#x2013;<lpage>3275</lpage>.</mixed-citation></ref>
<ref id="c26"><mixed-citation publication-type="journal"><string-name><surname>Li</surname>,<given-names>H.</given-names></string-name> (<year>2014b</year>). <article-title>Toward better understanding of artifacts in variant calling from high-coverage samples</article-title>. <source>Bioinformatics</source>, <volume>30</volume>(<issue>20</issue>), <fpage>2843</fpage>&#x2013;<lpage>2851</lpage>.</mixed-citation></ref>
<ref id="c27"><mixed-citation publication-type="journal"><string-name><surname>Li</surname>,<given-names>H.</given-names></string-name> (<year>2015</year>). <article-title>BFC: correcting Illumina sequencing errors</article-title>. <source>Bioinformatics</source>, <volume>31</volume>(<issue>17</issue>), <fpage>2885</fpage>&#x2013;<lpage>2887</lpage>.</mixed-citation></ref>
<ref id="c28"><mixed-citation publication-type="journal"><string-name><surname>Limasset</surname>,<given-names>A.</given-names></string-name> <etal>et al.</etal> (<year>2016</year>). <article-title>Read mapping on de Bruijn graphs</article-title>. <source>BMC Bioinformatics</source>, <volume>17</volume>(<issue>1</issue>), <fpage>237</fpage>&#x2013;<lpage>237</lpage>.</mixed-citation></ref>
<ref id="c29"><mixed-citation publication-type="journal"><string-name><surname>Mathers</surname>,<given-names>A.J.</given-names></string-name> <etal>et al.</etal> (<year>2015</year>). <article-title>Klebsiella pneumoniae carbapenemase (KPC) producing K. pneumoniae at a Single Institution: Insights into Endemicity from Whole Genome Sequencing</article-title>. <source>Antimicrobial Agents and Chemotherapy</source>, <volume>59</volume>(<issue>3</issue>), <fpage>1656</fpage>&#x2013;<lpage>1663</lpage></mixed-citation></ref>
<ref id="c30"><mixed-citation publication-type="journal"><string-name><surname>McVean</surname>,<given-names>G.A.</given-names></string-name> <etal>et al.</etal> (<year>2012</year>). <article-title>An integrated map of genetic variation from 1,092 human genomes</article-title>. <source>Nature</source>, <volume>491</volume>(<issue>7422</issue>), <fpage>56</fpage>&#x2013;<lpage>65</lpage>.</mixed-citation></ref>
<ref id="c31"><mixed-citation publication-type="journal"><string-name><surname>Miller</surname>,<given-names>J.R.</given-names></string-name> <etal>et al.</etal> (<year>2010</year>). <article-title>Assembly algorithms for next-generation sequencing data</article-title>. <source>Genomics</source>, <volume>95</volume>(<issue>6</issue>), <fpage>315</fpage>&#x2013;<lpage>327</lpage>.</mixed-citation></ref>
<ref id="c32"><mixed-citation publication-type="journal"><string-name><surname>Myers</surname>,<given-names>E.W.</given-names></string-name> (<year>1995</year>). <article-title>Toward simplifying and accurately formulating fragment assembly</article-title>. <source>Journal of Computational Biology</source>, <volume>2</volume>(<issue>2</issue>), <fpage>275</fpage>&#x2013;<lpage>290</lpage>.</mixed-citation></ref>
<ref id="c33"><mixed-citation publication-type="journal"><string-name><surname>Myers</surname>, <given-names>E.W.</given-names></string-name> (<year>2005</year>). <article-title>The fragment assembly string graph</article-title>. <source>Bioinformatics</source>, <volume>21</volume> (<issue>suppl 2</issue>), <fpage>ii79</fpage>&#x2013;<lpage>ii85</lpage>.</mixed-citation></ref>
<ref id="c34"><mixed-citation publication-type="journal"><string-name><surname>Pevzner</surname>, <given-names>P.A.</given-names></string-name> (<year>1989</year>). <article-title>l-Tuple DNA sequencing: computer analysis</article-title>. <source>Journal of Biomolecular Structure &#x0026; Dynamics</source>, <volume>7</volume>(<issue>1</issue>), <fpage>63</fpage>&#x2013;<lpage>73</lpage>.</mixed-citation></ref>
<ref id="c35"><mixed-citation publication-type="journal"><string-name><surname>Pevzner</surname>, <given-names>P.A.</given-names></string-name> <etal>et al.</etal> (<year>2004</year>). <article-title>De Novo Repeat Classification and Fragment Assembly</article-title>. <source>Genome Research</source>, <volume>14</volume>(<issue>9</issue>), <fpage>1786</fpage>&#x2013;<lpage>1796</lpage>.</mixed-citation></ref>
<ref id="c36"><mixed-citation publication-type="journal"><string-name><surname>Read</surname>,<given-names>B.A.</given-names></string-name> <etal>et al.</etal> (<year>2013</year>). <article-title>Pan genome of the phytoplankton Emiliania underpins its global distribution</article-title>. <source>Nature</source>, <volume>499</volume>(<issue>7457</issue>), <fpage>209</fpage>&#x2013;<lpage>213</lpage>.</mixed-citation></ref>
<ref id="c37"><mixed-citation publication-type="journal"><string-name><surname>Ribeiro</surname>,<given-names>A.</given-names></string-name> <etal>et al.</etal> (<year>2015</year>). <article-title>An investigation of causes of false positive single nucleotide polymorphisms using simulated reads from a small eukaryote genome</article-title>. <source>BMC Bioinformatics</source>, <volume>16</volume>(<issue>1</issue>), <fpage>382</fpage>.</mixed-citation></ref>
<ref id="c38"><mixed-citation publication-type="journal"><string-name><surname>Rimmer</surname>,<given-names>A.</given-names></string-name> <etal>et al.</etal> (<year>2014</year>). <article-title>Integrating mapping-, assembly- and haplotype-based approaches for calling variants in clinical sequencing applications</article-title>. <source>Nature Genetics</source>, <volume>46</volume>(<issue>8</issue>), <fpage>912</fpage>&#x2013;<lpage>918</lpage>.</mixed-citation></ref>
<ref id="c39"><mixed-citation publication-type="journal"><string-name><surname>Rizk</surname>,<given-names>G.</given-names></string-name> <etal>et al.</etal> (<year>2013</year>). <article-title>DSK: k-mer counting with very low memory usage</article-title>. <source>Bioinformatics</source>, <volume>29</volume>(<issue>5</issue>), <fpage>652</fpage>&#x2013;<lpage>653</lpage>.</mixed-citation></ref>
<ref id="c40"><mixed-citation publication-type="journal"><string-name><surname>Schneeberger</surname>, <given-names>K.</given-names></string-name> <etal>et al.</etal> (<year>2009</year>). <article-title>Simultaneous alignment of short reads against multiple genomes</article-title>. <source>Genome Biol.</source>, <volume>10</volume>, <fpage>R98</fpage>.</mixed-citation></ref>
<ref id="c41"><mixed-citation publication-type="journal"><string-name><surname>Sheppard</surname>,<given-names>A.E.</given-names></string-name> <etal>et al.</etal> (<year>2016</year>). <article-title>Nested Russian Doll-Like Genetic Mobility Drives Rapid Dissemination of the Carbapenem Resistance Gene blaKPC</article-title>. <source>Antimicrobial Agents and Chemotherapy</source>, <volume>60</volume>(<issue>6</issue>), <fpage>3767</fpage>&#x2013;<lpage>3778</lpage>.</mixed-citation></ref>
<ref id="c42"><mixed-citation publication-type="journal"><string-name><surname>Simpson</surname>,<given-names>J.T.</given-names></string-name> and <string-name><surname>Durbin</surname>, <given-names>R.</given-names></string-name> (<year>2010</year>). <article-title>Efficient construction of an assembly string graph using the FM-index</article-title>. <source>Bioinformatics</source>, <volume>26</volume>(<issue>12</issue>), <fpage>i367</fpage>&#x2013;<lpage>i373</lpage>.</mixed-citation></ref>
<ref id="c43"><mixed-citation publication-type="journal"><string-name><surname>Simpson</surname>,<given-names>J.T.</given-names></string-name> <etal>et al.</etal> (<year>2009</year>). <article-title>ABySS: A parallel assembler for short read sequence data</article-title>. <source>Genome Research</source>, <volume>19</volume>(<issue>6</issue>), <fpage>1117</fpage>&#x2013;<lpage>1123</lpage>.</mixed-citation></ref>
<ref id="c44"><mixed-citation publication-type="journal"><string-name><surname>Weisenfeld</surname>,<given-names>N.I.</given-names></string-name> <etal>et al.</etal> (<year>2014</year>). <article-title>Comprehensive variation discovery in single human genomes</article-title>. <source>Nature Genetics</source>, <volume>46</volume>(<issue>12</issue>), <fpage>1350</fpage>&#x2013;<lpage>1355</lpage>.</mixed-citation></ref>
<ref id="c45"><mixed-citation publication-type="journal"><string-name><surname>Zerbino</surname>,<given-names>D.R.</given-names></string-name> (<year>2010</year>). <article-title>Using the Velvet de novo assembler for short-read sequencing technologies</article-title>. <source>Curr. Protoc. Bioinformatics</source>, <volume>31</volume>, <fpage>11.5.1</fpage>&#x2013;<lpage>11.5.12.</lpage></mixed-citation></ref>
<ref id="c46"><mixed-citation publication-type="journal"><string-name><surname>Zerbino</surname>,<given-names>D.R.</given-names></string-name> and <string-name><surname>Birney</surname>, <given-names>E.</given-names></string-name> (<year>2008</year>). <article-title>Velvet: algorithms for de novo short read assembly using de Bruijn graphs</article-title>. <source>Genome Research</source>, <volume>18</volume>(<issue>5</issue>), <fpage>821</fpage>&#x2013;<lpage>829</lpage>.</mixed-citation></ref>
</ref-list></back>
</article>
