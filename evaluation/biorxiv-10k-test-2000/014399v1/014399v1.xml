<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.2d1 20170631//EN" "JATS-archivearticle1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" article-type="article" dtd-version="1.2d1" specific-use="production" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">BIORXIV</journal-id>
<journal-title-group>
<journal-title>bioRxiv</journal-title>
<abbrev-journal-title abbrev-type="publisher">bioRxiv</abbrev-journal-title>
</journal-title-group>
<publisher>
<publisher-name>Cold Spring Harbor Laboratory</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1101/014399</article-id>
<article-version>1.1</article-version>
<article-categories>
<subj-group subj-group-type="author-type">
<subject>Regular Article</subject>
</subj-group>
<subj-group subj-group-type="heading">
<subject>New Results</subject>
</subj-group>
<subj-group subj-group-type="hwp-journal-coll">
<subject>Bioinformatics</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>Do Read Errors Matter for Genome Assembly?</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<name><surname>Shomorony</surname><given-names>Ilan</given-names></name>
<xref ref-type="aff" rid="a1">1</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Courtade</surname><given-names>Thomas</given-names></name>
<xref ref-type="aff" rid="a2">2</xref></contrib>
<contrib contrib-type="author">
<name><surname>Tse</surname><given-names>David</given-names></name>
<xref ref-type="aff" rid="a3">3</xref></contrib>
<aff id="a1"><label>1</label><institution>UC Berkeley</institution>, <email>ilan.shomorony@berkeley.edu</email></aff>
<aff id="a2"><label>2</label><institution>UC Berkeley</institution>, <email>courtade@berkeley.edu</email></aff>
<aff id="a3"><label>3</label><institution>Stanford University</institution>, <email>dntse@stanford.edu</email></aff>
</contrib-group>
<pub-date pub-type="epub">
<year>2015</year>
</pub-date>
<elocation-id>014399</elocation-id>
<history>
<date date-type="received">
<day>25</day>
<month>1</month>
<year>2015</year>
</date>
<date date-type="accepted">
<day>26</day>
<month>1</month>
<year>2015</year>
</date>
</history>
<permissions>
<copyright-statement>&#x00A9; 2015, Posted by Cold Spring Harbor Laboratory</copyright-statement>
<copyright-year>2015</copyright-year>
<license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by/4.0/"><license-p>This pre-print is available under a Creative Commons License (Attribution 4.0 International), CC BY 4.0, as described at <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link></license-p></license>
</permissions>
<self-uri xlink:href="014399.pdf" content-type="pdf" xlink:role="full-text"/>
<abstract><title>Abstract</title>
<p>While most current high-throughput DNA sequencing technologies generate short reads with low error rates, emerging sequencing technologies generate long reads with high error rates. A basic question of interest is the tradeoff between read length and error rate in terms of the information needed for the perfect assembly of the genome. Using an adversarial erasure error model, we make progress on this problem by establishing a critical read length, as a function of the genome and the error rate, above which perfect assembly is guaranteed. For several real genomes, including those from the GAGE dataset, we verify that this critical read length is not significantly greater than the read length required for perfect assembly from reads without errors.</p>
</abstract>
<counts>
<page-count count="5"/>
</counts>
</article-meta>
</front>
<body>
<sec id="s1">
<label>I.</label><title>Introduction</title>
<p>Current DNA sequencing technologies are based on a two-step process. First, tens or hundreds of millions of fragments from random locations on the DNA sequence are read via <italic>shotgun sequencing</italic>. Second, these fragments, called reads, are merged to each other based on regions of overlap, using an <italic>assembly algorithm</italic>.</p>
<p>Roughly speaking, different shotgun sequencing platforms can be distinguished from the point of view of three main metrics: the <italic>read length</italic>, the <italic>read error rate</italic>, and the <italic>read throughput</italic>. In the last decade, the so-called next-generation sequencing platforms have attained considerable success at employing heavy parallelization in order to achieve <italic>high-throughput</italic> shotgun sequencing. This allowed a significant reduction in the cost and time of sequencing, causing an explosion in the number of new sequencing projects and the generation of massive amounts of sequencing data.</p>
<p>In order to guarantee low error rates, most of these next-generation technologies are restricted to <italic>short read lengths</italic>, shifting some of the burden of sequencing to the assembly step. In practice, this results in very fragmented assemblies, with large gaps and little linking information between fragments [<xref ref-type="bibr" rid="c1">1</xref>]. On the other hand, recent technologies that generate longer reads suffer from lower throughput and much higher error rates<sup><xref ref-type="fn" rid="fn1">1</xref></sup>.</p>
<p>Given this technology trend, the natural questions to ask are: what is the impact of read errors on the performance of assemblers? Is the negative impact of read errors more than offset by the increase in read lengths in long-read technologies? It is well known that read errors have a significant impact on assembly algorithms. For example, in DeBruijn graph based algorithms, read errors create extraneous nodes and edges in the assembly graph, which results in added complexity. However, these observations pertain to <italic>specific</italic> algorithms. A more fundamental question can be asked from an <italic>information-theoretic</italic> point of view: given a read length, an error rate and a coverage depth (number of reads per base), is there enough <italic>information</italic> in the read data to uniquely reconstruct the genome? Do errors significantly increase the read length and/or coverage depth requirements? An answer to these basic feasibility questions can provide an algorithm-independent framework for evaluating different sequencing technologies. It would also settle some speculations in the assembly community on whether read errors have a significant impact in long-read technologies (see for example [<xref ref-type="bibr" rid="c2">2</xref>]).</p>
<p>Such a framework was initiated in [<xref ref-type="bibr" rid="c3">3</xref>] for <italic>error-free</italic> reads: a feasibility curve relating the read length and coverage depth needed to perfectly assemble a genome was characterized in terms of the repeat complexity of the genome (see examples in <xref ref-type="fig" rid="fig1">Fig. 1</xref>). Evaluating this curve on several genomes revealed an interesting threshold phenomenon: if the read length is below a certain critical value <italic>&#x2113;</italic><sub>crit</sub>, reconstruction is impossible; a read length slightly above <italic>&#x2113;</italic><sub>crit</sub> and a coverage depth close to the Lander-Waterman depth <italic>c</italic><sub><italic>LW</italic></sub> (i.e., just enough reads to cover the whole sequence) is sufficient. The critical read length <italic>&#x2113;</italic><sub>crit</sub> is given by the length of the longest <italic>interleaved repeat</italic> in the genome, and coincides with the minimum read length <italic>L</italic> needed to uniquely reconstruct the genome given its <italic>L-spectrum</italic>, i.e. the set of reads with one length-<italic>L</italic> read starting at each position of the sequence, illustrated in <xref ref-type="fig" rid="fig2">Fig. 2</xref>. This minimum read length also appeared in earlier works by Ukkonen and Pevzner [<xref ref-type="bibr" rid="c4">4</xref>, <xref ref-type="bibr" rid="c5">5</xref>] for reconstruction via <italic>sequencing by hybridization</italic>.</p>
<fig id="fig1" position="float" fig-type="figure">
<label>Fig. 1.</label>
<caption><p>The thick black curve is a feasibility lower bound for any algorithm, and the green line represents the performance of the Multibridging algorithm [<xref ref-type="bibr" rid="c3">3</xref>].</p></caption>
<graphic xlink:href="014399_fig1.tif"/></fig>
<fig id="fig2" position="float" fig-type="figure">
<label>Fig. 2.</label>
<caption><p>The sequence s and its <italic>L</italic>-spectrum, &#x1D4E1;<sub><italic>L</italic>, 0</sub>(<bold>s</bold>).</p></caption>
<graphic xlink:href="014399_fig2.tif"/></fig>
<p>Given this framework, the impact of read errors can be studied by asking how much the critical read length <italic>&#x2113;</italic><sub>crit</sub> increases when there are errors. In this paper, we investigate this tradeoff for a specific error model: 1) the errors are erasures; 2) the erasures occur at a rate no larger than <italic>D</italic>/<italic>L</italic> for each read and for each base in the sequence, but are otherwise arbitrary. Our main result is the characterization of a critical read length <italic>&#x2113;</italic>&#x0303;<sub>crit</sub> above which perfect assembly is always possible. While in the noiseless case <italic>&#x2113;</italic><sub>crit</sub> is a function of the sequence repeat structure, <italic>&#x2113;</italic>&#x0303;<sub>crit</sub> depends more generally on the error rate and on the <italic>approximate repeats</italic> in the sequence. More concretely, for a sequence <italic>s</italic>,
<disp-formula><alternatives><graphic xlink:href="014399_ueqn1.gif"/></alternatives></disp-formula>
where <italic>M</italic><sub><bold>s</bold></sub>(<italic>D</italic>, <italic>&#x2113;</italic>) is the maximum number of <italic>D</italic>-approximate length-<italic>&#x2113;</italic> repeats in s. Moreover, reminiscent of classical coding theory results, we show that the same read length <italic>&#x2113;</italic>&#x0303;<sub>crit</sub> is sufficient for assembly if instead of erasures we consider substitution errors at half of the rate. In order to characterize <italic>&#x2113;</italic>&#x0303;<sub>crit</sub>, we derive a new result about the error correction capability of the <italic>L</italic>-spectrum. More precisely, we show that given a noisy version of the <italic>L</italic>-spectrum of a sequence, it is possible to obtain the noiseless (<italic>k</italic> &#x002B; 1)-spectrum of the same sequence, for any <italic>k</italic> such that <italic>L</italic> &#x003E; <italic>k</italic> &#x002B; <italic>D</italic> &#x00B7; <italic>M</italic><sub>s</sub>(<italic>D</italic>, <italic>k</italic> &#x002B; 1). When <italic>L</italic> &#x003E; <italic>&#x2113;</italic>&#x0303;<sub>crit</sub> we can obtain the noiseless (<italic>k</italic> &#x002B; 1) spectrum for some <italic>k</italic> &#x003E; <italic>&#x2113;</italic><sub>crit</sub>, and the noiseless result from [<xref ref-type="bibr" rid="c3">3</xref>] implies that perfect assembly is possible.</p>
<p>By evaluating <italic>&#x2113;</italic>&#x0303;<sub>crit</sub> on several real genomes, including those in the GAGE dataset [<xref ref-type="bibr" rid="c6">6</xref>], we verify that <italic>&#x2113;</italic>&#x0303;<sub>crit</sub> is not significantly larger than <italic>&#x2113;</italic><sub>crit</sub>. In fact, in most cases, <italic>&#x2113;</italic>&#x0303;<sub>crit</sub> &#x2248; <italic>&#x2113;</italic><sub>crit</sub>, &#x002B; 3<italic>D</italic>. Hence, if the read length <italic>L</italic> is chosen above the noiseless requirement <italic>&#x2113;</italic><sub>crit</sub>, perfect assembly is robust to errors up to a threshold (roughly <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline1.gif"/></alternatives></inline-formula> erasures per read).</p>
<p>The impact of read errors on the information theoretic limits of genome assembly has also been studied in the setting of an i.i.d. genome model and asymptotically long genome length [<xref ref-type="bibr" rid="c7">7</xref>], building on an earlier work on error-free reads in the same setting [<xref ref-type="bibr" rid="c8">8</xref>]. The results are surprising: as long as the error rate is below a threshold (which can be as high as 19&#x0025; for substitution errors), noisy reads are as good as noiseless reads; i.e., the requirements for assembly in terms of read length and coverage depth are the same in both cases. While this result seems stronger than the result in the present paper, it is proved under the idealistic and unrealistic settings of i.i.d. genome statistics and i.i.d. errors. The present result, on the other hand, is more robust as it applies to arbitrary genome repeat statistics and error statistics.</p>
</sec>
<sec id="s2">
<label>II.</label><title>Problem Setting</title>
<p>In the DNA assembly problem, the goal is to reconstruct a sequence s &#x003D; (<italic>s</italic>[1], &#x2026;, <italic>s</italic>[<italic>G</italic>]) of length <italic>G</italic> with symbols from the alphabet &#x2211; &#x003D; {<italic>a</italic>, <italic>c</italic>, <italic>g</italic>, <italic>t</italic>}. In order to simplify the exposition, we assume a <italic>circular</italic> DNA model; thus, <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline2.gif"/></alternatives></inline-formula> is a periodic sequence with (minimum) period <italic>G</italic>. Our results hold in the non-circular case as well under minor modifications. We will let <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline3.gif"/></alternatives></inline-formula> be the substring of length <italic>&#x2113;</italic> starting at <italic>s</italic>[<italic>i</italic>]; i.e., <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline4.gif"/></alternatives></inline-formula>.</p>
<p>The sequencer provides a multiset of <italic>N reads</italic> &#x1D4E1; &#x003D; {r<sub>1</sub>, &#x2026;, r<sub><italic>N</italic></sub>} from s, each of length <italic>L</italic>. In the noiseless case, each read is a length-<italic>L</italic> substring of s with an unknown starting location. Our focus, however, will be on noisy read models, where each read may be corrupted by noise. The goal is to design an <italic>assembler</italic>, which takes the set of reads &#x1D4E1; and attempts to reconstruct the sequence s.</p>
<sec id="s2a">
<label>A.</label><title>The L-Spectrum Read Model</title>
<p>We will consider a &#x201C;dense-read&#x201D; model, in which all the reads in the <italic>L</italic>-spectrum of s are provided. More precisely, &#x1D4E1; will have exactly <italic>G</italic> reads, one from each possible starting position; i.e., &#x1D4E1; &#x003D; {r<sub>1</sub>, &#x2026;, r<sub><italic>G</italic></sub>}, where <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline5.gif"/></alternatives></inline-formula> for <italic>i</italic> &#x003D; 1, &#x2026;, <italic>G</italic>. We will refer to the error-free <italic>L</italic>-spectrum of s by &#x1D4E1;<sub><italic>L</italic>,0</sub>(s). Notice that the starting position <italic>i</italic> for each read r<sub><italic>i</italic></sub> is unknown to the assembler.</p>
<p>While such a read model was originally proposed in the context of <italic>sequencing by hybridization</italic> [<xref ref-type="bibr" rid="c4">4</xref>, <xref ref-type="bibr" rid="c5">5</xref>, <xref ref-type="bibr" rid="c9">9</xref>], our motivation for using it comes from next-generation sequencing technologies, where the high read throughput can provide large coverage depths at low costs, and a dense read regime is not unrealistic. This way, we can bypass the question of the necessary coverage depth for assembly, and instead focus on the interplay between read length and error rate in the context of assembly feasibility. Moreover, as shown in [<xref ref-type="bibr" rid="c3">3</xref>] for noiseless reads, the dense-read model provides valuable insights towards understanding the information-theoretic limits of reconstruction in the more general shotgun read model.</p>
<p>In the <italic>L</italic>-spectrum read model, since we have exactly <italic>G</italic> reads, an assembly of the reads &#x1D4E1;<sub><italic>L</italic>,0</sub>(s) &#x003D; {r<sub>1</sub>, &#x2026;, r<sub><italic>G</italic></sub>} can be thought of as a permutation <italic>&#x03C3;</italic> of the entries of (1, &#x2026;, <italic>G</italic>). We assume without loss of generality that the identity permutation <italic>&#x03C3;</italic><sub>0</sub> &#x003D; (1, &#x2026;, <italic>G</italic>) yields a correct assembly of s. Notice, however, that the index <italic>i</italic> of each read r<sub><italic>i</italic></sub> is unknown to the assembler. Notice also that in general, there may be multiple correct assemblies for a sequence s if <bold>r</bold><sub><italic>i</italic></sub> &#x003D; <bold>r</bold><sub><italic>j</italic></sub> for some <italic>i</italic> &#x2260; <italic>j</italic>.</p>
</sec>
<sec id="s2b">
<label>B.</label><title>Adversarial Erasure Model</title>
<p>As in the classical coding theory literature, we will study the problem of DNA assembly with noisy reads from the perspective of an <italic>adversarial</italic> noise model. Given that actual sequencing noise profiles are complex (non-i.i.d., asymmetric across bases) and technology-dependent, this approach avoids the need for a probabilistic noise model by instead focusing on a worst-case scenario. Moreover, under this model we can hope to obtain deterministic and non-asymptotic conditions for perfect assembly, which can be more easily analyzed in terms of real genome data.</p>
<p>Motivated by the fact that sequencing technologies usually provide a quality score for each base that is read (which could be thresholded into &#x201C;good&#x201D; and &#x201D;bad&#x201D; bases), and in order to simplify the problem, we will consider an <italic>erasure</italic> model. The reads in &#x1D4E1; will be length-<italic>L</italic> sequences from the alphabet &#x03A3;&#x2032; &#x003D; {<italic>a</italic>, <italic>c</italic>, <italic>g</italic>, <italic>t</italic>, <italic>&#x03B5;</italic>}, where <italic>&#x03B5;</italic> corresponds to an erasure. Thus, a read starting at position <italic>i</italic> from s can be written as r<sub><italic>i</italic></sub> &#x003D; (<italic>r</italic><sub><italic>i</italic></sub>[0], &#x2026;, <italic>r</italic><sub><italic>i</italic></sub>[<italic>L</italic> &#x2013; 1]), where either <italic>r</italic><sub><italic>i</italic></sub>[<italic>j</italic>] &#x003D; <italic>s</italic>[<italic>i</italic> &#x002B; <italic>j</italic>] or <italic>r</italic><sub><italic>i</italic></sub>[<italic>j</italic>] &#x003D; <italic>&#x03B5;</italic>, for 1 &#x2264; <italic>i</italic> &#x2264; <italic>G</italic> and 0 &#x2264; <italic>j</italic> &#x2264; <italic>L</italic> &#x2013; 1.</p>
<p>For a fixed parameter <italic>D</italic>, the adversarial erasure model will be constrained by a maximum error rate of <italic>D</italic>/<italic>L</italic> within each read, and for each base. Since in our read model each base <italic>s</italic>[<italic>i</italic>] is read <italic>L</italic> times (<italic>r</italic><sub><italic>i</italic> &#x2013; (<italic>L</italic> &#x2013; 1)</sub>[<italic>L</italic> &#x2013; 1], <italic>r</italic><sub><italic>i</italic> &#x2013; (<italic>L</italic> &#x2013; 2)</sub>[<italic>L</italic> &#x2013; 2], &#x2026;, <italic>r</italic><sub><italic>i</italic></sub>[0]), these constraints can be written as follows:</p>
<list list-type="alpha-lower">
<list-item><p>There are at most <italic>D</italic> erasures per read.</p></list-item>
<list-item><p>Each base <italic>s</italic>[<italic>i</italic>] is erased at most <italic>D</italic> times across all reads.</p></list-item></list>
<p>We will use &#x1D4E1;<sub><italic>L</italic>,<italic>D</italic></sub>(s) to refer to the <italic>L</italic>-spectrum of s, &#x1D4E1;<sub><italic>L</italic>,0</sub>(s), after being corrupted by erasures satisfying (a) and (b).</p>
<p>In the context of an adversarial noise model with deterministic constraints, it makes sense to restrict our attention to potential sequences &#x015D; that are <italic>consistent</italic> with the reads &#x1D4E1;<sub><italic>L</italic>,<italic>D</italic></sub>(s). A sequence &#x015D; is said to be consistent with &#x1D4E1;<sub><italic>L</italic>,<italic>D</italic></sub>(s) if it could have generated the set of reads &#x1D4E1;<sub><italic>L</italic>, <italic>D</italic></sub>(s) according to the erasure model in (a) and (b). By extension, we will say that an assembly <italic>&#x03C3;</italic> of &#x1D4E1;<sub><italic>L</italic>,<italic>D</italic></sub>(s) is consistent if there exists a sequence &#x015D;, consistent with &#x1D4E1;<sub><italic>L</italic>,<italic>D</italic></sub>(s), that could have generated the reads in &#x1D4E1;<sub><italic>L</italic>,<italic>D</italic></sub>(s) according to the positions determined by <italic>&#x03C3;</italic>. As illustrated in <xref ref-type="fig" rid="fig3">Fig. 3</xref>, we notice that (b) guarantees that a consistent assembly <italic>&#x03C3;</italic> defines, up to cyclic shifts, a unique consistent sequence in &#x03A3;<sup><italic>G</italic></sup>, which we will refer to as &#x015D;(<italic>&#x03C3;</italic>).</p>
<fig id="fig3" position="float" fig-type="figure">
<label>Fig. 3.</label>
<caption><p>Part of a consistent assembly for <italic>L</italic> &#x003D; 5 and <italic>D</italic> &#x003D; 2. Notice that there can be at most <italic>D</italic> erasures per read and per &#x201C;column&#x201D; of the assembly<italic>&#x03C3;</italic>. Moreover, all non-erased bases in a column must agree.</p></caption>
<graphic xlink:href="014399_fig3.tif"/></fig>
<p>The fundamental feasibility question corresponds to asking which values of <italic>L</italic> allow unambiguous reconstruction. Formally, it corresponds to the following algorithm-independent question.</p>
<statement id="stat1">
<label>Question 1.</label>
<p><italic>Consider a fixed circular sequence</italic> s &#x2208; &#x03A3;<sup><italic>G</italic></sup>. <italic>What values of <italic>L</italic> guarantee that, for an arbitrary set of erased reads &#x1D4E1;<sub><italic>L</italic>,<italic>D</italic></sub></italic>(<italic>s</italic>), <italic>s is the unique sequence consistent with &#x1D4E1;<sub><italic>L</italic>,<italic>D</italic></sub></italic>(<italic>s</italic>)?</p></statement>
</sec>
</sec>
<sec id="s3">
<label>III.</label><title>Assembly in the Noiseless Case</title>
<p>The assembly problem in <xref ref-type="statement" rid="stat1">Question 1</xref> was first studied in [<xref ref-type="bibr" rid="c4">4</xref>] in the noiseless setting <italic>D</italic> &#x003D; 0. Notice that when <italic>L</italic> &#x003D; 1, &#x1D4E1;<sub>1,0</sub>(s) is simply the multi-set {<italic>s</italic>[<xref ref-type="bibr" rid="c1">1</xref>], &#x2026;, <italic>s</italic>[<italic>G</italic>]} and any permutation <italic>&#x03C3;</italic> of (1, &#x2026;, <italic>G</italic>) is a consistent assembly. Hence, s cannot be reconstructed unambiguously, unless all of its symbols are the same. On the other hand, when <italic>L</italic> &#x003D; <italic>G</italic>, there is a unique assembly of &#x1D4E1;<sub><italic>G</italic>,0</sub>(s) &#x003D; {s}, and s can always be reconstructed unambiguously. <xref ref-type="statement" rid="stat1">Question 1</xref> is thus equivalent to asking for the threshold <italic>&#x2113;</italic><sub>th</sub> for which s can be reconstructed if and only if <italic>L</italic> &#x003E; &#x2113;<sub>th</sub>. In [<xref ref-type="bibr" rid="c4">4</xref>], this threshold is established as a function of the <italic>repeat</italic> structure of the sequence s, as we explain next.</p>
<p>A <italic>repeat</italic> of length <italic>&#x2113;</italic> in s is a subsequence appearing twice at some positions <italic>t</italic><sub>1</sub> and <italic>t</italic><sub>2</sub> (so <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline6.gif"/></alternatives></inline-formula> and <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline7.gif"/></alternatives></inline-formula>) that is maximal; i.e., <italic>s</italic>[<italic>t</italic><sub>1</sub> &#x2013; 1] &#x2260; <italic>s</italic>[<italic>t</italic><sub>2</sub> &#x2013; 1] and <italic>s</italic>[<italic>t</italic><sub>1</sub> &#x002B; <italic>&#x2113;</italic>] &#x2260; <italic>s</italic>[<italic>t</italic><sub>2</sub> &#x002B; <italic>&#x2113;</italic>]. Two pairs of repeats <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline8.gif"/></alternatives></inline-formula> and <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline9.gif"/></alternatives></inline-formula> are <italic>interleaved</italic> if <italic>a</italic><sub>1</sub> &#x003C; <italic>b</italic><sub>1</sub> &#x2264; <italic>a</italic><sub>2</sub> &#x003C; <italic>b</italic><sub>2</sub>. Due to the circular DNA model, since a subsequence <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline10.gif"/></alternatives></inline-formula> can also be written as <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline11.gif"/></alternatives></inline-formula> for any integer <italic>m</italic>, we additionally require that <italic>b</italic><sub>2</sub> &#x2013; <italic>a</italic><sub>1</sub> &#x003C; <italic>G</italic>. The length of a pair of interleaved repeats <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline12.gif"/></alternatives></inline-formula> and <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline13.gif"/></alternatives></inline-formula> is defined to be min(<italic>&#x2113;</italic>, <italic>k</italic>). We let <italic>&#x2113;</italic><sub>inter</sub>(s) be the length of the longest pair of interleaved repeats in s and set <italic>&#x2113;</italic><sub>crit</sub>(s) &#x003D; <italic>&#x2113;</italic><sub>inter</sub>(s) &#x002B; 1. The results from [<xref ref-type="bibr" rid="c4">4</xref>, <xref ref-type="bibr" rid="c5">5</xref>] imply the following:</p>
<statement id="stat2">
<label>Theorem 1.</label>
<p><italic>If L</italic> &#x003E; <italic>&#x2113;</italic><sub>crit</sub>(s), <italic>then</italic> s <italic>is the unique sequence that is consistent with</italic> &#x1D4E1;<sub>L,0</sub>(s). <italic>Conversely, if L</italic> &#x2264; <italic>&#x2113;</italic><sub>crit</sub>(s), <italic>there exists a sequence s&#x2032;</italic> &#x2260; <italic>s that is also consistent with</italic> &#x1D4E1;<sub><italic>L</italic>,0</sub>(s).</p>
</statement>
<p>In other words, <xref ref-type="statement" rid="stat2">Theorem 1</xref> characterizes the threshold on <italic>L</italic> that fully answers <xref ref-type="statement" rid="stat1">Question 1</xref>. We point out that, in the previous literature [<xref ref-type="bibr" rid="c3">3</xref>, <xref ref-type="bibr" rid="c4">4</xref>], <italic>&#x2113;</italic><sub>crit</sub> was defined in terms of the length of pairs of interleaved repeats (defined in a more restrictive way) and the length of <italic>triple repeats</italic>. However, one can verify that by considering the more general definition of interleaved repeats above, triple repeats are included as a special case.</p>
<p>Notice that, while <xref ref-type="statement" rid="stat2">Theorem 1</xref> characterizes the minimum <italic>L</italic> that guarantees perfect reconstruction, <italic>&#x2113;</italic><sub>crit</sub>(s) is a function of the ground truth s, and is not known a priori. However, the following corollary of <xref ref-type="statement" rid="stat2">Theorem 1</xref> readily follows:</p>
<statement id="stat3">
<label>Corollary 1.</label>
<p><italic>If a sequence</italic> &#x015D; <italic>is consistent with &#x1D4E1;</italic><sub><italic>L</italic>,0</sub>(s) <italic>and L</italic> &#x003E; <italic>&#x2113;</italic><sub>crit</sub>(&#x015D;), <italic>then</italic> &#x015D; &#x003D; s.</p>
</statement>
<p>Since <italic>&#x2113;</italic><sub>crit</sub>(&#x015D;) can be computed from the assembled sequence &#x015D;, this result means that <italic>L</italic> &#x003E; <italic>&#x2113;</italic><sub>crit</sub>(&#x015D;) provides a certificate that &#x015D; &#x003D; s, even without previous knowledge of <italic>&#x2113;</italic><sub>crit</sub>(s).</p>
</sec>
<sec id="s4">
<label>IV.</label><title>Main Results</title>
<p>In the previous section, we described how <xref ref-type="statement" rid="stat2">Theorem 1</xref> fully characterizes when assembly is possible given the noiseless Lspectrum. In this section, we seek a similar characterization in the case where reads are noisy.</p>
<p>Notice that for the erasure setting described in <xref ref-type="sec" rid="s2">Section II</xref>, one possible erasure pattern is to have the last <italic>D</italic> bases from each read erased, which effectively results in noiseless reads of length <italic>L</italic> &#x2013; <italic>D</italic>. Therefore, the converse part of <xref ref-type="statement" rid="stat2">Theorem 1</xref> implies that, if <italic>L</italic> &#x2264; <italic>&#x2113;</italic><sub>crit</sub>(s) &#x002B; <italic>D</italic>, there is a read set &#x1D4E1;<sub><italic>L</italic>,<italic>D</italic></sub>(s) and a sequence &#x015D; &#x2260; s that is consistent with &#x1D4E1;<sub><italic>L</italic>,<italic>D</italic></sub>(s). But how much larger than <italic>&#x2113;</italic><sub>crit</sub>(s) &#x002B; <italic>D</italic> does the read length <italic>L</italic> have to be in order to guarantee unambiguous correct reconstruction? In other words, how do erasures degrade the fundamental limit characterized by <xref ref-type="statement" rid="stat2">Theorem 1</xref>?</p>
<p>Our main result is the introduction of a new sequencedependent quantity, <italic>&#x2113;</italic>&#x0303;<sub>crit</sub>(<italic>D</italic>, s), such that, if <italic>L</italic> &#x003E; <italic>&#x2113;</italic>&#x0303;<sub>crit</sub>(s, <italic>D</italic>), s is the unique sequence consistent with &#x1D4E1;<sub><italic>L</italic>,<italic>D</italic></sub>(s). In general, <italic>&#x2113;</italic><sub>crit</sub>(s) &#x002B; <italic>D</italic> &#x003C; <italic>&#x2113;</italic>&#x0303;<sub>crit</sub>(s, <italic>D</italic>) for <italic>D</italic> &#x003E; 0, and one can construct an arbitrary sequence s &#x2208; &#x03A3;<sup><italic>G</italic></sup> for which the gap between the two quantities is significant. However, by computing <italic>&#x2113;</italic><sub>crit</sub> &#x002B; <italic>D</italic> and <italic>&#x2113;</italic>&#x0303;<sub>crit</sub> for actual genomes, we verify that they are often close, as shown in <xref ref-type="table" rid="tbl1">Table I</xref>.</p>
<table-wrap id="tbl1" orientation="portrait" position="float">
<label>Table I.</label>
<caption><p>Computed <italic>&#x2113;</italic>&#x0303;<sub>crit</sub>(s, <italic>D</italic>) for <italic>D</italic>/<italic>&#x2113;</italic><sub>crit</sub> &#x2248; 15&#x0025;</p></caption>
<graphic xlink:href="014399_tbl1.tif"/></table-wrap>
<p>Rather than being defined in terms of exact repeats, as is the case of <italic>&#x2113;</italic><sub>crit</sub>(s), <italic>&#x2113;</italic>&#x0303;<sub>crit</sub>(s) depends more generally on approximate repeats. For a set of segments &#x1D4E2; of a given length <italic>&#x2113;</italic>; i.e., &#x1D4E2; &#x2282; &#x03A3;<sup><italic>&#x2113;</italic></sup>, we will first define the radius of &#x1D4E2; to be
<disp-formula id="eqn1"><alternatives><graphic xlink:href="014399_eqn1.gif"/></alternatives></disp-formula>
where <italic>d</italic><sub><italic>H</italic></sub>(y, x) is the Hamming distance between y and x. We will say that the segments in &#x1D4E2; are <italic>d</italic>-approximate copies if <italic>&#x03C1;</italic>(&#x1D4E2;) &#x2264; <italic>d</italic>. Intuitively, a sequence s that contains a large set &#x1D4E2; of length-<italic>&#x2113;</italic> segments with a small radius <italic>&#x03C1;</italic>(&#x1D4E2;) has more ambiguity in terms of assembly. To capture that, we will let <italic>M</italic>(<italic>d</italic>, <italic>&#x2113;</italic>) correspond to the maximum number of <italic>d</italic>-approximate length-<italic>&#x2113;</italic> segments in s; i.e.,
<disp-formula id="eqn2"><alternatives><graphic xlink:href="014399_eqn2.gif"/></alternatives></disp-formula></p>
<p>Notice that <italic>M</italic><sub>s</sub>(<italic>d</italic>, <italic>&#x2113;</italic>) is monotonically decreasing in <italic>&#x2113;</italic>. We let
<disp-formula id="eqn3"><alternatives><graphic xlink:href="014399_eqn3.gif"/></alternatives></disp-formula></p>
<p>Notice that <italic>&#x2113;</italic>&#x0303;<sub>crit</sub>(s, <italic>D</italic>) &#x2265; <italic>&#x2113;</italic>&#x0303;<sub>crit</sub>(s, 0) &#x003D; <italic>&#x2113;</italic><sub>crit</sub>(s). Our main result is the following.</p>
<statement id="stat4">
<label>Theorem 2.</label>
<p><italic>If L</italic> &#x003E; <italic>&#x2113;</italic>&#x0303;<sub>crit</sub>(s, <italic>D</italic>), <italic>then</italic> s <italic>is the unique sequence that is consistent with &#x1D4E1;</italic><sub><italic>L</italic>,<italic>D</italic></sub>(s).</p></statement>
<p>The main tool used to prove Theorem 2 is a result about spectrum error correction. More precisely, we show that from a noisy version of the <italic>L</italic>-spectrum of s &#x1D4E1;<sub><italic>L</italic>,<italic>D</italic></sub>(s), it is possible to obtain &#x1D4E1;<sub><italic>L&#x2032;</italic>,0(s)</sub>, for some effective read length <italic>L&#x2032;</italic> &#x003C; <italic>L</italic>. This result and the proof of Theorem 2 are presented in <xref ref-type="sec" rid="s5">Section V</xref>.</p>
<p>As in the noiseless case, we point out that <italic>&#x2113;</italic>&#x0303;<sub>crit</sub>(s, <italic>D</italic>) cannot be computed a priori, since it is a function of the ground truth sequence s. However, Theorem 2 can in fact be used to obtain a certif1cate result analogous to Corollary 1, allowing one to certify whether an assembly &#x015D; is correct, even without prior knowledge of <italic>&#x2113;</italic>&#x0303;<sub>crit</sub>(s) and <italic>M</italic><sub>s</sub>(<italic>D</italic>, &#x00B7;).</p>
<statement id="stat5">
<label>Corollary 2.</label>
<p><italic>If a sequence</italic> &#x015D; <italic>is consistent with</italic> &#x1D4E1;<sub><italic>L</italic>,<italic>D</italic></sub>(s) <italic>and L</italic> &#x003E; <italic>&#x2113;</italic>&#x0303;<sub>crit</sub>(&#x015D;), <italic>then</italic> &#x015D; &#x003D; s.</p>
<p><italic>Proof:</italic> If &#x015D; is consistent with &#x1D4E1;<sub><italic>L</italic>,<italic>D</italic></sub>(s), by the definition of consistency, &#x1D4E1;<sub><italic>L</italic>,<italic>D</italic></sub>(s) can be viewed as a set of reads &#x1D4E1;<sub><italic>L</italic>,<italic>D</italic></sub>(&#x015D;) from &#x015D;, with an erasure pattern satisfying (a) and (b). But from Theorem 2, if <italic>L</italic> &#x003E; <italic>&#x2113;</italic>&#x0303;<sub>crit</sub>(&#x015D;), &#x015D; is the unique sequence that is consistent with &#x1D4E1;<sub><italic>L</italic>,<italic>D</italic></sub>(&#x015D;) &#x003D; &#x1D4E1;<sub><italic>L</italic>,<italic>D</italic></sub>(s). Since s must also be consistent with &#x1D4E1;<sub><italic>L</italic>,<italic>D</italic></sub>(&#x015D;), we must have &#x015D; &#x003D; s.</p>
</statement>
<p>In <xref ref-type="table" rid="tbl1">Table I</xref>, we show the value of <italic>&#x2113;</italic>&#x0303;<sub>crit</sub>(s, <italic>D</italic>) computed for several real genomes. Computing <italic>&#x2113;</italic>&#x0303;<sub>crit</sub>(s, <italic>D</italic>) is generally impractical from a computational standpoint, so the values in <xref ref-type="table" rid="tbl1">Table I</xref> are based on heuristics implemented by a sequence alignment tool called Nucmer [<xref ref-type="bibr" rid="c10">10</xref>]. We choose the value of <italic>D</italic> such that <italic>D</italic>/<italic>&#x2113;</italic><sub>crit</sub> &#x2248; 15&#x0025;. We point out that the first two genomes, <italic>R. sphaeroides</italic> and <italic>S. aureus</italic> are from the GAGE dataset [<xref ref-type="bibr" rid="c6">6</xref>], which is used as a benchmark for assemblers. Notice that, with the exception of <italic>E. coli 536</italic>, in all cases <italic>&#x2113;</italic>&#x0303;<sub>crit</sub>(s, <italic>D</italic>) &#x003D; <italic>&#x2113;</italic><sub>crit</sub>(s) &#x002B; <italic>mD</italic>, for <italic>m</italic> &#x2208; {2, 3, 4}. This occurs because, for the genomes considered, <italic>&#x2113;</italic><sub>crit</sub> (s) is already long enough so that there aren&#x2019;t many approximate repeats of that length.</p>
<p>While the results in this section were presented for an erasure model, they can be extended to a substitution error model. In fact, if instead of <italic>D</italic> erasures per read and per base, we have <italic>D</italic>/2 substitution errors, the proofs of Theorems 2 and 3 can be modified accordingly, and the statements still hold. We will restrict the discussion to the erasure case for simplicity.</p>
</sec>
<sec id="s5">
<label>V.</label><title>Spectrum Error Correction</title>
<p>The main result we use to prove Theorem 2 is a statement about when it is possible to take a noisy <italic>L</italic>-spectrum of s and unambiguously construct its noiseless <italic>L&#x2032;</italic>-spectrum, for <italic>L&#x2032;</italic> &#x003C; <italic>L</italic>.</p>
<statement id="stat6">
<label>Theorem 3.</label>
<p><italic>Suppose that, for some k, we have</italic>
<disp-formula id="eqn4"><alternatives><graphic xlink:href="014399_eqn4.gif"/></alternatives></disp-formula></p>
<p><italic>Then, for any sequence</italic> &#x015D; <italic>that is consistent with &#x1D4E1;</italic><sub><italic>L</italic>,<italic>D</italic></sub>(s), &#x1D4E1;<sub><italic>k</italic>&#x002B;1,0</sub>(&#x015D;) &#x003D; &#x1D4E1;<sub><italic>k</italic>&#x002B;1,0</sub>(s).</p>
</statement>
<p>Theorem 3 says that, by finding a consistent assembly of &#x1D4E1;<sub><italic>L</italic>,<italic>D</italic></sub>(s), we can obtain the (noiseless) (<italic>k</italic> &#x002B; 1)-spectrum of s, as long as <italic>k</italic> satisfies (4). Therefore, when <italic>L</italic> &#x003E; <italic>&#x2113;</italic>&#x0303;<sub>crit</sub>(s, <italic>D</italic>), if we let <italic>k</italic><sup>&#x22C6;</sup> be the minimizer in (3), we have that <italic>L</italic> &#x003E; <italic>k</italic><sup>&#x22C6;</sup> &#x002B; <italic>D</italic> &#x00B7; <italic>M</italic><sub>s</sub>(<italic>D</italic>, <italic>k</italic><sup>&#x22C6;</sup> &#x002B; 1) and, by Theorem 3, any &#x015D; that is consistent with &#x1D4E1;<sub><italic>L</italic>,<italic>D</italic></sub>(s) has the same (<italic>k</italic><sup>&#x22C6;</sup> &#x002B; 1)-spectrum &#x1D4E1;<sub><italic>k</italic><sup>&#x22C6;</sup> &#x002B; 1, 0</sub>(s). But since, <italic>k</italic><sup>&#x22C6;</sup> &#x002B; 1 &#x003E; <italic>&#x2113;</italic><sub>crit</sub>(s), <xref ref-type="statement" rid="stat2">Theorem 1</xref> implies that there is only one sequence that is consistent with &#x1D4E1;<sub><italic>k</italic><sup>&#x22C6;</sup> &#x002B; 1, 0</sub>(s), and we must have &#x015D; &#x003D; s. This proves Theorem 2.</p>
<p>Next, we turn to the proof of Theorem 3. Suppose that we pick some <italic>k</italic> satisfying (4) and that <italic>&#x03C3;</italic> is a consistent assembly for the set of reads &#x1D4E1;<sub><italic>L</italic>,<italic>D</italic></sub>(s) with assembled sequence &#x015D; &#x003D; &#x015D;(<italic>&#x03C3;</italic>). The main idea of the proof is to show that (<italic>k</italic> &#x002B; 1)-blocks in s and &#x015D; are in one-to-one correspondence; i.e., <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline15.gif"/></alternatives></inline-formula> for a bijective mapping <italic>&#x03C4;</italic>:{1, &#x2026;, <italic>G</italic>} &#x2192; {1, &#x2026;, <italic>G</italic>}, which implies &#x1D4E1;<sub><italic>k</italic>&#x002B;1,0</sub>(s) &#x003D; &#x1D4E1;<sub><italic>k</italic>&#x002B;1,0</sub>(&#x015D;).</p>
<p>In order to show the existence of this bijection <italic>&#x03C4;</italic>, we consider a bipartite graph (<italic>V</italic><sub>s</sub>, <italic>V</italic><sub>&#x015D;</sub>, <italic>E</italic><sub><italic>k</italic>&#x002B;1</sub>), where <italic>V</italic><sub>s</sub> &#x003D; <italic>V</italic><sub>&#x015D;</sub> &#x003D; {1, &#x2026;, <italic>G</italic>} and <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline16.gif"/></alternatives></inline-formula>, as illustrated in <xref ref-type="fig" rid="fig4">Fig. 4</xref>. The existence of the bijective mapping <italic>&#x03C4;</italic> is equivalent to the existence of a perfect matching in (<italic>V</italic><sub>s</sub>, <italic>V</italic><sub>&#x015D;</sub>, <italic>E</italic>). Hence, Theorem 3 is equivalent to the following:
<statement id="stat7">
<label>Claim 1.</label>
<p><italic>There exists a perfect matching in</italic> (<italic>V</italic><sub>s</sub>, <italic>V</italic><sub>&#x015D;</sub>, <italic>E</italic>).</p></statement></p>
<fig id="fig4" position="float" fig-type="figure">
<label>Fig. 4.</label>
<caption><p>We place an edge (<italic>u</italic>, <italic>&#x03C5;</italic>) in (<italic>V</italic><sub>s</sub>, <italic>V</italic><sub>&#x015D;</sub>, <italic>E</italic>) if <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline14.gif"/></alternatives></inline-formula>. In this example, (<italic>&#x03C4;</italic><sub>1</sub>, <italic>t</italic><sub>1</sub>), (<italic>&#x03C4;</italic><sub>2</sub>, <italic>t</italic><sub>2</sub>) and (<italic>&#x03C4;</italic><sub>1</sub>, <italic>t</italic><sub>3</sub>) are some of the edges in (<italic>V</italic><sub>s</sub>, <italic>V</italic><sub>&#x015D;</sub>, <italic>E</italic>).</p></caption>
<graphic xlink:href="014399_fig4.tif"/></fig>
<p>For a set of nodes <italic>U</italic> &#x2282; <italic>V</italic><sub>&#x015D;</sub>, we let <italic>&#x03B4;</italic>(<italic>U</italic>) &#x003D; {<italic>&#x03C5;</italic> &#x2208; <italic>V</italic><sub>s</sub> : (<italic>&#x03C5;</italic>, <italic>u</italic>) &#x2208; <italic>E</italic> for <italic>u</italic> &#x2208; <italic>U</italic>} be the set of neighbors of <italic>U</italic>. We will show that, for any <italic>U</italic> &#x2282; <italic>V</italic><sub>&#x015D;</sub>, |<italic>&#x03B4;</italic>(<italic>U</italic>)| &#x2265; |<italic>U</italic>|, and by Hall&#x2019;s marriage theorem, Claim 1 will follow. We will first state the following lemma, which establishes |<italic>&#x03B4;</italic>(<italic>U</italic>)| &#x2265; |<italic>U</italic>| for the special case of sets <italic>U</italic> of the form <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline17.gif"/></alternatives></inline-formula> for some <italic>x</italic> &#x2208; &#x03A3;<sup><italic>k</italic> &#x002B; 1</sup>.</p>
<statement id="stat8">
<label>Lemma 1.</label>
<p><italic>For the bipartite graph</italic> (<italic>V</italic><sub>s</sub>, <italic>V</italic><sub>&#x015D;</sub>, <italic>E</italic>), |<italic>&#x03B4;</italic>(<italic>U</italic><sub>x</sub>)| &#x2265; |<italic>U</italic><sub>x</sub>|, for any <italic>x</italic> &#x2208; &#x03A3;<sup><italic>k</italic>&#x002B;1</sup>.</p></statement>
<p>The proof of Lemma 1 is at the end of this section. Now consider a general set <italic>U</italic> &#x2208; <italic>V</italic><sub>&#x015D;</sub>. Let <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline18.gif"/></alternatives></inline-formula>. Since two nodes <italic>u</italic>, <italic>u&#x2032;</italic> &#x2208; <italic>U</italic> with <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline19.gif"/></alternatives></inline-formula> cannot be connected to the same node <italic>v</italic> &#x2208; <italic>V</italic><sub>s</sub>, we have
<disp-formula><alternatives><graphic xlink:href="014399_ueqn2.gif"/></alternatives></disp-formula>
where the first inequality follows from Lemma 1. By applying Hall&#x2019;s theorem, Claim 1 follows, implying that, &#x1D4E1;<sub><italic>k</italic>&#x002B;1,0</sub>(s) &#x003D; &#x1D4E1;<sub><italic>k</italic>&#x002B;1,0</sub>(&#x015D;). Therefore, to conclude the proof of Theorem 3, we just need to prove Lemma 1.</p>
<statement id="stat9">
<label>Proof of Lemma 1:</label>
<p>Let <italic>U</italic><sub>x</sub> &#x003D; {<italic>t</italic><sub>1</sub>, &#x2026;, <italic>t</italic><sub><italic>q</italic></sub>} &#x2282; <italic>V</italic> <sub>&#x015D;</sub>, where <italic>t</italic><sub>1</sub>, &#x2026;, <italic>t</italic><sub><italic>q</italic></sub> are distinct and <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline20.gif"/></alternatives></inline-formula>. Consider one such block <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline21.gif"/></alternatives></inline-formula>, for <italic>t</italic> &#x2208; {<italic>t</italic><sub>1</sub>, &#x2026;, <italic>t</italic><sub><italic>q</italic></sub>}. There are <italic>L</italic> &#x2013; <italic>k</italic> reads that cover <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline22.gif"/></alternatives></inline-formula> in &#x015D;, as illustrated in <xref ref-type="fig" rid="fig5">Fig. 5</xref>. These are the reads given by r<sub><italic>&#x03C3;</italic>&#x2013;1(<italic>t</italic> &#x2013; <italic>n</italic>)</sub>, for <italic>n</italic> &#x003D; 0, 1, &#x2026;, <italic>L</italic> &#x2013; <italic>k</italic> &#x2013; 1. Notice that read r<sub><italic>&#x03C3;</italic>&#x2013;1(<italic>t</italic> &#x2013; <italic>n</italic>)</sub> was originally obtained from the segment <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline23.gif"/></alternatives></inline-formula> from the true sequence s. The consistency requirement on <italic>&#x03C3;</italic> thus implies that <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline24.gif"/></alternatives></inline-formula>. Moreover, if we just focus on the (<italic>k</italic> &#x002B; 1)-block corresponding to <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline25.gif"/></alternatives></inline-formula>, we have <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline26.gif"/></alternatives></inline-formula>, which holds for each <italic>t</italic> &#x2208; {<italic>t</italic><sub>1</sub>, &#x2026;, <italic>t</italic><sub><italic>q</italic></sub>} and <italic>n</italic> &#x003D; 0, &#x2026;, <italic>L</italic> &#x2013; <italic>k</italic> &#x2013; 1.</p></statement>
<fig id="fig5" position="float" fig-type="figure">
<label>Fig. 5.</label>
<caption><p>For an arbitrary length-(<italic>k</italic> &#x002B; 1) block <italic>B</italic> in <italic>&#x015D;</italic>, the <italic>L</italic> &#x2013; <italic>k</italic> reads that completely cover <italic>B</italic> according to the assembly are shaded (in this example, <italic>L</italic> &#x003D; 6 and <italic>k</italic> &#x003D; 2). By mapping these <italic>L</italic> &#x2013; <italic>k</italic> reads back to s, we find the corresponding (<italic>k</italic> &#x002B; 1)-blocks in s given by <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline27.gif"/></alternatives></inline-formula> for <italic>j</italic> &#x003D; 0, 1, 2, 3. Notice that, in this example, <italic>&#x03C3;</italic><sup>&#x2212;1</sup>(<italic>t</italic>) &#x003D; <italic>&#x03C3;</italic><sup>&#x2212;1</sup>(<italic>t</italic> &#x2013; 2) &#x002B; 2, because reads r<sub><italic>&#x03C3;</italic><sup>&#x2212;1</sup></sub>(<italic>t</italic>) and r<sub><italic>&#x03C3;</italic><sup>&#x2212;1</sup>(<italic>t</italic> &#x2013; 2) &#x002B; 2</sub> are aligned to each other in the same way in s and &#x015D;.</p></caption>
<graphic xlink:href="014399_fig5.tif"/></fig>
<p>If we now consider the set of all such (<italic>k</italic> &#x002B; 1)-blocks in s
<disp-formula id="eqn5"><alternatives><graphic xlink:href="014399_eqn5.gif"/></alternatives></disp-formula>
since <italic>d</italic><sub><italic>H</italic></sub>(y, x) &#x2264; <italic>D</italic> for each y &#x2208; &#x1D4E2;, we have that <italic>&#x03C1;</italic>(&#x1D4E2;) &#x2264; <italic>D</italic>.</p>
<p>Hence, if we let
<disp-formula><alternatives><graphic xlink:href="014399_ueqn3.gif"/></alternatives></disp-formula>
be the starting positions of these blocks in s, &#x1D4E3; must satisfy |&#x1D4E3;| &#x2264; <italic>M</italic><sub>s</sub>(<italic>D</italic>, <italic>k</italic> &#x002B; 1). Now consider the set of (<italic>n</italic>, <italic>i</italic>) pairs
<disp-formula><alternatives><graphic xlink:href="014399_ueqn4.gif"/></alternatives></disp-formula></p>
<p>We will define a partition on &#x1D4D1; according to the value of <italic>&#x03C3;</italic><sup>&#x2212;1</sup>(<italic>t</italic><sub><italic>i</italic></sub> &#x2013; <italic>n</italic>) &#x002B; <italic>n</italic>. More precisely, we will let
<disp-formula><alternatives><graphic xlink:href="014399_ueqn5.gif"/></alternatives></disp-formula>
for <italic>&#x03C4;</italic> &#x2208; &#x1D4E3;. It is clear that {&#x1D4D1;<sub><italic>&#x03C4;</italic></sub>}<sub><italic>&#x03C4;</italic> &#x2208; &#x1D4E3;</sub> is a partition of &#x1D4D1;. We claim that there exist distinct <italic>&#x03C4;</italic><sub>1</sub>, &#x2026;, <italic>&#x03C4;</italic><sub><italic>q</italic></sub> &#x2208; &#x1D4E3; such that |&#x1D4D1;<sub><italic>&#x03C4;</italic><sub><italic>j</italic></sub></sub>| &#x2265; <italic>D</italic> &#x002B; 1, for <italic>j</italic> &#x003D; 1, &#x2026;, <italic>q</italic>. Suppose by contradiction that this is not the case, and we have at most <italic>q</italic> &#x2013; 1 parts &#x1D4D1;<sub><italic>&#x03C4;</italic></sub> with |&#x1D4D1;<sub><italic>&#x03C4;</italic></sub>| &#x2265; <italic>D</italic> &#x002B; 1. Notice that, since <italic>&#x03C3;</italic> : (1, &#x2026;, <italic>G</italic>) &#x2192; (1, &#x2026;, <italic>G</italic>) is one-to-one, <italic>&#x03C3;</italic><sup>&#x2212;1</sup>(<italic>t</italic><sub><italic>i</italic></sub> &#x2013; <italic>n</italic>) &#x002B; <italic>n</italic> &#x2260; <italic>&#x03C3;</italic><sup>&#x2212;1</sup>(<italic>t</italic><sub><italic>j</italic></sub> &#x2013; <italic>n</italic>) &#x002B; <italic>n</italic> if <italic>t</italic><sub><italic>i</italic></sub> &#x2260; <italic>t</italic><sub><italic>j</italic></sub>, and, for any <italic>&#x03C4;</italic>, we must have |&#x1D4D1;<sub><italic>&#x03C4;</italic></sub>| &#x2264; <italic>L</italic> &#x2013; <italic>k</italic>. Therefore, since (4) implies <italic>L</italic> &#x2013; <italic>k</italic> &#x2013; 1 &#x2265; <italic>D</italic> &#x00B7; <italic>M</italic><sub>s</sub>(<italic>D</italic>, <italic>k</italic> &#x002B; 1),
<disp-formula><alternatives><graphic xlink:href="014399_ueqn6.gif"/></alternatives></disp-formula></p>
<p>But since &#x03A3;<sub><italic>&#x03C4;</italic> &#x2208; &#x1D4E3;</sub> |&#x1D4D1;<sub><italic>&#x03C4;</italic></sub>| &#x003D; |&#x1D4D1;<sub><italic>&#x03C4;</italic></sub>| &#x003D; <italic>q</italic>(<italic>L</italic> &#x2013; <italic>k</italic>), we have a contradiction. Now consider the segments <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline28.gif"/></alternatives></inline-formula> with |&#x1D4D1;<sub><italic>&#x03C4;</italic><sub><italic>j</italic></sub></sub>| &#x2265; <italic>D</italic> &#x002B; 1, for <italic>j</italic> &#x003D; 1, &#x2026;, <italic>q</italic>. Since <italic>&#x03C4;</italic><sub>1</sub>, &#x2026;, <italic>&#x03C4;</italic><sub><italic>q</italic></sub> are all distinct, these segments start at different points in s. Moreover, since |&#x1D4D1;<sub><italic>&#x03C4;</italic><sub><italic>j</italic></sub></sub>| &#x2265; <italic>D</italic> &#x002B; 1, each <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline29.gif"/></alternatives></inline-formula> is covered by <italic>D</italic> &#x002B; 1 reads from the reads that cover <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline30.gif"/></alternatives></inline-formula> <italic>i</italic> &#x003D; 1, &#x2026; <italic>q</italic>. Notice that these must be distinct reads from the multiset &#x1D4E1;<sub><italic>L</italic>,<italic>D</italic></sub>(s). This is because two distinct pairs (<italic>n</italic>, <italic>i</italic>) and (<italic>m</italic>, <italic>j</italic>) in &#x1D4D1;<sub><italic>&#x03C4;</italic></sub> must have <italic>n</italic> &#x2260; <italic>m</italic>, and the corresponding reads are r<sub><italic>&#x03C3;</italic><sup>&#x2212;1</sup>(<italic>t</italic><sub><italic>i</italic></sub> &#x2013; <italic>n</italic>)</sub> &#x003D; r<sub><italic>&#x03C4;</italic> &#x2013; <italic>n</italic></sub> and r<sub><italic>&#x03C3;</italic><sup>&#x2212;1</sup>(<italic>&#x03C3;</italic><sub><italic>j</italic></sub> &#x2013; <italic>m</italic>)</sub> &#x003D; r<sub><italic>&#x03C4;</italic> &#x2013; <italic>m</italic></sub>, which are distinct reads (not necessarily different sequences from &#x03A3;<sup><italic>L</italic></sup>). Finally, as illustrated in <xref ref-type="fig" rid="fig6">Fig. 6</xref>, we note that, since there are at most <italic>D</italic> erasures per base in s, we have that <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline31.gif"/></alternatives></inline-formula>, for <italic>j</italic> &#x003D; 1, &#x2026;, <italic>q</italic>.</p>
<fig id="fig6" position="float" fig-type="figure">
<label>Fig. 6.</label>
<caption><p>|&#x1D4D1;<sub><italic>&#x03C4;</italic><sub><italic>j</italic></sub></sub>| &#x2265; <italic>D</italic> &#x002B; 1, at least <italic>D</italic> &#x002B; 1 of the reads that cover one of <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline32.gif"/></alternatives></inline-formula> in &#x015D; also cover <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline33.gif"/></alternatives></inline-formula> in s (in this example, <italic>D</italic> &#x003D; 3). Since there are at most <italic>D</italic> erasures per base in s, we must have <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="014399_inline34.gif"/></alternatives></inline-formula>.</p></caption>
<graphic xlink:href="014399_fig6.tif"/></fig>
<p>We conclude that |<italic>&#x03B4;</italic>(<italic>U</italic>)| &#x2265; <italic>q</italic>.</p>
</sec>
<sec id="s6">
<label>VI.</label><title>CONCLUDING REMARKS</title>
<p>Our results show that for several actual genomes, if we are in a dense-read model with reads 20-40&#x0025; longer than the noiseless requirement <italic>&#x2113;</italic><sub>crit</sub>(s), perfect assembly feasibility is robust to erasures at a rate of about 10&#x0025;. While this is not as optimistic as the message from [<xref ref-type="bibr" rid="c7">7</xref>], we emphasize that we consider an adversarial error model. When errors instead occur at random locations, it is natural to expect less stringent requirements.</p>
<p>Another message provided by our results deals with error correction. Most current sequencing technologies employ error correction algorithms based on aligning reads to form clusters and outputing a cleaned-up read for each cluster. However, the spectrum error correction result from Theorem 3 suggests that a &#x201C;global&#x201D; approach to generating cleaned-up reads (based on finding a consistent assembly and looking at its spectrum) may perform better than cluster-based, or local, error correction.</p>
<p>A direction for future work is to replace the dense-read model with a shotgun read model. While the L-spectrum approach is motivated by the high-throughput of current technologies, it bypasses the question of the actual coverage depth required for assembly. As was the case in [<xref ref-type="bibr" rid="c3">3</xref>], we expect the read length requirements from the dense-read model to translate into <italic>bridging</italic> conditions in the shotgun model, allowing one to compute the coverage required for perfect reconstruction with high probability.</p>
</sec>
</body>
<back>
<ack><title>Acknowledgment</title>
<p>This work is partially supported by the Center for Science of Information (CSoI), an NSF Science and Technology Center, under grant agreement CCF-0939370.</p>
</ack>
<ref-list><title>References</title>
<ref id="c1"><label>[1]</label><mixed-citation publication-type="journal"><string-name><given-names>S. L.</given-names> <surname>Salzberg</surname></string-name>, &#x201C;<article-title>Mind the gaps</article-title>,&#x201D; <source>Nature methods</source>, vol. <volume>7</volume>, no. <issue>2</issue>, pp. <fpage>105</fpage>&#x2013;<lpage>106</lpage>, <year>2010</year>.</mixed-citation></ref>
<ref id="c2"><label>[2]</label><mixed-citation publication-type="website"><string-name><given-names>E.</given-names> <surname>Myers</surname></string-name>. (<year>2014</year>, Feb.). [Online], Available: <ext-link ext-link-type="uri" xlink:href="https://twitter.com/thegenemyers/status/437349388676263937">https://twitter.com/thegenemyers/status/437349388676263937</ext-link></mixed-citation></ref>
<ref id="c3"><label>[3]</label><mixed-citation publication-type="journal"><string-name><given-names>G.</given-names> <surname>Bresler</surname></string-name>, <string-name><given-names>M.</given-names> <surname>Bresler</surname></string-name>, and <string-name><given-names>D.</given-names> <surname>Tse</surname></string-name>, &#x201C;<article-title>Optimal assembly for high throughput shotgun sequencing</article-title>,&#x201D; <source>BMC Bioinformatics</source>, <year>2013</year>.</mixed-citation></ref>
<ref id="c4"><label>[4]</label><mixed-citation publication-type="journal"><string-name><given-names>E.</given-names> <surname>Ukkonen</surname></string-name>, &#x201C;<article-title>Approximate string matching with q-grams and maximal matches</article-title>,&#x201D; <source>Theoretical Computer Science</source>, vol. <volume>92</volume>, no. <issue>1</issue>, <year>1992</year>.</mixed-citation></ref>
<ref id="c5"><label>[5]</label><mixed-citation publication-type="journal"><string-name><given-names>P.</given-names> <surname>Pevzner</surname></string-name>, &#x201C;<article-title>DNA physical mapping and alternating Eulerian cycles in colored graphs</article-title>,&#x201D; <source>Algorithmica</source>, vol. <volume>13</volume>, pp. <fpage>77</fpage>&#x2013;<lpage>105</lpage>, <year>1995</year>.</mixed-citation></ref>
<ref id="c6"><label>[6]</label><mixed-citation publication-type="journal"><string-name><given-names>S. L.</given-names> <surname>Salzberg</surname></string-name>, <string-name><given-names>A. M.</given-names> <surname>Phillippy</surname></string-name>, <string-name><given-names>A.</given-names> <surname>Zimin</surname></string-name>, <string-name><given-names>D.</given-names> <surname>Puiu</surname></string-name>, <string-name><given-names>T.</given-names> <surname>Magoc</surname></string-name>, <string-name><given-names>S.</given-names> <surname>Koren</surname></string-name>, <string-name><given-names>T. J.</given-names> <surname>Treangen</surname></string-name>, <string-name><given-names>M. C.</given-names> <surname>Schatz</surname></string-name>, <string-name><given-names>A. L.</given-names> <surname>Delcher</surname></string-name>, <string-name><given-names>M.</given-names> <surname>Roberts</surname></string-name>, <string-name><given-names>G.</given-names> <surname>Marcais</surname></string-name>, <string-name><given-names>M.</given-names> <surname>Pop</surname></string-name>, and <string-name><given-names>J. A.</given-names> <surname>Yorke</surname></string-name>, &#x201C;<article-title>GAGE: a critical evaluation of genome assemblies and assembly algorithms</article-title>,&#x201D; <source>Genome Research</source>, vol. <volume>22</volume>, no. <issue>3</issue>, pp. <fpage>557</fpage>&#x2013;<lpage>567</lpage>, <year>2012</year>.</mixed-citation></ref>
<ref id="c7"><label>[7]</label><mixed-citation publication-type="journal"><string-name><given-names>A.</given-names> <surname>Motahari</surname></string-name>, <string-name><given-names>K.</given-names> <surname>Ramchandran</surname></string-name>, <string-name><given-names>D.</given-names> <surname>Tse</surname></string-name>, and <string-name><given-names>N.</given-names> <surname>Ma</surname></string-name>, &#x201C;<article-title>Optimal DNA shotgun sequencing: Noisy reads are as good as noiseless reads</article-title>,&#x201D; <source>Proc. of IEEE International Symposium on Information Theory</source>, pp. <fpage>1640</fpage>&#x2013;<lpage>1644</lpage>, <year>2013</year>.</mixed-citation></ref>
<ref id="c8"><label>[8]</label><mixed-citation publication-type="journal"><string-name><given-names>A.</given-names> <surname>Motahari</surname></string-name>, <string-name><given-names>G.</given-names> <surname>Bresler</surname></string-name>, and <string-name><given-names>D.</given-names> <surname>Tse</surname></string-name>, &#x201C;<article-title>Information theory of DNA shotgun sequencing</article-title>,&#x201D; <source>IEEE Transactions on Information Theoiy</source>, vol. <volume>59</volume>, no. <issue>10</issue>, pp. <fpage>6273</fpage>&#x2013;<lpage>6289</lpage>, Oct. <year>2013</year>.</mixed-citation></ref>
<ref id="c9"><label>[9]</label><mixed-citation publication-type="journal"><string-name><given-names>P. E. C.</given-names> <surname>Compeau</surname></string-name>, <string-name><given-names>P.</given-names> <surname>Pevzner</surname></string-name>, and <string-name><given-names>G.</given-names> <surname>Tesler</surname></string-name>, &#x201C;<article-title>How to apply de Bruijn graphs to genome assembly</article-title>,&#x201D; <source>Nature Biotechnology</source>, vol. <volume>29</volume>, <year>2011</year>.</mixed-citation></ref>
<ref id="c10"><label>[10]</label><mixed-citation publication-type="website">[Online], Available: <ext-link ext-link-type="uri" xlink:href="http://mummer.sourceforge.net/">http://mummer.sourceforge.net/</ext-link></mixed-citation></ref>
</ref-list>
<fn-group>
<fn id="fn1"><label><sup>1</sup></label><p>One example of a short-read-length technology is Illumina, with reads of length &#x007E; 200 base pairs and error rates of about 1&#x0025;. In contrast, PacBio reads can be several thousand base pairs long, with error rates of about 10-15&#x0025;.</p></fn>
</fn-group>
</back>
</article>