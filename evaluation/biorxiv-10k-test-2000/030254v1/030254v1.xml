<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.2d1 20170631//EN" "JATS-archivearticle1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" article-type="article" dtd-version="1.2d1" specific-use="production" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">BIORXIV</journal-id>
<journal-title-group>
<journal-title>bioRxiv</journal-title>
<abbrev-journal-title abbrev-type="publisher">bioRxiv</abbrev-journal-title>
</journal-title-group>
<publisher>
<publisher-name>Cold Spring Harbor Laboratory</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1101/030254</article-id>
<article-version>1.1</article-version>
<article-categories>
<subj-group subj-group-type="author-type">
<subject>Regular Article</subject>
</subj-group>
<subj-group subj-group-type="heading">
<subject>New Results</subject>
</subj-group>
<subj-group subj-group-type="hwp-journal-coll">
<subject>Bioinformatics</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>MetaR: simple, high-level languages for data analysis with the R ecosystem</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes">
<contrib-id contrib-id-type="orcid">http://orcid.org/0000-0001-6237-3564</contrib-id>
<name>
<surname>Campagne</surname>
<given-names>Fabien</given-names>
</name>
<xref ref-type="aff" rid="a1">1</xref>
<xref ref-type="aff" rid="a2">2</xref>
<xref ref-type="aff" rid="a3">3</xref>
<xref ref-type="corresp" rid="cor1">&#x002A;</xref>
</contrib>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">http://orcid.org/0000-0001-6237-3564</contrib-id>
<name>
<surname>Digan</surname>
<given-names>William ER</given-names>
</name>
<xref ref-type="aff" rid="a1">1</xref>
<xref ref-type="aff" rid="a2">2</xref>
</contrib>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">http://orcid.org/0000-0001-6237-3564</contrib-id>
<name>
<surname>Simi</surname>
<given-names>Manuele</given-names>
</name>
<xref ref-type="aff" rid="a1">1</xref>
<xref ref-type="aff" rid="a2">2</xref>
</contrib>
<aff id="a1"><label>1</label><institution>The HRH Prince Alwaleed Bin Talal Bin Abdulaziz Alsaud Institute for Computational Biomedicine, Weill Cornell Medicine</institution>, New York, NY, <country>United States of America</country></aff>
<aff id="a2"><label>2</label><institution>Clinical Translational Science Center, Weill Cornell Medicine</institution>, New York, NY, <country>United States of America</country></aff>
<aff id="a3"><label>3</label><institution>Department of Physiology and Biophysics, Weill Cornell Medicine</institution>, New York, NY, <country>United States of America</country></aff>
</contrib-group>
<author-notes>
<corresp id="cor1">
<label>&#x002A;</label>To whom correspondence should be addressed: <email>fac2003&#x0040;campagnelab.org</email>
</corresp>
</author-notes>
<pub-date pub-type="epub">
<year>2015</year>
</pub-date>
<elocation-id>030254</elocation-id>
<history>
<date date-type="received">
<day>29</day>
<month>10</month>
<year>2015</year>
</date>
<date date-type="accepted">
<day>29</day>
<month>10</month>
<year>2015</year>
</date>
</history>
<permissions>
<copyright-statement>&#x00A9; 2015, Posted by Cold Spring Harbor Laboratory</copyright-statement>
<copyright-year>2015</copyright-year>
<license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by/4.0/"><license-p>This pre-print is available under a Creative Commons License (Attribution 4.0 International), CC BY 4.0, as described at <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link></license-p></license>
</permissions>
<self-uri xlink:href="030254.pdf" content-type="pdf" xlink:role="full-text"/>
<abstract>
<title>ABSTRACT</title>
<p>Data analysis tools have become essential to the study of biology. Tools available today were constructed with layers of technology developed over decades. Here, we explain how some of the principles used to develop this technology are sub-optimal for the construction of data analysis tools for biologists. In contrast, we applied language workbench technology (LWT) to create a data analysis language, called MetaR, tailored for biologists with no programming experience, as well as expert bioinformaticians and statisticians. A key novelty of this approach is its ability to blend user interface with scripting in such a way that beginners and experts alike can analyze data productively in the same analysis platform. While presenting MetaR, we explain how a judicious use of LWT eliminates problems that have historically contributed to data analysis bottlenecks. These results show that language design with LWT can be a compelling approach for developing intelligent data analysis tools.</p>
</abstract>
<kwd-group kwd-group-type="author">
<title>Keywords:</title>
<kwd>Data analysis</kwd>
<kwd>Bioinformatics</kwd>
<kwd>Language Workbench Technology</kwd>
<kwd>Jetbrains MPS</kwd>
<kwd>Composable R</kwd>
<kwd>R language</kwd>
</kwd-group>
<counts>
<page-count count="15"/>
</counts>
</article-meta>
</front>
<body>
<p>The modern tools of biology often require biologists to rely on software tools for data analysis. For instance, software tools are required for analysis of high-throughput data, for the study of genome-wide gene expression, genetic or epigenetic. Similarly, most fields of biology require specialized software tools for analysis of microscopy, crystallography or other data. Most analysis software is constructed in a very similar manner: writing a program as a collection of text source code that is compiled into one or more executable analysis tools. Despite the evolution of programming languages, encoding programs as text has been a constant since the invention of the first high-level programming language (FORTRAN <xref ref-type="bibr" rid="c2">Backus (1958</xref>, <xref ref-type="bibr" rid="c1">1978</xref>)).</p>
<p>In this manuscript, we discuss several drawbacks of encoding programs as text that we believe contribute to common challenges encountered by data analysts. Language Workbenches (LWs) with projectional editors offer an alternative to storing source code as text. These approaches were conceived in the 90s <xref ref-type="bibr" rid="c17">Simonyi (1995)</xref> and have since led to the development of robust software development environments <xref ref-type="bibr" rid="c7">Dmitriev (2004)</xref>; <xref ref-type="bibr" rid="c9">Erdweg et al. (2013)</xref>. For this study, we used the Meta-Programming System (MPS, <ext-link ext-link-type="uri" xlink:href="http://jetbrains.com/mps">http://jetbrains.com/mps</ext-link>), a robust and open-source LW to explore whether LW technology (WLT) can help develop improved data analysis tools.</p>
<p>One question we were particularly interested in testing was whether we could create an analysis tool that would blend the boundary between programming/scripting languages and graphical user interfaces. Programming languages such as the R language <xref ref-type="bibr" rid="c12">Ihaka and Gentleman (1996)</xref> are frequently preferred for data analysis by experts. They have so far been the most flexible and powerful tools for data analysis, but require a steep learning curve. In contrast, beginners tend to prefer data analysis software with a graphical user interface, which are easier to learn, but eventually are found to lack flexibility and extensibility. We reasoned that blending these two types of interfaces into one tool could provide a simpler way for beginners to learn elements of scripting, improve repeatability and reproducibility of their analyses, and increase their productivity.</p>
<p>We found that LWT made it straightforward to develop a data analysis tool that blends the distinction between graphical user interface and scripting. If implementation was straightforward, our design of a novel type of analysis tool was an iterative process that benefited from frequent feedback from users of the tool. In this manuscript, we describe the goals of the language, explain how the tool can be used, and highlight the most innovative aspects of the language compared to other tools used for data analysis, such as the R language <xref ref-type="bibr" rid="c12">Ihaka and Gentleman (1996)</xref> or electronic notebooks.</p>
<p>The initial focus of MetaR was on analysis of RNA-Seq data and the creation of heatmaps, but the tool is general and can be readily extended to support a broad range of data analyses. For instance, we have used MetaR to analyze data in a study of association between the allogenomics score and kidney graft function <xref ref-type="bibr" rid="c13">Mesnard et al. (2015)</xref>. We chose to focus on the construction of heatmaps as a use case and illustration for this study because this activity is of interest to many biologists who obtain high-throughput data.</p>
<p>Interestingly, we found that both beginners and experts can benefit from blending user interfaces and scripting. Beginners benefit because the MetaR user interface is much simpler to learn than the full R programming language. Expert users benefit because they can develop high-level language elements to simplify repetitive aspects of data analysis in ways that text-based programming languages cannot achieve.</p>
<sec id="s1"><title>LANGUAGE WORKBENCH TECHNOLOGY PRIMER</title>
<p>Since many readers may not be familiar with LWT, this section briefly describes how this technology differs from traditional text-based technology.</p>
<p>Text-based programming languages are implemented with compilers that internally convert the text representation of the source code into an <italic>abstract syntax tree</italic> (AST), a data structure used when analyzing and transforming programming languages into machine code.</p>
<p>In the MPS LW, the AST is also a central data structure, but the parsing elements of the compilers are replaced with a graphical user interface (called a <italic>projectional editor</italic>) that enables users to directly edit the data structure. Where text-based languages are restricted to programs written as text, a projectional editor can support both textual and graphical user interfaces (such as images, buttons, tables or diagrams) <xref ref-type="bibr" rid="c18">Voelter and Solomatov (2010)</xref>. Projectional editors can also offer distinct views of the same AST, implemented as alternative editors. Projectional editors keep an AST in memory until the user saves the program. Saving an AST to disk is done using serialization (loading is conversely done via deserialization to memory AST data structures).</p>
<p>The choice of serialization rather than encoding with text has a profound consequence. Serialization uniquely identifies the concept for each node in an AST. This method makes it possible to combine AST fragments expressed with different languages, when the concept hierarchy of the languages supports composition. We have presented examples of language composition in <xref ref-type="bibr" rid="c16">Simi and Campagne (2014)</xref>; <xref ref-type="bibr" rid="c3">Benson and Campagne (2015)</xref>. In this manuscript, we extensively use language composition to extend the R language and provide the ability to embed user interfaces into R programs.</p>
<sec id="s1a"><title>Abstract Syntax Tree (AST)</title>
<p>An AST is a data structure traditionally used by compilers as a step towards generating machine code. In the MPS Language Workbench, an AST is a tree data structure, where nodes of the tree are instances of concepts (in the object-oriented sense). <xref ref-type="fig" rid="fig1">Figure 1</xref> illustrates the notion of AST nodes, concepts and projectional editor.</p>
<fig id="fig1" position="float" orientation="portrait" fig-type="figure">
<label>Figure 1.</label>
<caption><title>Concepts, Nodes and Projectional Editor.</title>
<p>Panel <bold>A:</bold> Projectional editor showing a simple R script with one assignment expression. Panel <bold>B:</bold> An abstract syntax tree is shown with nodes that correspond to the program in panel A. Panel <bold>C:</bold> Language Concepts for the nodes in Panel (B) (shown as blue boxes). Each concept is connected to other concepts with an open-ended arrow to indicate inheritance (e.g., <monospace>A &#x003C; &#x2013; B</monospace> indicates that <bold>B</bold> is a sub-concept of A). Green boxes indicate fields of a concept and are connected to the concept that has these fields by a line with a black diamond on the concept that owns the field. This shows that <monospace>BinaryExpression</monospace> is a concept that is an <monospace>Expression</monospace> and has three fields: <monospace>left, operator</monospace> and <monospace>right.</monospace> Dotted lines connect nodes to their concept. For instance, the &#x003C;&#x2212; and &#x002B; nodes are instances of <monospace>BinaryExpression.</monospace></p></caption>
<graphic xlink:href="030254_fig1.tif"/>
</fig>
<p>AST concepts may have properties (values of primitive types), children (lists of other nodes they contain), references (links to other nodes defined elsewhere in the AST). An AST has always a root node, which is used to start traversing the tree. In the MPS LW, AST root nodes are stored in models.</p></sec>
<sec id="s1b"><title>Languages</title>
<p>In the MPS LW, languages are defined as collection of concepts, concept editors (which together implement the user interface for the language), and other language aspects <xref ref-type="bibr" rid="c4">Campagne (2014)</xref>. Each language has a name which is used to import, or activate, the language inside a model. After importing a language into a model, it becomes possible to create ASTs with this language in the model. Creating an AST starts with the creation of a root node. Children of the root node are added using the projectional editor. Children of root nodes, properties and references can be edited interactively in the editor.</p></sec></sec>
<sec id="s2"><title>DESIGN OF A HIGH-LEVEL DATA ANALYSIS LANGUAGE</title>
<p>Several decisions must be made when designing a new computational language. Most decisions are driven by design goals. We have designed the MetaR language to address the following goals:</p>
<list list-type="order">
<list-item><p>The language should help users who have no knowledge of programming. The goal is to offer a smooth learning curve for beginners used to GUIs. We favor declarative language constructs over flexibility in parts of the language aimed at beginners.</p></list-item>
<list-item><p>Since a table of data is a frequent input when working with high-throughput data, make Table a first class element of the design. Leverage this element to simplify the annotation of the columns of a table. We rely on the idea that a little formalism (e.g., annotation of table columns) goes a long way to simplify analysis scripts.</p></list-item>
<list-item><p>Eliminate the need to know the language syntax to help beginners get started quickly. We leverage the MPS LW and its projectional editor to this end (<xref ref-type="bibr" rid="c18">Voelter and Solomatov (2010)</xref>). The MPS projectional editor provides interactive features, such as auto-completion, that provide guidance to beginners and experts alike when using the language to develop analyses.</p></list-item>
<list-item><p>Provide the ability to blend a scripting language with a graphical user interface. We use language composition and the ability of the MPS LW to render nodes with a mix of text and graphical user interface components.</p></list-item>
<list-item><p>Offer essential data transformations (e.g., joining two tables, taking subsets of rows of a table) via simple, yet composable language elements.</p></list-item>
<list-item><p>Provide means for experts to use their knowledge of the R language to work-around cases when the MetaR language is not sufficiently expressive to perform a specific analysis. We offer the ability to embed R code inside a MetaR analysis, as well as the ability to write scripts in the R language. In both instances, this variant of the R language supports language composition and enables embedding graphical user interfaces inside script fragments.</p></list-item>
</list>
<sec id="s2a"><title>High-level Design Choices</title>
<p>In addition to these goals, the design of MetaR included several strategic choices. We now present these choices and their rationales:</p>
<p><bold>Choice of a Target Language and Runtime System</bold> A language needs a runtime system to execute the code of programs written in the language. A possible choice for a runtime is to target another high-level language (such as Java, or C) but this would require implementing all aspects of data manipulation in the target language. Since the R language (<xref ref-type="bibr" rid="c12">Ihaka and Gentleman (1996)</xref>) is widely used for data analysis in biology, we considered using it as a runtime system. Experts biostatisticians and bioinformaticians have developed many R packages that implement advanced analysis for biological high-throughput data. These packages can be used to simplify the implementation of a runtime system for a new data analysis language. We therefore decided that the MetaR language would generate R code in order to take advantage of the packages developed in this language. This decision greatly simplified the implementation of the MetaR language because it removed the need to develop a custom language runtime system.</p>
<p><bold>Data Object Surrogates</bold> MetaR makes extensive use of Data Object Surrogates (DOS, our terminology). A data object surrogate is an object that represents other data (the source data). The surrogate often contains only limited information from the original data source. The DOS contains just enough to facilitate referring to the source data in another context for the purpose of data analysis, but not as much as to represent the entire content of the data source in memory. A good example of DOS is the Table object, which stores information about the columns of a data file. The Table DOS describes the columns of the table, but does not store the data contained in the table. A DOS typically has a name which can be used to refer to the DOS and its source data inside a MetaR model. References to table DOS help users refer to the table as they develop an analysis. Our use of the MPS LW facilitates the creation of DOS. In the MPS LW, we model DOS as concepts of the language. For instance, the Table DOS is represented by a Table concept, whose instances can be created in a model as root nodes. DOS are also used in MetaR to represent plots.</p>
<p><bold>Immutable Data Objects</bold> Many programming languages (of which C, C&#x002B;&#x002B;, Java, Perl, Python and R are members) make it possible to define variables or objects whose values can be changed (so called mutable variables). While this provides flexibility, it is a frequent source of confusion for beginners until they have developed their own mental model of how program steps modify variable values. During the design of MetaR, we chose to offer immutable objects rather than mutable variables when possible. This makes MetaR analyses easier to reason about because the value of objects cannot be changed after the object is created. Note that design decision does not prevent adding mutable variables to the MetaR language, but simplifies initial learning of the language by complete beginners.</p></sec>
<sec id="s2b"><title>Organization into Languages</title>
<p>We designed MetaR as a collection of MPS languages. The main language, <italic>org.campagnelab.metar</italic> is aimed at beginners with limited computational experience.</p>
<p>In the next section, we explain how the MetaR language can be used from the point of view of an end-user. This section also includes highlights of features that differ from the state of the art in data analysis. Please note that exhaustive reference documentation is available elsewhere (see <xref ref-type="bibr" rid="c6">Campagne and Simi (2015)</xref>) and the goal of the following paragraphs is to provide a sufficient introduction to data analysis with MetaR that readers can understand the impact of the innovations we tested in developing this tool.</p></sec>
<sec id="s2c"><title>The MetaR Language</title>
<sec id="s2c1"><title>Tables</title>
<p>An example of an immutable DOS is the MetaR Table object. In MetaR, objects of type Table represent tabular data with columns and rows of data. An example of a MetaR Table is shown in <xref ref-type="fig" rid="fig2">Figure 2</xref>. A MetaR Table is associated to a data file that contains the actual data of the table in a Tab-Separated Value (TSV). The location of the data file can be specified using Variables (i.e., <monospace>&#x0024;&#x007B;project&#x007D;)</monospace>, which offer independence from the local file system structure, and are particularly useful when keeping analyses under source control). A table has columns. Columns have names and types, which determine how data in each column is used. Types of data include string, numeric, boolean and enumeration (a small number of pre-defined categories, such as Male and Female). <xref ref-type="fig" rid="fig2">Figure 2</xref> presents a table of RNA-Seq read counts which was obtained from the Gene Expression Omnibus <xref ref-type="bibr" rid="c15">Seguin-Estevez et al. (2014)</xref> and annotated to enable analysis with MetaR.</p>
<fig id="fig2" position="float" orientation="portrait" fig-type="figure">
<label>Figure 2.</label>
<caption><title>Table and Column Group objects.</title>
<p>This figure presents the Table and Column Group objects. Green arrows show some cross-references among nodes of Tables and Column Groups. For instance, the ID group used to annotate the gene column is a reference to the ID group defined under the Column Group and Usage Container.</p></caption>
<graphic xlink:href="030254_fig2.tif"/>
</fig>
<p>Annotating a Table consists of two steps: (1) browsing to the file that contains the data. This can be accomplished by clicking on the file dialog button (the little square with &#x0026;) to locate the file. Upon selection of a valid file, the MetaR table node inspects the file and determines column names and types. Names and types are then shown in the Table node (under the <monospace>Columns</monospace> heading). (2) Specific columns can be annotated with one or more Column Groups.</p>
<p>Users can define arbitrary Column Groups in a different node called &#x201C;Column Groups and Usages&#x201D; (shown on the right of <xref ref-type="fig" rid="fig2">Figure 2</xref>). If two columns are related, user can define a Group Usage to explicitly document the relation. For instance, in <xref ref-type="fig" rid="fig2">Figure 2</xref>, the usage <monospace>LPS_Treatment</monospace> is defined to indicate that the Column Groups <monospace>LPS&#x003D;no</monospace> and <monospace>LPS&#x003D;yes</monospace> are two kinds of LPS treatments.</p>
<p>Tables and their annotations help users formalize information about data in a table. We find that asking the user to provide such information early on is beneficial because the structure of annotations can be leveraged in other parts of the language to provide intelligent auto-completion, customized for each table of data (for instance, to provide auto-completion for column names when writing expressions, or to select columns to use when joining two tables, examples of intelligent auto-completion is provided in the following sections, see <xref ref-type="fig" rid="fig3">Figure 3</xref>).</p>
<fig id="fig3" position="float" orientation="portrait" fig-type="figure">
<label>Figure 3.</label>
<caption><title>MetaR Analysis.</title>
<p>The Analysis node is composed of a list of statements. This analysis works with the table of data presented in <xref ref-type="fig" rid="fig2">Figure 2</xref>, removes the row of data where the value <monospace>Total</monospace> appears in the gene column, performs statistical modeling with Limma Voom to identify genes differentially expressed between LPS treated and control samples, constructs a heatmap and displays the plot as a preview. Finally, the analysis converts the plot to PDF format and writes the joined table (statistics and counts) in the <monospace>results.tsv</monospace> file.</p></caption>
<graphic xlink:href="030254_fig3.tif"/>
</fig>
<p>For instance, in the dataset of <xref ref-type="bibr" rid="c15">Seguin-Estevez et al. (2014)</xref>, users can indicate which columns contain data for samples that were treated (<monospace>LPS&#x003D;yes</monospace>) with lipopolysaccharide (LPS) or not (<monospace>LPS&#x003D;no</monospace>). MetaR facilitates the data curation steps of a data analysis project by offering an interactive user interface to help users keep track of annotations. The interface is interactive in several ways: group names can be auto-completed to the groups defined in the &#x201C;Column Group and Usage&#x201D; object. Menus are available to add column group annotations to a set of columns that the user has selected. In addition to LPS treatment, <xref ref-type="fig" rid="fig2">Figure 2</xref> shows the <monospace>count</monospace> annotation, used in an RNA-Seq differential expression analysis to identify which columns contain read counts, the <monospace>ID</monospace> column group, which uniquely identifies specific rows of the data table and the <monospace>heatmap</monospace> column group, used to choose which columns groups should be heatmap. This illustrates that the table annotation mechanism is flexible and can be leveraged by specific statements of the language, in order to indicate that the statement needs data annotated in a certain way.</p></sec>
<sec id="s2c2"><title>Analyses</title>
<p>Analyses make it possible for users to express how data is to be analyzed. <xref ref-type="fig" rid="fig3">Figure 3</xref> presents a MetaR Analysis node. This analysis is the one we use as a worked example during training sessions we offer at our institution. The editor of an analysis node offers an interface similar to that of a script in a traditional editor, but provides a more interactive and intelligent user interface. For instance, auto-completion is available at every point inside an analysis and suggests possible elements of the language that are compatible with the context at the cursor position.</p>
<p>The user may accept a suggestion and this results in the insertion of the language element at the position of the cursor. When the context calls for referencing a column of a table, for instance, only columns of Tables available at this point of the analysis are shown. While it is still possible to make mistakes when using this interface, mistakes created as a result of typos are less common than in programs encoded as text, for two reasons:</p>
<list list-type="bullet">
<list-item><p>Auto-completion offers a convenient way to set references between objects. Accepting an auto-completion suggestion helps users avoid typos.</p></list-item>
<list-item><p>Some users choose not to use auto-completion to set references and instead type a referenced node name. In this case, mis-typed names that cannot be resolved to a valid node are highlighted in red and in the right margin of the editor (this feature of the MPS LW is available for all languages developed with the MPS platform). This highlighting draws the attention of the user to the error or typo. This feature is also important when merging different versions of an analysis placed under source control or when combining analyses from parts of other analyses (e.g., errors will be clearly marked after a code fragment is pasted into a new analysis).</p></list-item>
</list>
<p>Auto-completion help is available for the various types of references supported by the MetaR language. Examples of these can be seen on <xref ref-type="fig" rid="fig3">Figure 3</xref> for tables (whose names are in green), plots (whose names are in blue), styles (names shown with a green background and white foreground, such as HeatmapStyle), or Column Group names (shown with a blue grey background and black foreground). Pressing control-B (or command-B on Mac) with the cursor on these nodes navigates to the destination of the reference (a menu is also available to help novice users discover this navigation mechanism). References may point to children nodes defined inside an analysis (e.g., plots), or nodes defined outside the analysis (e.g., tables and column groups).</p>
<p>Importantly, the MetaR user interface can also display buttons and images directly as part of the language. This feature takes advantage of the ability of the MPS LW to embed arbitrary graphical elements in the projectional editor. This capability is illustrated in <xref ref-type="fig" rid="fig3">Figure 3</xref> by the &#x201C;Hide Preview&#x201D; button and by the heatmap image shown immediately below the <monospace>multiplot</monospace> keyword (pressing this button hides the plot preview).</p>
<p>The level of interactivity provided by the MetaR user interface is best conveyed by watching video recordings of its use. We provide training videos at <monospace><ext-link ext-link-type="uri" xlink:href="http://metaR.campagnelab.org">http://metaR.campagnelab.org</ext-link></monospace> that help illustrate how much more interactive the MetaR language is compared to other languages commonly used for data analysis.</p></sec></sec>
<sec id="s2d"><title>Language Composition and Micro-Languages</title>
<p>Since MetaR is implemented as a set of MPS languages, it fully supports language composition (<xref ref-type="bibr" rid="c18">Voelter and Solomatov (2010)</xref>). Language composition has no equivalent in text-based programming languages and many readers may be therefore unfamiliar with this technique. We will use an example to explain the advantage of this technique for data analysis.</p>
<p>Consider the table of results produced by the analysis shown in <xref ref-type="fig" rid="fig3">Figure 3</xref>. Users are likely to need to annotate the subset of genes found differentially expressed with gene names and gene descriptions. Information such as this is available in the Biomart system <xref ref-type="bibr" rid="c11">Haider et al. (2009)</xref>.</p>
<p>To illustrate language composition, we created a new kind of MetaR statement called <monospace>query biomart</monospace>, which we defined in a micro-language. A micro-language is a language which provides only a few concepts meant to extend a host language. In this case, the MetaR language is the host language and <monospace>query biomart</monospace> is a concept contributed by the the micro-language. The purpose of this concept is to connect to Biomart and retrieve data. In the R language, this functionality is provided as a BioConductor package (called &#x201C;biomaRt&#x201D;, <xref ref-type="bibr" rid="c8">Durinck et al. (2005)</xref>)</p>
<p>Querying Biomart in R consists in calling one of the functions defined in the package with specific parameters. The statement is very specialized, and for this reason would not typically be part of the core statements of a text-based programming language. Leveraging language composition, we can offer a dedicated statement that supports auto-completion in a remote Biomart instance. The statement acts as a specialized user interface designed to help users retrieve data from Biomart (in very much the same way that the web-based interface to Biomart helps users query this resource, but here completely integrated with the MetaR host language).</p>
<p><xref ref-type="fig" rid="fig4">Figure 4</xref> illustrates how the <monospace>query biomart</monospace> statement can be used to obtain gene annotations. In order to use these statements, end-users of MetaR would declare using both the <italic>org.campagnelab.metar.tables</italic> (the host language) and <italic>org.campagnelab.metar.biomart</italic> (the micro-language). In this specific case, the micro-language is provided with the MetaR distribution, but end-users can also implement other micro-languages to seamlessly combine them with the host language (the process for doing so is described in the MetaR documentation booklet <xref ref-type="bibr" rid="c6">Campagne and Simi (2015)</xref>, Chapter 10). This capability makes it possible to customize the data analysis process for specific problems in much more flexible ways than would be possible with text-based programming languages: with the <monospace>query biomart</monospace> statement, we demonstrated that it is possible to remotely query databases to support auto-completion directly in the language. In contrast, text-based languages can only be extended in ways compatible with the syntax of the programming language, and are not able to support such levels of interactivity.</p>
<fig id="fig4" position="float" orientation="portrait" fig-type="figure">
<label>Figure 4.</label>
<caption><title>Example of Micro-language Composition.</title>
<p>The query biomart stament is defined in a micro-language called <italic>org.campagnelab.metar.biomart</italic>, which extends the host language <italic>org.campagnelab.metar.tables.</italic> The biomart language provides one statement that offers an interactive user interface to help users retrieve data from biomart. This language reuses expressions and tables from the host language. Micro-languages can be enabled or disabled dynamically by the end-user at the level of a model. This example retrieves Human ENSEMBL identifiers and gene descriptions using the HGNC gene symbols used as identifiers in the Results table (see <xref ref-type="fig" rid="fig3">Figure 3</xref> for the analysis that produced Results).</p></caption>
<graphic xlink:href="030254_fig4.tif"/>
</fig></sec>
<sec id="s2e"><title>Composable R language</title>
<p>In addition to the MetaR language illustrated in <xref ref-type="fig" rid="fig2">Figure 2</xref>-<xref ref-type="fig" rid="fig4">4</xref>, we have developed a composable R language. This language models the traditional R language <xref ref-type="bibr" rid="c12">Ihaka and Gentleman (1996)</xref>, but supports language composition. Composable R is implemented in the language <italic>org.campagnelab.metar.R</italic> distributed with MetaR. R programs can be pasted in text form into an RScript root node and the text is parsed and converted to nodes of the composable R language. In <xref ref-type="fig" rid="fig5">Figure 5</xref>, we show the R code equivalent to the analysis shown in <xref ref-type="fig" rid="fig4">Figure 4</xref>. This R script was pasted from the text generated automatically from the MetaR analysis shown in <xref ref-type="fig" rid="fig4">Figure 4</xref>. Executing this script is supported in the MPS LW and yields the same result that of the simpler MetaR script shown in <xref ref-type="fig" rid="fig4">Figure 4</xref>.</p>
<fig id="fig5" position="float" orientation="portrait" fig-type="figure">
<label>Figure 5.</label>
<caption><title>R language equivalent of the Analysis shown in <xref ref-type="fig" rid="fig4">Figure 4</xref>.</title>
<p>To produce this figure, the analysis shown in <xref ref-type="fig" rid="fig4">Figure 4</xref> was generated to the R language and the text was pasted in a RScript node of the composable R language. Automatic parsing of the R code into composable R objects yields a composable R version of the biomart example. Notice that boiler plate code needed to import R packages is shown only for the biomaRt package. Subsequent package import statements have been folded &#x007B;&#x0026;&#x007D; to save space in the Figure. Folding is directly supported by the MPS LW. Function calls are highlighted in green and are linked to the function declaration in the package stub (end-user can navigate to each function to review its list of arguments, for instance). Comparing the complexity of this code with the equivalent MetaR code shown in <xref ref-type="fig" rid="fig4">Figure 4</xref> makes a strong case for the need for simplified languages for data analysis.</p></caption>
<graphic xlink:href="030254_fig5.tif"/>
</fig></sec>
<sec id="s2f"><title>Micro-Languages for the R Language</title>
<p>A composable R language makes it possible to create micro-languages that compose directly with R as the host language. We demonstrate this capability by adapting the <monospace>query biomart</monospace> statement shown in <xref ref-type="fig" rid="fig4">Figure 4</xref> to the R language. Adaptation is simple because both MetaR and R generate to the same target language (R). In this case, we create a sub-concept of <monospace>Expr</monospace> (this type represents any R expression), and define a field of type <monospace>Biomart</monospace> (the concept that implements <monospace>query biomart</monospace>). This simple adapter is sufficient to make it possible to use the <monospace>query biomart</monospace> user interface inside an R script and is defined in the language <italic>org.campagnelab.metar.biomartToR.</italic> The result of composing the adapter language with composable R is shown in <xref ref-type="fig" rid="fig6">Figure 6</xref>.</p>
<fig id="fig6" position="float" orientation="portrait" fig-type="figure">
<label>Figure 6.</label>
<caption><title>Composing Query Biomart with the composable R language.</title>
<p>We developed an adapter that makes it possible to use the MetaR <monospace>query biomart</monospace> statement directly inside a composable R Script. This figure shows how the <monospace>query biomart</monospace> Expression adapter appears when used inside an R script. Notice how the table and column adapters are used inside a regular <monospace>hist()</monospace> function call <monospace>resultFromBioMart&#x0024;percent_identity_from_aflavus_homologs</monospace>. These adapters make it possible to refer to the table produced by the statement as an R expression and provide auto-completion for column names in the table (determined dynamically based on the query expressed in the <monospace>query biomart</monospace> statement).</p></caption>
<graphic xlink:href="030254_fig6.tif"/>
</fig>
<p>This example illustrates that a composable R language makes it possible to mix regular R code with new types of language constructs that can include user interfaces elements. This opens up new possibilities to facilitate repetitive analyses in R, for instance for specific data science domains (e.g., the Biomart example is useful for bioinformatic data analyses), but also for more general activities where simpler ways to perform a task would be beneficial. An example of this would be a micro-language to facilitate the use of packages to replace the boiler-plate package import code found at the beginning of most R scripts.</p></sec>
<sec id="s2g"><title>Using R Expressions in the MetaR Language</title>
<p><xref ref-type="fig" rid="fig7">Figure 7</xref> illustrates that language composition can also be used to embed R expressions inside a MetaR analysis. This extension is possible because both analyses and R expressions generate code compatible with the syntax of the R programming language. Providing a way to embed the full language in a simpler analysis language offers a guarantee that the end-user will not be overly limited by restrictions of the simpler language.</p>
<fig id="fig7" position="float" orientation="portrait" fig-type="figure">
<label>Figure 7.</label>
<caption><title>Composing R Expressions with the MetaR Language.</title>
<p>Top panel: this example illustrates that it is possible to use R code inside a MetaR analysis. In this snapshot, R code is delimited by the &#x2014; R and R &#x2014; markers and shown with a blue background. Embedding R code in MetaR provides flexibility to perform operations for which MetaR statements have not yet been developed. The analysis shown simulates a dataset using simple parameters and tests the ability of Limma voom, as integrated with MetaR, to call differentially expressed genes. Bottom panel: shows the result of executing the analysis inside the MPS LW. As part of execution, the analysis is converted to R code, this code is run and standard output displayed inside the LW. The <monospace>STATEMENT_EXECUTED//</monospace> lines hyperlink the progress of the execution with each specific analysis statement that has been executed.</p></caption>
<graphic xlink:href="030254_fig7.tif"/>
</fig></sec></sec>
<sec id="s3"><title>SOFTWARE</title>
<p>MetaR is distributed as a plugin of the MPS LW. Instructions for installing the software are available online at <monospace><ext-link ext-link-type="uri" xlink:href="http://metaR.campagnelab.org">http://metaR.campagnelab.org</ext-link>.</monospace> Briefly, after installing MPS, users can download and activate plugins with the Preferences/Plugins (Mac) or Settings/Plugins (Windows/Linux) menu. Plugins are stored as Zip files on the Jetbrains Plugin repository <monospace><ext-link ext-link-type="uri" xlink:href="https://plugins.jetbrains.com/category/index?pr&#x003D;mps&#x0026;category_id&#x003D;92">https://plugins.jetbrains.com/category/index?pr&#x003D;mps&#x0026;category_id&#x003D;92</ext-link></monospace> and can also be downloaded and installed manually from the zip file. Source code (technically, MPS languages serialized to files) are distributed on GitHub at <monospace><ext-link ext-link-type="uri" xlink:href="https://github.com/campagnelaboratory/MetaR">https://github.com/campagnelaboratory/MetaR</ext-link>.</monospace> MetaR (and the MPS LW) are distributed under the open-source Apache 2.0 license.</p></sec>
<sec id="s4"><title>DISCUSSION</title>
<sec id="s4a"><title>Data Object Surrogates and Relation to Meta Data</title>
<p>DOS are related, but different from metadata. For instance, the Table DOS provides metadata about the file that contains the tabular data represented by Table nodes. It lists columns, associates columns to groups and defines group usages. This type of information can be thought of as metadata about the file that contains the tabular data. However, there is an important difference between DOS and metadata. For instance, a MetaR Table only provides metadata relevant to the analysis that the user needs to perform. It makes no effort to provide information that would have a meaning outside of the user&#x2019;s analysis. This simplification maximizes the benefit of annotation while keeping the effort needed to produce it minimal and local to the user who actually needs the annotation.</p></sec>
<sec id="s4b"><title>Graphical User Interfaces for Data Analysis</title>
<p>Programs with graphical user interfaces (GUIs) (also called direct manipulation interfaces <xref ref-type="bibr" rid="c10">Galitz (2007)</xref>) are often popular among beginners who are starting with data analysis and have no programming or scripting experience. GUIs are popular in part because they facilitate discovery of software functionality directly when using the software. They do not require prior-knowledge of syntax.</p>
<p>Data Analysis software with GUIs constrains how analysis is to be performed and provides clear menus and buttons that make it obvious what the program can do. A user can often discover new ways to perform analysis with these tools simply by browsing the user interface and looking at choices offered in menus and dialogs of the program. While such programs are favored by beginners (because they are relatively easy to learn), more advanced users who need to perform similar analyses across several datasets tend to strongly prefer analysis software that does not require repeating interactions with a GUI for every new dataset that must be studied. The novel approaches we have used to develop MetaR share these advantages with GUIs.</p>
<p>A minority of analysis software with GUIs also supports writing and running scripts in their user interface. For instance, JMP from SAS Inc. is an example of a statistical analysis software with GUI that also offers a scripting language. However, when scripting is offered, it is often only loosely integrated with the rest of the interface. Furthermore, users who are familiar with the GUI often need to learn scripting from scratch and do not benefit much from their prior experience using the GUI.</p></sec>
<sec id="s4c"><title>Scripting and Programming Languages for Data Analysis</title>
<p>Scripting and programming languages are popular options for data analysis because analyses encoded in scripts or programs can be reused with different datasets. This makes these options popular among researchers who have programming skills and engage frequently in data analysis. The popularity and power of scripting for data analysis is epytomized by the development of the R language <xref ref-type="bibr" rid="c12">Ihaka and Gentleman (1996)</xref>, which has become a defacto workhorse of open data science in biology. The versatility of the R language is its strength, but mastering the language requires elements of programming. Learning the R programming language is not as simple as learning how to use a GUI analysis tool and many users who would benefit from data analysis experience difficulties with the steep learning curve involved in learning programming and the R language.</p>
<p>In contrast to R, the MetaR language offers a much simpler alternative for users who have no prior programming background. At the same time, the Composable R language offers the means for expert R users to extend the R language with micro-languages in order to provide custom user interfaces. Such interfaces could be used to flatten the learning curve for novice data analysts or to empower expert data analysts with expressive means to encode solution to specific problems. Since both these options are available in the same platform (the MPS LW), users who become skilled with one language acquire transferable skills that help them learn other languages available on the platform.</p></sec>
<sec id="s4d"><title>Relation to Electronic Notebooks</title>
<p>MetaR shares some similarities to electronic notebooks such as IPython <xref ref-type="bibr" rid="c14">P&#x00E9;rez and Granger (2007)</xref>, Jupyter (<monospace><ext-link ext-link-type="uri" xlink:href="https://jupyter.org/">https://jupyter.org/</ext-link></monospace>) and Beaker (<monospace><ext-link ext-link-type="uri" xlink:href="http://beakernotebook.com/">http://beakernotebook.com/</ext-link></monospace>) notebooks, but also has some important differences.</p>
<p>Regarding analogies, both MetaR and notebooks can be used to present analysis results alongside the code necessary to reproduce the results. For instance, the MetaR multi-view plot can be used to show a plot at the location where the statement is introduced in an analysis.</p>
<p>MetaR was developed approximately over the course of one year (2015). As such the software cannot be expected to be as feature-rich as software developed for many years. Beside this obvious difference, MetaR has the advantage to support language composition. In contrast, current data analysis notebooks support conventional programming languages constructed using text-based technology. Therefore, the closest that notebooks can approach language composition is to support multiple languages in one notebook, a so-called polyglot feature, available for instance in the Beaker notebook. Polyglot notebooks are useful, but cannot be extended by data analysts to customize languages for the requirements of a specific analysis project or domain. For instance, supporting a simple analysis language like MetaR would not be possible without developing a MetaR compiler and an associated execution kernel for the notebook. Developing and using micro-languages together with the traditional languages supported by the notebooks is also not possible.</p>
<p>Hence, the approach taken with MetaR is different from notebooks in two major ways. First, MetaR provides flexibility in designing new languages or micro-languages. It is not constrained by the syntax of a full programming language. Extending MetaR often consists in adding just one statement to an existing language. This promotes collaborative language design and development since many users can acquire sufficient skills to create one or two statements, reusing the building blocks provided by the host language (the steps needed to extend MetaR with a new language statement are described in the user manual <xref ref-type="bibr" rid="c6">Campagne and Simi (2015)</xref>). As long as a new statement generates valid R code, a MetaR Analysis that contains this statement will be executable.</p>
<p>Second, the syntax of the MetaR languages is not limited to text scripts or programs. Language Workbench technology used to implement MetaR supports graphical notations and diagrams as well as text. These differences combine to make it easier to design and implement custom data analysis abstractions with the LWT approach than it is possible with current electronic notebooks. Interestingly, the R IPython kernel could be used to execute scripts generated from MetaR analyses, which would provide an interactive console similar to that offered in the IPython notebook inside the MPS LW.</p></sec>
<sec id="s4e"><title>Relation to Electronic Notebooks</title>
<p>MetaR analysis and Composable R scripts can be executed seamlessly with an R environment installed inside a docker image (see Methods). Users can enable this feature by providing a few details about the installation of docker on their computer and checking the &#x201C;Run with Docker&#x201D; option in the MPS LW. This feature is particularly useful to facilitate reproducible research because docker images can be tagged with version numbers and always result in the same execution environment at the start of an analysis. This makes it possible to pre-install specific versions of R, CRAN and Bioconductor packages in a container and distribute this image with the MetaR analyses or R scripts that implement the analysis inside the container. While this is possible also with R, using docker on the command line, the customization of the MPS LW makes it seamless to run analyses with docker. We are not aware of a similar feature being supported by current R IDEs.</p>
<p>We found this feature also particularly useful for training sessions where installation of a working R environment can be challenging on trainees&#x2019; laptops. Using docker, we simply request that trainees pre-install Kitematic (available on Mac and Windows), or run docker natively on Linux and download the image we prepared with the packages used in the MetaR training sessions. The ability to run MetaR analysis in docker container results in a predictable installation of dependencies for training session and frees more of the instructor&#x2019;s time to present data analysis techniques.</p></sec></sec>
<sec id="s5"><title>METHODS</title>
<p>We have used the MPS Language Workbench (<monospace><ext-link ext-link-type="uri" xlink:href="http://jetbrains.com/mps">http://jetbrains.com/mps</ext-link></monospace>), as also described in <xref ref-type="bibr" rid="c4">Campagne (2014)</xref> and <xref ref-type="bibr" rid="c5">Campagne (2015)</xref>. For an introduction to Language Workbench Technology (LWT) in the context of bioinformatics see <xref ref-type="bibr" rid="c16">Simi and Campagne (2014)</xref> and <xref ref-type="bibr" rid="c3">Benson and Campagne (2015)</xref> in the context of predictive biomarker model development.</p>
<sec id="s5a"><title>Language Design</title>
<p>We designed the MetaR MPS languages through an iterative process, releasing the languages at least weekly to end-users at the beginning of the project and adjusting designs and implementations according to user feedback. Full language developments logs are available on the GitHub code repository (<monospace><ext-link ext-link-type="uri" xlink:href="https://github.com/CampagneLaboratory/MetaR">https://github.com/CampagneLaboratory/MetaR</ext-link></monospace>). Briefly, we designed abstractions to facilitate specific analyses and implemented these abstractions with the structure, editor, constraints and typesystem aspects of MPS languages. Generated R code is produced from nodes of the languages using the <italic>org.campagnelab.TextOutput</italic> plugin. An illustration of the steps required to develop one language statement is available in Chapter 10 of the MetaR documentation booklet (see <xref ref-type="bibr" rid="c6">Campagne and Simi (2015)</xref>).</p></sec>
<sec id="s5b"><title>Table Viewer</title>
<p>We implemented a Table viewer as an MPS Tabbed Tool, using the MPS LW mechanisms for user interface extension (see <xref ref-type="bibr" rid="c5">Campagne (2015)</xref>). The table viewer provides the ability to inspect the data content of any table produced during an analysis, or any input table. When the cursor is positioned over a node that represent a FutureTable (created when running the R script generated from the MetaR Analysis), and the viewer is opened, it tries to load the data file that the analysis would create for this table. If the file is found, the content is displayed using a Java Swing Component in the MPS user interface of the Table Viewer tool.</p></sec>
<sec id="s5c"><title>Language Execution</title>
<p>MetaR analyses can be executed directly from within the MPS LW. This capability was implemented with Run Configurations (see <xref ref-type="bibr" rid="c5">Campagne (2015)</xref>, Chapter 5).</p></sec>
<sec id="s5d"><title>Execution in a Docker Container</title>
<p>In order to facilitate reproducible execution, we implemented optional execution within a Docker container. A docker image was created to contain a Linux operating system and a recent distribution of the R language (provided in the rocker-base image), as well as several R packages needed when executing the MetaR statements. The Run Configuration was modified to enable execution inside a docker container when the user selects a checkbox &#x201D;execute inside docker container&#x201D;. Information necessary to run with docker (i.e., location of the docker executable, docker server connection settings and image name and tag) is collected under a tab in the MPS Preferences (Other Settings/Docker).</p></sec></sec>
</body>
<back>
<ack><title>ACKNOWLEDGMENTS</title>
<p>The authors thank Carl Boettiger and Dirk Eddelbuettel, who developed the <monospace>rocker-base</monospace> image, used in the MetaR project to facilitate the creation of docker images for training sessions and reproducible research. This investigation was supported by the National Institutes of Health NIAID award 5R01AI107762-02 to Fabien Campagne and by grant UL1 RR024996 (National Institutes of Health (NIH)/National Center for Research Resources) of the Clinical and Translation Science Center at Weill Cornell Medical College.</p>
</ack>
<ref-list><title>REFERENCES</title>
<ref id="c1"><mixed-citation publication-type="other"><string-name><surname>Backus</surname>, <given-names>J.</given-names></string-name> (<year>1978</year>). <article-title>The history of fortran i, ii, and iii</article-title>. In <source>History of programming languages I</source>, pages <fpage>25</fpage>&#x2013;<lpage>74</lpage>. ACM.</mixed-citation></ref>
<ref id="c2"><mixed-citation publication-type="other"><string-name><surname>Backus</surname>, <given-names>J. W.</given-names></string-name> (<year>1958</year>). <article-title>Automatic programming: properties and performance of fortran systems i and ii</article-title>. In <source>Proceedings of the Symposium on the Mechanisation of Thought Processes</source>, pages <fpage>165</fpage>&#x2013;<lpage>180</lpage>.</mixed-citation></ref>
<ref id="c3"><mixed-citation publication-type="journal"><string-name><surname>Benson</surname>, <given-names>V. M.</given-names></string-name>, and <string-name><surname>Campagne</surname>, <given-names>F.</given-names></string-name> (<year>2015</year>). <article-title>Language workbench user interfaces for data analysis</article-title>. <source>PeerJ</source>, <volume>3</volume>:<fpage>e800</fpage>.</mixed-citation></ref>
<ref id="c4"><mixed-citation publication-type="book"><string-name><surname>Campagne</surname>, <given-names>F.</given-names></string-name> (<year>2014</year>). <source>The MPS Language Workbench</source>, volume <volume>I</volume>. <publisher-loc>Fabien Campagne</publisher-loc>.</mixed-citation></ref>
<ref id="c5"><mixed-citation publication-type="book"><string-name><surname>Campagne</surname>, <given-names>F.</given-names></string-name> (<year>2015</year>). <source>The MPS Language Workbench</source>, volume <volume>II</volume>. <publisher-name>Fabien Campagne</publisher-name>.</mixed-citation></ref>
<ref id="c6"><mixed-citation publication-type="book"><string-name><surname>Campagne</surname>, <given-names>F.</given-names></string-name> and <string-name><surname>Simi</surname>, <given-names>M.</given-names></string-name> (<year>2015</year>). <source>MetaR Documentation Booklet</source>. <publisher-name>Fabien Campagne</publisher-name>.</mixed-citation></ref>
<ref id="c7"><mixed-citation publication-type="other"><string-name><surname>Dmitriev</surname>, <given-names>S.</given-names></string-name> (<year>2004</year>). <source>Language oriented programming: The next programming paradigm</source>.</mixed-citation></ref>
<ref id="c8"><mixed-citation publication-type="journal"><string-name><surname>Durinck</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>Moreau</surname>, <given-names>Y.</given-names></string-name>, <string-name><surname>Kasprzyk</surname>, <given-names>A.</given-names></string-name>, <string-name><surname>Davis</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>Moor</surname>, <given-names>B. D.</given-names></string-name>, <string-name><surname>Brazma</surname>, <given-names>A.</given-names></string-name>, and <string-name><surname>Huber</surname>, <given-names>W.</given-names></string-name> (<year>2005</year>). <article-title>BioMart and Bioconductor: a powerful link between biological databases and microarray data analysis</article-title>. <source>Bioinformatics</source>, <volume>21</volume>: <fpage>3439</fpage>&#x2013;<lpage>3440</lpage>.</mixed-citation></ref>
<ref id="c9"><mixed-citation publication-type="book"><string-name><surname>Erdweg</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>van der Storm</surname>, <given-names>T.</given-names></string-name>, <string-name><surname>V&#x00F6;lter</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Boersma</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Bosman</surname>, <given-names>R.</given-names></string-name>, <string-name><surname>Cook</surname>, <given-names>W. R.</given-names></string-name>, <string-name><surname>Gerritsen</surname>, <given-names>A.</given-names></string-name>, <string-name><surname>Hulshout</surname>, <given-names>A.</given-names></string-name>, <string-name><surname>Kelly</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>Loh</surname>, <given-names>A.</given-names></string-name>, <etal>et al.</etal> (<year>2013</year>). <chapter-title>The state of the art in language workbenches</chapter-title>. In <source>Software language engineering</source>, pages <fpage>197</fpage>&#x2013;<lpage>217</lpage>. <publisher-name>Springer</publisher-name>.</mixed-citation></ref>
<ref id="c10"><mixed-citation publication-type="book"><string-name><surname>Galitz</surname>, <given-names>W. O.</given-names></string-name> (<year>2007</year>). <source>The Essential Guide to User Interface Design: An Introduction to GUI Design Principles and Techniques</source>. <publisher-name>John Wiley &#x0026; Sons</publisher-name>.</mixed-citation></ref>
<ref id="c11"><mixed-citation publication-type="other"><string-name><surname>Haider</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>Ballester</surname>, <given-names>B.</given-names></string-name>, <string-name><surname>Smedley</surname>, <given-names>D.</given-names></string-name>, <string-name><surname>Zhang</surname>, <given-names>J.</given-names></string-name>, <string-name><surname>Rice</surname>, <given-names>P.</given-names></string-name>, and <string-name><surname>Kasprzyk</surname>, <given-names>A.</given-names></string-name> (<year>2009</year>). <article-title>BioMart Central Portal-unified access to biological data</article-title>. <source>Nucleic Acids Res</source>.</mixed-citation></ref>
<ref id="c12"><mixed-citation publication-type="journal"><string-name><surname>Ihaka</surname>, <given-names>R.</given-names></string-name> and <string-name><surname>Gentleman</surname>, <given-names>R.</given-names></string-name> (<year>1996</year>). <article-title>R: a language for data analysis and graphics</article-title>. <source>Journal of computational and graphical statistics</source>, <volume>5</volume>(<issue>3</issue>):<fpage>299</fpage>&#x2013;<lpage>314</lpage>.</mixed-citation></ref>
<ref id="c13"><mixed-citation publication-type="other"><string-name><surname>Mesnard</surname>, <given-names>L.</given-names></string-name>, <string-name><surname>Muthukumar</surname>, <given-names>T.</given-names></string-name>, <string-name><surname>Burbach</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Li</surname>, <given-names>C.</given-names></string-name>, <string-name><surname>Shang</surname>, <given-names>H.</given-names></string-name>, <string-name><surname>Dadhania</surname>, <given-names>D.</given-names></string-name>, <string-name><surname>Lee</surname>, <given-names>J. R.</given-names></string-name>, <string-name><surname>Sharma</surname>, <given-names>V. K.</given-names></string-name>, <string-name><surname>Xiang</surname>, <given-names>J.</given-names></string-name>, <string-name><surname>Suberbielle</surname>, <given-names>C.</given-names></string-name>, <string-name><surname>Carmagnat</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Ouali</surname>, <given-names>N.</given-names></string-name>, <string-name><surname>Rondeau</surname>, <given-names>E.</given-names></string-name>, <string-name><surname>Friedewald</surname>, <given-names>J. J.</given-names></string-name>, <string-name><surname>Abecassis</surname>, <given-names>M. M.</given-names></string-name>, <string-name><surname>Suthanthiran</surname>, <given-names>M.</given-names></string-name>, and <string-name><surname>Campagne</surname>, <given-names>F.</given-names></string-name> (<year>2015</year>). <source>Exome sequencing and prediction of long-term kidney allograft function</source>.</mixed-citation></ref>
<ref id="c14"><mixed-citation publication-type="journal"><string-name><surname>P&#x00E9;rez</surname>, <given-names>F.</given-names></string-name> and <string-name><surname>Granger</surname>, <given-names>B. E.</given-names></string-name> (<year>2007</year>). <article-title>IPython: a system for interactive scientific computing</article-title>. <source>Computing in Science and Engineering</source>, <volume>9</volume>(<issue>3</issue>):<fpage>21</fpage>&#x2013;<lpage>29</lpage>.</mixed-citation></ref>
<ref id="c15"><mixed-citation publication-type="journal"><string-name><surname>Seguin-Estevez</surname>, <given-names>Q.</given-names></string-name>, <string-name><surname>Dunand-Sauthier</surname>, <given-names>I.</given-names></string-name>, <string-name><surname>Lemeille</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>Iseli</surname>, <given-names>C.</given-names></string-name>, <string-name><surname>Ibberson</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Ioannidis</surname>, <given-names>V.</given-names></string-name>, <string-name><surname>Schmid</surname>, <given-names>C. D.</given-names></string-name>, <string-name><surname>Rousseau</surname>, <given-names>P.</given-names></string-name>, <string-name><surname>Barras</surname>, <given-names>E.</given-names></string-name>, <string-name><surname>Geinoz</surname>, <given-names>A.</given-names></string-name>, <string-name><surname>Xenarios</surname>, <given-names>I.</given-names></string-name>, <string-name><surname>Acha-Orbea</surname>, <given-names>H.</given-names></string-name>, and <string-name><surname>Reith</surname>, <given-names>W.</given-names></string-name> (<year>2014</year>). <article-title>Extensive remodeling of DC function by rapid maturation-induced transcriptional silencing</article-title>. <source>Nucleic Acids Research</source>, <volume>42</volume>(<issue>15</issue>):<fpage>9641</fpage>&#x2013;<lpage>9655</lpage>.</mixed-citation></ref>
<ref id="c16"><mixed-citation publication-type="other"><string-name><surname>Simi</surname>, <given-names>M.</given-names></string-name> and <string-name><surname>Campagne</surname>, <given-names>F.</given-names></string-name> (<year>2014</year>). <article-title>Composable languages for bioinformatics: the nyosh experiment</article-title>. <source>PeerJ</source>.</mixed-citation></ref>
<ref id="c17"><mixed-citation publication-type="other"><string-name><surname>Simonyi</surname>, <given-names>C.</given-names></string-name> (<year>1995</year>). <article-title>The death of computer languages, the birth of intentional programming</article-title>. <source>Technical report</source>.</mixed-citation></ref>
<ref id="c18"><mixed-citation publication-type="other"><string-name><surname>Voelter</surname>, <given-names>M.</given-names></string-name> and <string-name><surname>Solomatov</surname>, <given-names>K.</given-names></string-name> (<year>2010</year>). <article-title>Language modularization and composition with projectional language workbenches illustrated with MPS</article-title>. <source>Software Language Engineering, SLE</source>.</mixed-citation></ref>
</ref-list>
</back>
</article>