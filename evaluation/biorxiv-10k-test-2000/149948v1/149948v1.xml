<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.2d1 20170631//EN" "JATS-archivearticle1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" article-type="article" dtd-version="1.2d1" specific-use="production" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">BIORXIV</journal-id>
<journal-title-group>
<journal-title>bioRxiv</journal-title>
<abbrev-journal-title abbrev-type="publisher">bioRxiv</abbrev-journal-title>
</journal-title-group>
<publisher>
<publisher-name>Cold Spring Harbor Laboratory</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1101/149948</article-id>
<article-version>1.1</article-version>
<article-categories>
<subj-group subj-group-type="author-type">
<subject>Regular Article</subject>
</subj-group>
<subj-group subj-group-type="heading">
<subject>New Results</subject>
</subj-group>
<subj-group subj-group-type="hwp-journal-coll">
<subject>Bioinformatics</subject>
</subj-group>
</article-categories>
<title-group><article-title>K-mer clustering algorithm using a MapReduce framework: application to the parallelization of the Inchworm module of Trinity</article-title></title-group>
<contrib-group>
<contrib contrib-type="author"><name><surname>Kim</surname><given-names>Chang Sik</given-names></name><xref ref-type="aff" rid="a1">1</xref>
<xref ref-type="author-notes" rid="n1">&#x2020;</xref></contrib>
<contrib contrib-type="author" corresp="yes"><name><surname>Winn</surname><given-names>Martyn D.</given-names></name><xref ref-type="aff" rid="a1">1</xref>
<xref ref-type="corresp" rid="cor1">&#x002A;</xref></contrib>
<contrib contrib-type="author"><name><surname>Sachdeva</surname><given-names>Vipin</given-names></name><xref ref-type="aff" rid="a2">2</xref>
<xref ref-type="author-notes" rid="n2">&#x00A7;</xref></contrib>
<contrib contrib-type="author"><name><surname>Jordan</surname><given-names>Kirk E.</given-names></name><xref ref-type="aff" rid="a2">2</xref></contrib>
<aff id="a1"><label>1</label> <institution>The Hartree Centre, STFC Daresbury Laboratory</institution>, Warrington, WA4 4AD, <country>UK</country></aff>
<aff id="a2"><label>2</label> <institution>Computational Science Center, IBM T.J. Watson Research</institution>, Cambridge, MA, <country>USA</country></aff>
</contrib-group>
<author-notes>
<fn fn-type="present-address" id="n1"><label>&#x2020;</label><p>Presenet addresses: Cancer Research UK Manchester Institute, The University of Manchester, Manchester, M20 4BX, UK</p></fn>
<fn fn-type="present-address" id="n2"><label>&#x00A7;</label><p>Presenet addresses: Silicon Therapeutics, 300 A Street, Boston MA, USA</p></fn>
<corresp id="cor1"><label>&#x002A;</label>Corresponding author: <email>martyn.winn@stfc.ac.uk</email></corresp>
</author-notes>
<pub-date pub-type="epub">
<year>2017</year>
</pub-date>
<elocation-id>149948</elocation-id>
<history>
<date date-type="received">
<day>14</day>
<month>6</month>
<year>2017</year>
</date>
<date date-type="rev-recd">
<day>14</day>
<month>6</month>
<year>2017</year>
</date>
<date date-type="accepted">
<day>14</day>
<month>6</month>
<year>2017</year>
</date>
</history><permissions><copyright-statement>&#x00A9; 2017, Posted by Cold Spring Harbor Laboratory</copyright-statement>
<copyright-year>2017</copyright-year><license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by/4.0/"><license-p>This pre-print is available under a Creative Commons License (Attribution 4.0 International), CC BY 4.0, as described at <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link></license-p></license></permissions>
<self-uri xlink:href="149948.pdf" content-type="pdf" xlink:role="full-text"/>
<abstract><title>Abstract</title>
<sec><title>Background</title>
<p><italic>De novo</italic> transcriptome assembly is an important technique for understanding gene expression in non-model organisms. Many de novo assemblers using the de Bruijn graph of a set of the RNA sequences rely on in-memory representation of this graph. However, current methods analyse the complete set of read-derived k-mer sequence at once, resulting in the need for computer hardware with large shared memory.</p>
</sec>
<sec><title>Results</title>
<p>We introduce a novel approach that clusters k-mers as the first step. The clusters correspond to small sets of gene products, which can be processed quickly to give candidate transcripts. We implement the clustering step using the MapReduce approach for parallelising the analysis of large datasets, which enables the use of compute clusters. The computational task is distributed across the compute system, and no specialised hardware is required. Using this approach, we have re-implemented the Inchworm module from the widely used Trinity pipeline, and tested the method in the context of the full Trinity pipeline. Validation tests on a range of real datasets show large reductions in the runtime and per-node memory requirements, when making use of a compute cluster.</p>
</sec>
<sec><title>Conclusions</title>
<p>Our study shows that MapReduce-based clustering has great potential for distributing challenging sequencing problems, without loss of accuracy. Although we have focussed on the Trinity package, we propose that such clustering is a useful initial step for other assembly pipelines.</p>
</sec>
</abstract>
<kwd-group kwd-group-type="author">
<title>Keywords:</title>
<kwd>MapReduce</kwd>
<kwd><italic>de novo</italic> sequence assembly</kwd>
<kwd>RNA-Seq</kwd>
<kwd>Trinity</kwd>
</kwd-group>
<counts>
<page-count count="45"/>
</counts>
</article-meta>
</front>
<body>
<sec id="s1"><title>Background</title>
<p>Quantifying the expression of genes under different conditions is fundamental to understanding the behaviour and response of organisms to internal and external stimuli. With the arrival of Next Generation massively parallel sequencing technologies, the ability to monitor gene expression has been transformed [<xref ref-type="bibr" rid="c1">1</xref>, <xref ref-type="bibr" rid="c2">2</xref>]. Direct sequencing of mRNA from expressed genes (RNA-Seq) is now feasible, and has several advantages over microarray technology [<xref ref-type="bibr" rid="c3">3</xref>]. Most notably, it removes the need to have <italic>a priori</italic> knowledge of the transcribed regions, so that novel genes can be identified, or novel variants of known genes. This has led to a rapid increase in the number of studies looking at gene expression in non-model organisms. RNA-Seq is also increasingly used to study non-coding RNAs, such as microRNAs [<xref ref-type="bibr" rid="c4">4</xref>], lincRNAs [<xref ref-type="bibr" rid="c5">5</xref>], and circRNAs [<xref ref-type="bibr" rid="c6">6</xref>] which play various regulatory roles.</p>
<p>Nevertheless, it is widely recognised that the improvement in sequencing technology has shifted the bottleneck to down-stream data analysis. In the case of RNA-Seq, sequencing can be complicated by the presence of contaminant RNA, paralogous genes, and especially for higher organisms the prevalence of alternative splicing [<xref ref-type="bibr" rid="c7">7</xref>, <xref ref-type="bibr" rid="c8">8</xref>]. Paired-end sequencing and strand-specific sequencing can help to resolve sequencing ambiguities, but must be included explicitly in the data analysis. Finally, and as we address in this study, the sheer size of datasets can cause practical problems in sequence assembly. In particular, the computational complexity limits the ability to try multiple methods or multiple parameter choices, in order to optimise the quality of the results obtained.</p>
<p>Initial approaches to the high throughput analysis of transcriptome sequence data were based on the alignment of RNA-Seq reads to reference genomes [<xref ref-type="bibr" rid="c9">9</xref>-<xref ref-type="bibr" rid="c14">14</xref>]. Such approaches are limited by the availability of suitable reference genomes, and by the structural alterations that can be detected, particularly when input reads are relatively short. Subsequently, <italic>de novo</italic> genome assemblers were adapted to the analysis of transcriptome data in the absence of a reference, by postprocessing draft contigs to identify transcripts. Examples of transcriptome assemblers based on genome assemblers include Oases [<xref ref-type="bibr" rid="c15">15</xref>] and <italic>postprocess</italic> [<xref ref-type="bibr" rid="c16">16</xref>] based on Velvet [<xref ref-type="bibr" rid="c17">17</xref>], TransABySS [<xref ref-type="bibr" rid="c18">18</xref>] based on ABySS [<xref ref-type="bibr" rid="c19">19</xref>], and SOAPdenovo-Trans [<xref ref-type="bibr" rid="c20">20</xref>] based on SOAPdenovo [<xref ref-type="bibr" rid="c21">21</xref>]. In contrast, the Trinity [<xref ref-type="bibr" rid="c22">22</xref>] pipeline which we consider below was developed specifically for <italic>de novo</italic> transcriptome assembly. More recent examples hybridizing previous <italic>de novo</italic> assembly algorithms include Bridger [<xref ref-type="bibr" rid="c23">23</xref>] based on Trinity [<xref ref-type="bibr" rid="c22">22</xref>] and SOAPdenovo-Trans [<xref ref-type="bibr" rid="c20">20</xref>], BinPacker [<xref ref-type="bibr" rid="c24">24</xref>] based on Bridger [<xref ref-type="bibr" rid="c23">23</xref>] and bin-packing strategy [<xref ref-type="bibr" rid="c25">25</xref>], and DRAP [<xref ref-type="bibr" rid="c26">26</xref>] based on Trinity [<xref ref-type="bibr" rid="c22">22</xref>] and Oases [<xref ref-type="bibr" rid="c15">15</xref>].</p>
<p>Most <italic>de novo</italic> transcriptome assembly methods are based on <italic>de Bruijn</italic> graphs of k-mers, where a k-mer is a sub-sequence of an input read with k base calls. For a chosen value of k, the assembler creates a k-mer graph, where the set of nodes correspond to all unique k-mers present in the input reads, and the edges represent &#x201C;suffix-to-prefix&#x201D; overlaps between k-mers. Most <italic>de novo</italic> transcriptome assembly algorithms store all unique k-mers from the input reads in shared memory, in order to facilitate edge detection and graph construction, and this can lead to extremely large RAM usage [<xref ref-type="bibr" rid="c27">27</xref>]. For example Velvet, as used by Oases, starts by creating two large hashmap tables in memory storing the information for all k-mers. TransABySS/ABySS is one of only a few parallel algorithms, which starts by distributing k-mers onto multiple compute nodes with a simple hash function. The Trinity pipeline consists of three independent software modules; <italic>Inchworm, Chrysalis</italic> and <italic>Butterfly</italic>. <italic>Inchworm</italic> initially creates a large hashmap table to store all unique k-mers from the input RNA-seq reads, and then it selects k-mers from the hashmap to construct linear contigs using a greedy k-mer extension approach. In our previous study [<xref ref-type="bibr" rid="c28">28</xref>], we confirmed that the <italic>Inchworm</italic> module of Trinity requires relatively high physical memory usage.</p>
<p>The memory requirements of these packages increase for larger and more complex transcriptomes, which generate larger numbers of k-mers and hence larger graphs, and can exceed the computational resources available. One strategy that is commonly used is to normalize the read data [<xref ref-type="bibr" rid="c29">29</xref>]. Redundant reads are removed from regions with high sequencing coverage, while reads are retained in regions of low coverage. In this way, up to 90&#x0025; of input reads can be removed, which in turn leads to the elimination of a large fraction of erroneous k-mers associated with these reads [<xref ref-type="bibr" rid="c29">29</xref>]. While this is believed to work well, it introduces an additional processing step, which can in itself require large memory.</p>
<p>The fundamental task of <italic>de novo</italic> transcriptome assembly (in contrast to genome assembly) is to separate the full sequence data into many disjoint sets. Each set corresponds to a collection of gene variants sharing k-mers due to alternative splicing or gene duplication. In other words, a transcriptome can be represented as multiple distinct <italic>de Bruijn</italic> graphs (<xref ref-type="fig" rid="fig1">Fig. 1</xref>), each of which contains several paths corresponding to alternative gene products. Intuitively, <italic>de novo</italic> transcriptome assembly could be performed for every connected sub-graph separately. In the case of genome-guided transcriptome assembly, generation of sub-graphs is directed by the reference genome.</p>
<fig id="fig1" position="float" orientation="portrait" fig-type="figure"><label>Figure 1 |</label><caption><p>A few selected de Bruijn graphs of transcripts from whitefly RNA-Seq data. Each node represents one of the unique k-mers present in the input reads, and the edges represent <italic>suffix-to-prefix</italic> overlap between k-mers. Examples of branching and looping are visible (data source: <ext-link ext-link-type="uri" xlink:href="http://evomics.org/learning/genomics/trinity">http://evomics.org/learning/genomics/trinity</ext-link>).</p></caption><graphic xlink:href="149948_fig1.tif"/></fig>
<p>In the absence of such a method for <italic>de novo</italic> assembly, however, most assemblers [<xref ref-type="bibr" rid="c15">15</xref>, <xref ref-type="bibr" rid="c20">20</xref>, <xref ref-type="bibr" rid="c22">22</xref>] work with all unique k-mers obtained from the input reads, resulting in the requirement for a large amount of available memory.</p>
<p>In this work, we present a reference-free method for generating connected sub-graphs from datasets of RNA-Seq reads. We employ the MapReduce formulation [<xref ref-type="bibr" rid="c30">30</xref>] for distributing the analysis of large datasets over many compute nodes. The MapReduce approach was popularized by Google for handling massively distributed queries, but has since been applied in a wide range of domains, including genome analysis [<xref ref-type="bibr" rid="c31">31</xref>-<xref ref-type="bibr" rid="c33">33</xref>]. A typical MapReduce implementation is based on <italic>map()</italic> and <italic>reduce()</italic> operations that work on a local subset of the data, but the power of the approach comes from an intermediate step called <italic>shuffle()</italic> or <italic>collate()</italic> which is responsible for re-distributing the data across the compute nodes. In the context of transcriptome assembly, the MapReduce approach distributes the sequence data over the available nodes, thus reducing the per-node memory requirement. The iterative application of <italic>map()</italic>, <italic>collate()</italic> and <italic>reduce()</italic> steps leads to clustering of the k-mers, such that the desired subgraphs are each physically located on a single compute node.</p>
<p>While distributing the sequence data across nodes of a compute cluster should lead to faster runtimes and reduced per-node memory requirements, this must be balanced against the cost of inter-node communication and transfer of data. We make use of an established MapReduce software library [<xref ref-type="bibr" rid="c34">34</xref>] that handles communication via the Message Passing Interface (MPI) protocol. Using this library, we have developed software that can cluster k-mers, and then launch multiple <italic>Inchworm</italic> jobs for the resulting sub-graphs. The procedure can be linked with the rest of the Trinity pipeline, for selected components of which we have also developed an MPI-based parallelisation [<xref ref-type="bibr" rid="c28">28</xref>], so that the entire assembly workflow can be run on a commodity cluster. Use of the MapReduce-MPI software library [<xref ref-type="bibr" rid="c34">34</xref>] means that specialised MapReduce installations such as Hadoop are not required. The only requirement is an MPI library, which is omnipresent on high performance computing platforms.</p>
</sec>
<sec id="s2"><title>Implementation</title>
<sec id="s2a"><title>MapReduce-MPI library</title>
<p>The MapReduce [<xref ref-type="bibr" rid="c30">30</xref>] programming paradigm consists of two core operations, namely a &#x201C;map&#x201D; operation followed by &#x201C;reduce&#x201D; operation. These are highly parallel operations working on distributed data, which wrap around an intermediate data-shuffling operation that requires inter-processor communication. The basic data structures for MapReduce operations are key/value (KV) pairs, and key/multivalue (KMV) pairs that consist of a unique key and a set of associated values. There are many implementations of the MapReduce idea, see for examples [<xref ref-type="bibr" rid="c35">35</xref>, <xref ref-type="bibr" rid="c36">36</xref>]. In the MapReduce-MPI library [<xref ref-type="bibr" rid="c34">34</xref>], which we utilise here, KV and KMV pairs are stored within MapReduce objects, and user defined algorithms consist of operations on these objects.</p>
<p>A typical algorithm using the MapReduce-MPI library is built upon three basic functions operating on MapReduce objects, namely <italic>map()</italic>, <italic>collate()</italic> and <italic>reduce().</italic> In <italic>map()</italic>, KV pairs are generated by reading data from files or processing existing KV pairs to create new ones. The <italic>collate()</italic> operation extracts unique keys and maps all the values associated with these keys to create KMV pairs. The <italic>reduce()</italic> operation processes KMV pairs to produce new KV pairs as input to the following steps of the algorithm. In a parallel environment, the <italic>map()</italic> and <italic>reduce()</italic> operations work on local data, while the <italic>collate()</italic> operation builds KMV pairs using values stored on all processors. Since KV pairs with the same key could be located on many different processors, there is a choice about where to store the resulting KMV pair. In the MapReduce-MPI library, each KMV pair is distributed onto a processor by hashing its key into a 32-bit value whose remainder modulo the number of processors is the owning processor rank.</p>
<p>The MapReduce-MPI library allows user-defined functions to be invoked for <italic>map()</italic> or <italic>reduce()</italic> operations, while the <italic>collate()</italic> operation and the general housekeeping of MapReduce objects are handled automatically. The <italic>map()</italic> and <italic>reduce()</italic> operations are called via pointers to functions supplied by the application program. Each user-defined function is invoked multiple times as a callback for each KV or KMV pair that is processed.</p>
<p><italic>Out-of-core</italic> processing is an important feature of the MapReduce-MPI library, and is initiated when KV or KMV pairs owned by a processor do not fit in the physical memory. When this happens, each processor writes one or more temporary files to disk and reads the data back in when required. Specifically, a <italic>pagesize</italic> is defined by the user, which is the maximum size of MapReduce objects that can be held in memory and used in MapReduce operations. This allows the MapReduce-library to handle data objects larger than the available memory, at the expense of additional I/O to disk, and we give examples later.</p>
</sec>
<sec id="s2b"><title>Finding Connected Components</title>
<p>A connected component of an undirected graph is a sub-graph where any two nodes are connected by a path of edges. A transcriptome can be represented as a k-mer graph with multiple <italic>connected components</italic>, where ideally the number of sub-graphs equals the number of genes (<xref ref-type="fig" rid="fig1">Fig. 1</xref>). The identification of connected components can be done using a depth-first search [<xref ref-type="bibr" rid="c37">37</xref>]. Starting from a seed node, the procedure searches for the entire connected component by repeatedly looping through neighbour nodes, and creates new paths between nodes as extensions of pre-existing paths.</p>
<p>The algorithm starts with the assignment of unique &#x201C;zone&#x201D; IDs to each graph node stored in a MapReduce object. In each iteration, the size of a zone may increase by one layer of its neighbours. As zone IDs between two nodes conflict by sharing edge, a winner is chosen and the losing nodes are then merged into the winning zone. When the final iteration is reached, all nodes in a connected component will have been assigned to the same zone, and the MapReduce object will contain the zone assignments for all fully connected components. More details of the algorithm and its implementation in the MapReduce-MPI library are given in [<xref ref-type="bibr" rid="c38">38</xref>]. For the current application, we need to define the nodes and edges of the full (disconnected) graph to be analysed, which we do in the next subsection.</p>
</sec>
<sec id="s2c"><title>MapReduce-Inchworm</title>
<p>We have implemented a multi-step procedure for clustering k-mers as the initial stages of transcriptome assembly in Trinity [<xref ref-type="bibr" rid="c22">22</xref>] (see <xref ref-type="fig" rid="fig2">Fig 2</xref>). In the first step, input sequence reads are decomposed into a list of unique k-mers, together with their abundances, as a single MapReduce cycle (Algorithm 1 in Supplementary Methods). In the second step, edges representing k-1 overlaps between k-mers are extracted in a single MapReduce operation (Algorithm 2). This pre-collection of edge information is an important feature of our algorithm. The third step filters out edges where a k-mer node has multiple candidates in the 3&#x2019; or 5&#x2019; directions, and is introduced to make the later <italic>Inchworm</italic> runs more robust (Algorithm 3). Inchworm builds contigs by extending a seed k-mer using the overlapping k-mer with the highest abundance, and extension continues until no more overlapping k-mers exist in the dataset. Our filtering step makes sure that the edge or edges with the highest abundance are kept in the cluster, and so available to Inchworm, while others are removed. Without this filtering operation, the subsequent step tends to produce k-mer clusters with highly diverse sizes, and leads to load balancing issues for high performance computing clusters. Having prepared the k-mer and k-mer overlap data, the fourth step (Algorithm 4) performs the k-mer clustering by finding connected components, as described above. The steps are described in detail in the Supplementary Methods 1.1.</p>
<fig id="fig2" position="float" orientation="portrait" fig-type="figure"><label>Figure 2|</label><caption><p>Workflow summarising the MapReduce-Inchworm algorithm. The steps are described in the main text and the Supplementary Methods. In this figure, <italic>V</italic> represents k-mer nodes with abundances <italic>C</italic>, <italic>E</italic> represents edges with abundances <italic>CE</italic>, and <italic>Z</italic> represents zone IDs.</p></caption><graphic xlink:href="149948_fig2.tif"/></fig>
<p>The original C&#x002B;&#x002B; code of <italic>Inchworm</italic> for constructing contigs is implemented as step 5 of the algorithm, and is executed as a callback function by each set of clustered k-mers (Algorithm 5). The input consists of two MapReduce objects, the zone assignment of k-mers from the previous step and the list of k-mers with their abundance values. These two input objects are concatenated into a single MapReduce object, followed by a <italic>collate()</italic> operation using k-mers as key. This creates KMV pairs with the k-mer as key and the pair of zone ID and abundance value as the multivalue. The following <italic>reduce()</italic> operation creates new KV pairs, this time with the zone ID as key and the corresponding pair of k-mer and abundance as the value. Another <italic>collate()</italic> operation with zone ID as key produces KMV pairs with each zone ID linked to a list of k-mer/abundant value pairs.</p>
<p>The final <italic>reduce()</italic> operation creates a <italic>hash_map</italic> table for each zone ID, i.e. for each cluster. This table has the k-mers <italic>V<sub>i</sub></italic> as keys and the abundance <italic>C<sub>i</sub></italic> as values. This <italic>hash_map</italic> table is an input to the <italic>Inchworm</italic> module, which constructs contigs for that cluster. The final <italic>collate()</italic> operation evenly distributes the k-mer clusters across the allocated nodes of the computer. Each compute node will then run multiple <italic>Inchworm</italic> jobs, according to the number of k-mer clusters residing on that compute node. The resulting files of Inchworm contigs can be merged for input to Chrysalis.</p>
</sec>
</sec>
<sec id="s3"><title>Results</title>
<p>This section presents our evaluation of MapReduce-Inchworm, in comparison to the original Inchworm. The primary aim of our work is to circumvent the high-memory requirements of the original Inchworm, while a secondary aim is to reduce the runtime required. It is vital, of course, that performance improvements do not lead to loss of accuracy, and so we begin by presenting a detailed characterization of the transcripts generated by the Trinity pipeline when MapReduce-Inchworm is used to generate the initial contigs. Next, we present performance results in terms of runtime and scalability, followed by results for the physical memory usage of MapReduce-Inchworm. Finally, we present a performance comparison using RNA-Seq datasets from several different organisms.</p>
<p>The datasets and computing resources used in our evaluations are listed in <xref ref-type="table" rid="tbl1">Table 1</xref>. The results presented here for MapReduce-Inchworm were obtained on an IBM iDataplex-Nextscale cluster, consisting of nodes with 2 x 12-core Intel Xeon processors and 64GB of RAM. For the original version of Inchworm, the code is necessarily run on a single node, albeit with multiple processors. For the mouse dataset, a single node of the iDataplex-Nextscale cluster was used. For the larger sugarbeet dataset, jobs were run on a high-memory (256GB) node of a slightly older iDataplex cluster. For the most complex transcriptome, the wheat dataset, ScaleMP software (<ext-link ext-link-type="uri" xlink:href="http://www.scalemp.com/">http://www.scalemp.com/</ext-link>) was used to create a virtual symmetric multiprocessing node on the iDataplex cluster to meet the high memory requirement of the original Inchworm.</p><table-wrap id="tbl1" position="float" orientation="portrait"><label>Table 1:</label><caption><p>RNA-Seq datasets and computing resources used for each RNA-Seq data.</p></caption>
<graphic xlink:href="149948_tbl1.tif"/>
</table-wrap>
<sec id="s3a"><title>Accuracy Assessment</title>
<p>To evaluate the accuracy of the MapReduce procedure, we compared the final transcripts generated by the Trinity pipeline when either the MapReduce-Inchworm or the original Inchworm is used. We focus on the final transcripts since these are the biologically relevant objects, while the intermediate contigs from each version of Inchworm can be quite different. We performed these tests using a mouse RNA-Seq dataset consisting of 105M pair-end reads taken from [<xref ref-type="bibr" rid="c22">22</xref>]. To generate additional datasets, we used the <italic>rsem-simulate-reads</italic> program from RSEM [<xref ref-type="bibr" rid="c39">39</xref>, <xref ref-type="bibr" rid="c40">40</xref>] to simulate RNA-Seq read data based on parameters learned from the real dataset. The simulation was done in 3 steps as follows. First, we ran Trinity (using the original Inchworm) on the downloaded set of reads to produce 80,867 transcripts. These transcripts act as the set of <italic>reference transcripts</italic> for our trials. Second, RSEM was executed using the mouse RNA-Seq data together with the <italic>reference transcripts</italic> to obtain parameters for simulation of RNA-Seq reads. Third, RNA-Seq read data was simulated by executing <italic>rsem-simulate-reads</italic> with the <italic>reference transcripts</italic> and parameters from the previous RSEM run. Three simulated datasets were generated consisting of 100M, 150M and 200M pair-end reads, compared to the original experimental dataset with 105M pair-end reads, and contain approximately 5&#x0025; background reads.</p>
<p>We ran both versions of <italic>Inchworm</italic> on the three simulated datasets to produce Fasta-formatted files of Inchworm contigs. The remainder of the Trinity pipeline was run from these Inchworm contigs, producing two sets of transcripts derived from MapReduce-Inchworm and the original Inchworm. The REF-EVAL module from DETONATE [<xref ref-type="bibr" rid="c41">41</xref>] was used to assess both sets against the &#x201C;reference transcripts&#x201D;, giving assembly recall and precision scores for each version of the transcriptome. Initially, all significant local alignments between assembled transcripts and reference transcripts are found using BLAT [<xref ref-type="bibr" rid="c42">42</xref>]. At the contig level, REF-EVAL counts the number of transcripts that align with at least a predefined level of accuracy in a one-to-one mapping. We varied the required level of accuracy to get a range of statistics. At the nucleotide level, it counts the number of correctly assembled nucleotides without requiring &#x201C;one-to-one&#x201D; mapping; that is, it takes partially assembled transcripts into account as true positives. Recall is defined as the fraction of reference transcripts that are correctly recovered by an assembly. Precision is defined as the fraction of assembled transcripts that correctly recover a reference transcript.</p>
<p>We also evaluated the two quantities N1 and N2, as given by the analysis script <italic>FL_trans_analysis_pipeline.pl</italic> distributed with the Trinity software. This tool looks at the alignment of reconstructed transcripts onto the set of reference transcripts. If at least 99&#x0025; of a reconstructed transcript is aligned to the reference, and the aligned sections have at least 99&#x0025; identity, then it is considered a full-length match. The focus is on the quality of the reconstructed transcript, rather than recovery of the reference transcripts (cf. REF-EVAL above). The N1 statistic represents the total number of assembled transcripts that give full-length matches to the reference. The N2 statistic represents the number of assembled transcripts that align to multiple reference transcripts, and are thus <italic>fused</italic> transcripts.</p>
<p>The results (<xref ref-type="table" rid="tbl2">Table 2</xref>) show that Trinity run with MapReduce-Inchworm gives consistently higher values for Recall, Precision and N1 for the three simulated datasets. The number of fused transcripts, given by N2, is also lower. Thus, parallelisation of the initial step in the Trinity pipeline actually leads to a slight increase in assembly accuracy. In fact, the improvement of Recall and Precision at the nucleotide level is only marginal, and the absolute values are close to 1.0, indicating that both versions of Inchworm lead to transcripts that are highly similar to the reference transcripts. Recall and Precision at the contig level are lower, roughly in line with the N1 values, indicating small differences in the transcripts that lead to some reference transcripts not being fully recovered or matched. In this case, the MapReduce-Inchworm leads to a more significant improvement.</p>
<table-wrap id="tbl2" position="float" orientation="portrait"><label>Table 2:</label><caption><p>Accuracy assessment of MapReduce-Inchworm compared to the original Inchworm using three simulated read datasets for mouse RNA-Seq</p></caption>
<graphic xlink:href="149948_tbl2.tif"/>
</table-wrap>
<p><xref ref-type="fig" rid="fig3">Fig. 3(a)</xref> and <xref ref-type="fig" rid="fig3">3(c)</xref> show the variation of the Recall and Precision statistics at the contig level, as a function of required alignment accuracy, for the simulated dataset with 100M reads. If the cutoff is reduced from 99&#x0025; to 90&#x0025;, so that transcripts align with high but not complete overlap, then most of the reference transcripts can be recovered from the simulated dataset. Although the absolute numbers are similar, MapReduce-Inchworm gives higher values of Recall and Precision for all cutoffs.</p>
<fig id="fig3" position="float" orientation="portrait" fig-type="figure"><label>Figure 3 |</label><caption><p>Assessment of the reconstruction accuracy of MapReduce-Inchworm (red bars) compared to the original Inchworm program (light blue bars), as given by the REF-EVAL tool of DETONATE [<xref ref-type="bibr" rid="c41">41</xref>]. Plots (a) and (c) give results for the dataset of 100M simulated pair-end reads (see main text), while plots (b) and (d) give the corresponding results for the original mouse RNA-Seq dataset of experimental reads. Plots (a) and (b) show the Recall statistic, which is the fraction of reference transcripts that are correctly recovered by an assembly. Plots (c) and (d) show the Precision statistic, which is the fraction of assembled transcripts that correctly recover a reference transcript Recovery of a reference transcript by a particular assembly is measured at the &#x201C;contig&#x201D; level, which requires almost complete alignment in a one-to-one mapping between the assembly and the reference. Each plot is given as a function of the alignment cutoff used to identify a recovered transcript.</p></caption><graphic xlink:href="149948_fig3.tif"/></fig>
<p>With the simulated data, we are testing the ability of Trinity to recover the transcripts from which the simulated reads were generated. As a further test, we used REF-EVAL to compare the transcript sets that we generate to a mouse transcriptome downloaded from the UCSC genome-browser database. We used the CruzDB programmatic interface [<xref ref-type="bibr" rid="c43">43</xref>] to obtain a set of 22,403 coding transcripts. Statistics for the two sets of transcripts are given <xref ref-type="table" rid="tbl3">Table 3</xref>, and the similarity between them is quantified in <xref ref-type="table" rid="tbl4">Table 4</xref>. Specifically, we compared transcripts generated from the downloaded set of 105M pair-end reads using Trinity run with MapReduce-Inchworm and the original Inchworm.</p>
<table-wrap id="tbl3" position="float" orientation="portrait"><label>Table 3:</label><caption><p>Basic statistics of Trinity transcripts using original Inchworm and MapReduce-Inchworm using the mouse RNA-seqdata [<xref ref-type="bibr" rid="c22">22</xref>].</p></caption>
<graphic xlink:href="149948_tbl3.tif"/>
</table-wrap>
<table-wrap id="tbl4" position="float" orientation="portrait"><label>Table 4:</label><caption><p>The number of similar Trinity transcripts between original Inchworm and MapReduce-Inchworm using the mouse RNA-seq data [<xref ref-type="bibr" rid="c22">22</xref>].</p></caption>
<graphic xlink:href="149948_tbl4.tif"/>
</table-wrap>
<p>Results for contig-level Recall and Precision are shown in <xref ref-type="fig" rid="fig3">Fig. 3(b)</xref> and <xref ref-type="fig" rid="fig3">3(d)</xref>, as a function of the required alignment accuracy. The Recall is generally lower than for the simulated datasets, as the read data used probably doesn&#x2019;t have the coverage to fully explain the UCSC transcriptome. Nevertheless, the Recall does approach 1.0 when the required accuracy is relaxed. The Precision also improves as the required alignment accuracy is relaxed, but remains less than 0.5 reflecting the fact that some of the read data used derives from transcripts not included in the UCSC set of coding transcripts. In the context of the current study, it is reassuring to see that again the MapReduce-Inchworm approach gives slightly improved statistics in most cases, compared to the original Inchworm (<xref ref-type="table" rid="tbl5">Table 5</xref>).</p>
<table-wrap id="tbl5" position="float" orientation="portrait"><label>Table 5:</label><caption><p>Comparison of mouse transcripts assembled using MapReduce-Inchworm or the original Inchworm with a reference mouse transcriptome.</p></caption>
<graphic xlink:href="149948_tbl5.tif"/>
</table-wrap>
<p>We believe that the reason for the slightly improved accuracy of MapReduce-Inchworm is the inclusion of additional edge information, which is obtained in step 2 of the procedure from pairs of k-mers appearing consecutively in input reads (see Methods). With this edge information, MapReduce-Inchworm clusters k-mers into multiple groups, each of which should contain k-mers from same gene. Inchworm contigs are constructed within each cluster, and the output is implicitly guided by the input reads via this initial segregation. On the other hand, the original Inchworm uses all unique k-mers extracted from the input reads, and the construction of Inchworm contigs is done without any additional supporting information from the input reads. Both methods produce a similar total number of Inchworm contigs (data not shown), but there are clearly differences in the resulting transcripts.</p>
</sec>
<sec id="s3b"><title>Runtime Improvement</title>
<p><xref ref-type="fig" rid="fig4">Fig. 4</xref> shows the scaling of the MapReduce-Inchworm runtime with increasing number of compute nodes, for the experimental mouse dataset. Plots are displayed for different choices of the <italic>pagesize</italic> parameter, which determines the physical memory usage (see the <italic>MapReduce-MPI library</italic> section in Methods for a detailed explanation). For each plot, the runtime of the original <italic>Inchworm</italic> (5431 seconds) is displayed as a dashed line for comparison. The number of compute nodes was varied from 32 to 192, with each node running a single MPI process, while the <italic>pagesize</italic> was varied from 1 GB to 4 GB. The runtimes obtained using all 192 compute nodes are 1093, 1067, 1034, and 1034 seconds for the four choices of <italic>pagesize</italic>, corresponding to a speed-up by a factor of about 5 compared to the original Inchworm.</p>
<fig id="fig4" position="float" orientation="portrait" fig-type="figure"><label>Figure 4 |</label><caption><p>Scaling of the runtime of MapReduce-Inchworm (black lines, left-hand axis) as a function of the number of compute nodes used, for the experimental mouse dataset (see <xref ref-type="table" rid="tbl1">Table 1</xref>). The runtime is for the MapReduce-Inchworm step only, and does not include the remainder of the Trinity pipeline. The runtime of the corresponding serial Inchworm is shown as a horizontal dashed line. Results are shown with <italic>pagesize</italic> set to (a) 1 GB, (b) 2 GB, (c) 3 GB and (d) 4 GB. The cumulative I/O to disk, due to out-of-core processing, is also shown (blue line, right-hand axis).</p></caption><graphic xlink:href="149948_fig4.tif"/></fig>
<p>There are also speed-ups for smaller numbers of compute nodes, except for the cases of 32 nodes with a <italic>pagesize</italic> parameter of 1 or 2 GB. In these cases, the memory requirements exceed the chosen <italic>pagesize</italic> leading to significant &#x201C;out-of-core&#x201D; processing (see Methods). The cumulative file I/O (Tb) is also plotted in <xref ref-type="fig" rid="fig4">Fig. 4</xref>, which confirms the significant paging to disk in these cases. Thus, the <italic>pagesize</italic> setting should be large enough (within the constraints of the available physical memory) or the number of nodes large enough (in order to distribute the memory requirements), otherwise there is an adverse effect on the runtime.</p>
<p>We stratified the runtime in terms of the major steps in both versions of <italic>Inchworm</italic>, as shown in <xref ref-type="fig" rid="fig5">Fig. 5</xref>. The original <italic>Inchworm</italic> consists of 3 principal steps: 1) <italic>jellyfish</italic>, 2) <italic>parsing k-mers</italic>, and 3) <italic>inchworm contig construction.</italic> The first step involves counting the occurrence of every unique k-mer in the set of input reads using the program Jellyfish [<xref ref-type="bibr" rid="c44">44</xref>], and writing the output to a disk file. In the second step, <italic>Inchworm</italic> reads the output file back into physical memory by storing each k-mer and its count into a hashmap table as a key-value pair. In the final step, the algorithm creates draft contigs using the hashmap table of unique k-mers. We divide the MapReduce-Inchworm algorithm into an initial <italic>splitting input reads</italic> step, followed by the five steps described in Methods. The initial step consists of evenly splitting the input file of reads into multiple files, according to the number of allocated compute nodes. Each file is then read into a compute node in preparation for subsequent steps.</p>
<fig id="fig5" position="float" orientation="portrait" fig-type="figure"><label>Figure 5 |</label><caption><p>Stratification of the runtime in terms of individual steps within both versions of Inchworm, for the experimental mouse dataset (see <xref ref-type="table" rid="tbl1">Table 1</xref>). 0I represents Original Inchworm; MR represents MapReduce-Inchworm. On the X-axis, <italic>original</italic> represents the original version of Inchworm, while 32-192 represent the numbers of compute nodes allocated for MapReduce-Inchworm. The original Inchworm is divided into three steps: step1 corresponds to <italic>Jellyfish</italic> [<xref ref-type="bibr" rid="c44">44</xref>]; step 2 corresponds to <italic>parsing kmers;</italic> and step3 corresponds to <italic>Inchworm contig construction.</italic> MapReduce-Inchworm is divided into six steps: an initial step for <italic>splitting input reads</italic> and steps 1-5. The initial step splits an input file (containing the RNA-Seq reads) into multiple files according to the number of allocated compute nodes. Steps 1 to 5 of the main algorithm are described in detail in Methods. Results are given with <italic>pagesize</italic> assigned to 2GB, cf <xref ref-type="fig" rid="fig3">Figure 3(b)</xref>.</p></caption><graphic xlink:href="149948_fig5.tif"/></fig>
<p><xref ref-type="fig" rid="fig5">Fig. 5</xref> shows that the first two steps of the original Inchworm, which could be categorised as k-mer preparation steps, take a significant fraction of the total runtime. These steps are equivalent to the <italic>splitting input reads</italic> and step 1 of MapReduce-Inchworm. The latter steps are however much quicker because they avoid storing k-mers on disc. The remaining runtime of the original Inchworm involves construction of contigs. In the MapReduce-Inchworm implementation, this is done individually for each cluster, and is very fast (MR: step 5 in <xref ref-type="fig" rid="fig5">Fig. 5</xref>). The bulk of the runtime for MapReduce-Inchworm is taken by the clustering algorithm (MR: step 4 in <xref ref-type="fig" rid="fig5">Fig. 5</xref>), and this scales well with the number of nodes used. As mentioned above, super-linear scaling is achieved in going from 32 nodes to 64 nodes because of the reduction in out-of-core processing, while going from 64 to 128 nodes gives a speedup of 1.9, and from 64 to 192 nodes a speedup of 2.6.</p>
</sec>
<sec id="s3c"><title>Physical Memory Requirement</title>
<p>The main objective of our work is to remove the need for large shared memory, by distributing the overall memory requirement over multiple computer nodes. With the ability to do that, the per-node memory requirement can always be reduced by adding more compute nodes, albeit with the expense of increased inter-node communication. The physical memory available on each node is controlled by the <italic>pagesize</italic> parameter in the underlying MapReduce-MPI library. In this section, we look at the memory requirements of MapReduce-Inchworm, as a function of the number of compute nodes and the <italic>pagesize</italic> parameter.</p>
<p>Firstly, we assessed the memory requirements as a function of the number of allocated compute nodes, using the mouse dataset (see <xref ref-type="table" rid="tbl1">Table 1</xref>). Within the 5 main steps of MapReduce-Inchworm, we collected the number of KV/KMV pairs generated from each of the three basic MapReduce functions: <italic>map, collate</italic>, or <italic>reduce.</italic> These values were converted into data object sizes in GB, and averaged over all compute nodes. <xref ref-type="fig" rid="fig6">Fig. 6(a)</xref> shows that the data size per compute node, and hence the memory requirement, decreases with increasing number of nodes, as expected. The values for step 4 are also averaged over the iterations of the k-mer clustering algorithm, of which there are 47 for the mouse dataset. The figure shows clearly that step 2 of the MapReduce algorithm, which extracts edges from the input read data, is the most memory demanding.</p>
<fig id="fig6" position="float" orientation="portrait" fig-type="figure"><label>Figure 6 |</label><caption><p>Data objects created by MapReduce-Inchworm for the experimental mouse dataset (see <xref ref-type="table" rid="tbl1">Table 1</xref>). (a) The size of data objects generated by each MapReduce function on each compute node, as calculated from the number of KV/KMV pairs involved. The data sizes for each MapReduce function (<italic>map()</italic>, <italic>collate()</italic>, and <italic>reduce()</italic> were averaged over nodes and iterations within each of the 5 main steps of MapReduce-Inchworm. (b-e) The corresponding cumulative I/O to disk, due to out-of-core processing, per compute node. Results are shown with <italic>pagesize</italic> set to: (b) 1 GB, (c) 2 GB, (d) 3 GB and (e) 4 GB. For all graphs, the Y-axis gives the data size in GB.</p></caption><graphic xlink:href="149948_fig6.tif"/></fig>
<p>The values in <xref ref-type="fig" rid="fig6">Fig. 6(a)</xref> give an estimate of the per-node memory requirements of MapReduce-Inchworm. When these exceed the physical memory allocated according to the <italic>pagesize</italic> parameter, then pages of data are written as temporary files on disk. Paging for each of the steps is shown in <xref ref-type="fig" rid="fig6">Fig. 6(b)-(e)</xref> for four choices of the <italic>pagesize</italic> parameter. For example, the data sizes of KV pairs obtained from the <italic>map</italic> operation of step 2 are 11.0&#x007E;GB, 5.5&#x007E;GB, 2.75&#x007E;GB and 1.83&#x007E;GB when run on 32, 64, 128 and 192 nodes respectively (see <xref ref-type="fig" rid="fig6">Fig. 6(a)</xref>). For a small <italic>pagesize</italic> of 1 GB (<xref ref-type="fig" rid="fig6">Fig. 6(b)</xref>), there is always some out-of-core processing. Increasing the <italic>pagesize</italic> to 2 GB (<xref ref-type="fig" rid="fig6">Fig. 6(c)</xref>) means that, in the case of 192 compute nodes, the KV pairs can fit in memory and there is no paging. Increasing the <italic>pagesize</italic> to 3 GB (<xref ref-type="fig" rid="fig6">Fig. 6(d)</xref>) means that out-of-core processing is eliminated when using 128 or 192 compute nodes. However, there is always paging for the smaller compute clusters considered, even for the largest tested <italic>pagesize</italic> of 4 GB. Out-of-core processing in the <italic>map</italic> operation of step 2 initiates <italic>out-of-core</italic> processing in the following <italic>collate</italic> step, because the KV pairs written to disk by the <italic>map</italic> operation need to be read back for the <italic>collate</italic> step. <xref ref-type="fig" rid="fig6">Fig. 6(b)-(e)</xref> shows that file I/O occurs for the <italic>collate</italic> operation of step 2 whenever it is present for the <italic>map</italic> operation. It also shows that total I/O is substantially higher for the <italic>collate</italic> operation. This arises because the core <italic>collate</italic> algorithm needs to cycle through the KV pairs multiple times, as it finds matches and builds up the KMV objects, necessitating multiple reading and writing of pages to disk. Thus, step 2 of the MapReduce algorithm is particularly sensitive to the choice of the <italic>pagesize</italic> parameter. On the other hand, <xref ref-type="fig" rid="fig5">Fig. 5</xref> shows that the runtime is dominated by step 4, and so the performance hit caused by paging in step 2 is perhaps not so important.</p>
<p>The underlying MapReduce-MPI library tends to evenly distribute the KMV pairs produced by <italic>collate</italic> operations by hashing each of its key for assignment onto available MPI-processors. In the present application, where the number of KMV pairs is much larger than the number of compute nodes, this is expected to lead to good load balancing. In fact, the minimum and maximum values for data size over all compute nodes are indistinguishable from the average values shown in <xref ref-type="fig" rid="fig6">Fig. 6(a)</xref>.</p>
</sec>
<sec id="s3d"><title>Performance comparison for RNA-Seq datasets from complex organisms</title>
<p>We next tested our approach on some more challenging RNA-Seq datasets obtained from sugarbeet and wheat samples, see <xref ref-type="table" rid="tbl1">Table 1</xref>. The memory requirement of the original <italic>Inchworm</italic> depends on the transcriptome complexity and is expected to roughly correlate with the number of unique k-mers from the input reads. <xref ref-type="fig" rid="fig7">Fig. 7(a)</xref> shows that the mouse, sugarbeet and wheat datasets require 46.7GB, 141.5GB and 373.9GB of memory respectively, and these values do indeed correlate with the total number of unique k-mers listed in <xref ref-type="table" rid="tbl1">Table 1</xref>. In fact, the required memory for the wheat dataset exceeded the physical memory on any single node of our available compute platforms. In order to run the original <italic>Inchworm</italic>, we used ScaleMP software (<ext-link ext-link-type="uri" xlink:href="http://www.scalemp.com/">http://www.scalemp.com/</ext-link>) to aggregate 32 nodes, each providing 128GB memory, to create a vSMP node with a 4TB address space.</p>
<fig id="fig7" position="float" orientation="portrait" fig-type="figure"><label>Figure 7 |</label><caption><p>(a) High-water mark for memory usage in GB over all compute nodes, (b) runtime in minutes, and (c) cumulative I/O in TB. Results are given for the mouse, sugarbeet and wheat datasets described in <xref ref-type="table" rid="tbl1">Table 1</xref>, and using the computing resources listed. All jobs with MapReduce-Inchworm used a 4GB <italic>pagesize</italic> parameter. Bars marked <italic>original</italic> represent runs of the original Inchworm, MR-64 represents runs of MapReduce-Inchworm using 64 compute nodes, MR-128 represents runs using 128 compute nodes, and MR-192 represents runs using 192 compute nodes.</p></caption><graphic xlink:href="149948_fig7.tif"/></fig>
<p><xref ref-type="fig" rid="fig7">Fig. 7(b)</xref> shows the total runtime to produce <italic>Inchworm</italic> contigs for <italic>MapReduce-Inchworm</italic>, compared with a run using the original <italic>Inchworm.</italic> With 64 compute nodes available, the <italic>MapReduce-Inchworm</italic> procedure yields a faster runtime, and increasing the number of nodes to 128 or 192 gives further improvements. Although we have only tested a small range of node counts, the scaling of the speedup is very good, suggesting that more nodes could be used. For example, tripling the number of nodes from 64 to 192 yields speedups of 2.4, 1.9 and 2.9 for mouse, sugarbeet and wheat respectively. The original <italic>Inchworm</italic> is particularly slow for the wheat dataset, taking over 6 days, because of the use of ScaleMP to provide the required amount of shared memory. While ScaleMP was required to be able to process the wheat dataset at all, its software-based aggregation of memory clearly incurs a significant overhead. Such problems are avoided in the distributed memory implementation of <italic>MapReduce-Inchworm.</italic></p>
<p><xref ref-type="fig" rid="fig7">Fig. 7(c)</xref> shows the cummulative I/O for the runs using <italic>MapReduce-lnchworm</italic>, reflecting the <italic>out-of-core</italic> processing of MapReduce-MPI. The wheat dataset, with 1.5&#x007E;billion input reads and 5.8&#x007E;billion unique k-mers, is particularly large and the MapReduce objects do not fit into the aggregate physical memory. Even with 192 nodes, there is 45TB of I/O over the course of the run. This could be reduced by allocating further compute nodes, or by using higher memory nodes that could accommodate a larger pagesize. For the smaller sugarbeet dataset, the situation is much better, but there is nevertheless still a small amount of paging to disk.</p>
<p>In conclusion, the <italic>MapReduce-lnchworm</italic> procedure scales well to large and complex datasets. Increasing the number of compute nodes leads to a reduction in runtime, and reduced paging to disk as the per-node memory requirements are lowered. In particular, <italic>MapReduce-lnchworm</italic> allowed us to process the large wheat dataset in less than a day, while the original <italic>Inchworm</italic> required an advanced platform solution to run at all.</p>
</sec>
</sec>
<sec id="s4"><title>Discussion</title>
<p>In this study, we enabled the parallelization of the <italic>Inchworm</italic> module of Trinity by using a MapReduce-based approach to pre-cluster the k-mers obtained from the input reads. An instance of <italic>Inchworm</italic> is run on each k-mer cluster, yielding a set of contigs per cluster. Contigs from all clusters are pooled together and passed to the <italic>Chrysalis</italic> module for re-clustering according to the original Trinity scheme. The <italic>Inchworm</italic> module of Trinity is known to be the most memory-intensive step [<xref ref-type="bibr" rid="c28">28</xref>], and is often a barrier to processing large or complex RNA-Seq datasets. In our scheme, the computational load is passed to the pre-clustering step, where the well-established MapReduce procedure allows the load to be distributed over a commodity compute cluster. Our approach is distinct from other recent developments, which seek to MPI-parallelise <italic>Inchworm</italic> itself (Brian Haas, personal communication).</p>
<p>Pell et al. [<xref ref-type="bibr" rid="c45">45</xref>] have introduced a Bloom filter which provides memory efficient storage of kmer graphs. Chikhi and Rizk [<xref ref-type="bibr" rid="c46">46</xref>] added an additional data structure holding the false positives which might arise through trial kmer extensions, as well as a marking structure holding complex nodes for use in graph traversal. In contrast, we store an explicit list of kmer nodes and edges in a set of MapReduce objects. There is no reduction in the total memory required, but rather we focus on the ability to distribute these MapReduce objects over a large number of nodes to reduce the per node memory requirement. Note that by storing edges explicitly, we do not make trial extensions from kmer nodes, which can lead to false edges in the Bloom filter method.</p>
<p>We expect that there should be a correspondence between the k-mer clusters we generate, and the contig clusters (<italic>components</italic>) produced by <italic>Chrysalis</italic>, in that they both relate to a set of gene products. It may be that further efficiency gains can be achieved by merging these steps, but we have not investigated this possibility in the current work, adopting instead a conservative approach. If, for example, reads from a transcribed gene yield two k-mer clusters, and hence two sets of <italic>Inchworm</italic> contigs, then the <italic>Chrysalis</italic> module should in principle find <italic>welds</italic> between them, and recover the correct graph.</p>
<p>The assessment of the assembly accuracy using simulated and experimental RNA-Seq datasets shows that our parallelized <italic>Inchworm</italic> provides the final transcripts from the Trinity pipeline with marginally more accuracy compared to the original inchworm. The difference in accuracy comes from the utilization of additional edge information in MapReduce-Inchworm, which clusters k-mers guided by edge objects which link pairs of k-mers appearing consecutively in input reads. On the other hand, the original <italic>Inchworm</italic> constructs contigs directly from the set of all k-mers. Contigs are extended by searching for appropriately overlapping k-mers, rather than using pre-calculated edges. This pre-collection of edge information is feasible in our approach because of the distributed nature of the algorithm.</p>
<p>We have presented performance results for a range of experimental read datasets. The total runtime required to produce the complete set of <italic>Inchworm</italic> contigs could be reduced below that required for the original <italic>Inchworm</italic>, provided a moderate number of compute nodes are available. It may be debatable whether this is necessary for small datasets, such as the mouse dataset included here, but there are clearly significant gains for larger and more complex datasets (<xref ref-type="fig" rid="fig7">Fig. 7</xref>). More importantly, the memory requirement on each node can be reduced by distributing the job over sufficient nodes. In this way, commodity compute clusters can be used, and there is no need for high memory nodes or specialised solutions for aggregating node memory into a single address space.</p>
</sec>
<sec id="s5"><title>Conclusion</title>
<p>The results of this study indicate that the MapReduce framework has great potential for processing high throughput sequencing datasets more efficiently. The proposed approach could be applied as a pre-processing step for other <italic>de novo</italic> transcriptome assemblers, by implementing the chosen assembly code as a callback function in the final <italic>reduce()</italic> step, as we have done for <italic>Inchworm</italic> in the current study. Specifically, we plan to investigate the parallelization of Oases [<xref ref-type="bibr" rid="c15">15</xref>] and SOAPdenovo-Trans [<xref ref-type="bibr" rid="c20">20</xref>] via this approach. It is also worth exploring the feasibility of the pre-clustering approach for <italic>de novo</italic> metagenome and metatranscriptome assembly, which is more complex due to the presence of multiple genomes or transcriptomes from different species. For example, the <italic>de novo</italic> metagenome assembler [<xref ref-type="bibr" rid="c47">47</xref>] starts by partitioning the <italic>de Bruijn</italic> graph into isolated components corresponding to different species. Then for each component, it reconstructs the slight variants of the genomes of subspecies within the same species using multiple sequence alignments. A similar approach has been developed for <italic>de novo</italic> metatransciptome assembly [<xref ref-type="bibr" rid="c48">48</xref>]. Our proposed approach could be adapted to these pipelines to provide a memory-efficient method for the initial partitioning.</p>
<p>In conclusion, we have presented a computationally efficient method for clustering k-mers derived from RNA-Seq datasets. Applied to the Trinity pipeline, the approach avoids the large memory requirements of the original Inchworm, enabling the analysis of large datasets on commodity compute clusters. We expect that this general approach will have applications for other assembly problems.</p>
</sec>
</body>
<back>
<sec id="s6"><title>Declarations</title>
<ack><title>Acknowledgement</title>
<p>We would like to thank Brian Haas of the Broad Institute for his advice on the Trinity software and source code. We thank Keywan Hassani-Pak of Rothamsted Research, UK for providing the sugarbeet and wheat datasets, as well as many useful discussions. We thank Steve Plimpton for making the MapReduce-MPI library freely available, and for answering technical questions on its use. We also wish to acknowledge the Hartree Centre at the STFC Daresbury Laboratory, UK for providing the computational resources used for this work.</p>
</ack>
<sec id="s6a"><title>Authors&#x2019; contributions</title>
<p>CSK and MDW conceived the study. CSK implemented the method. CSK and MDW designed the research. All authors analysed the data. The benchmarking and repository maintenance were done by CSK and MDW. All authors wrote, read and approved the final manuscript.</p>
</sec>
<sec id="s6b"><title>Availability of material</title>
<p>The code used in this study is available at <ext-link ext-link-type="uri" xlink:href="http://https://github.com/kimosaby2001/MR-Inchworm/">https://github.com/kimosaby2001/MR-Inchworm/</ext-link>.</p>
</sec>
<sec id="s6c"><title>Consent for publication</title>
<p>Not applicable.</p>
</sec>
<sec id="s6e" sec-type="COI-statement"><title>Competing interests</title>
<p>The authors declare that they have no competing interests.</p>
</sec>
<sec id="s6f"><title>Ethics approval and consent to participate</title>
<p>Not applicable.</p>
</sec>
<sec id="s6g"><title>Funding</title>
<p>This work was internally funded by the Hartree Centre at STFC Daresbury Laboratory.</p>
</sec>
</sec>
<ref-list><title>Reference</title>
<ref id="c1"><label>1.</label> <mixed-citation publication-type="journal"><string-name><surname>Corney</surname> <given-names>DC</given-names></string-name>: <article-title>RNA-Seq using next generation sequencing</article-title>. <source>Materials and Methods</source> <year>2013</year>, <volume>3</volume>:<fpage>203</fpage>.</mixed-citation></ref>
<ref id="c2"><label>2.</label> <mixed-citation publication-type="journal"><string-name><surname>Schliesky</surname> <given-names>S</given-names></string-name>, <string-name><surname>Gowik</surname> <given-names>U</given-names></string-name>, <string-name><surname>Weber</surname> <given-names>APM</given-names></string-name>, <string-name><surname>Brautigam</surname> <given-names>A</given-names></string-name>: <article-title>RNA-Seq Assembly - Are We There Yet?</article-title> <source>Front Plant Sci</source> <year>2012</year>, <volume>3</volume>:<fpage>220</fpage>.</mixed-citation></ref>
<ref id="c3"><label>3.</label> <mixed-citation publication-type="journal"><string-name><surname>Oshlack</surname> <given-names>A</given-names></string-name>, <string-name><surname>Robinson</surname> <given-names>MD</given-names></string-name>, <string-name><surname>Young</surname> <given-names>MD</given-names></string-name>: <article-title>From RNA-Seq reads to differential expression results</article-title>. <source>Genome Biology</source> <year>2010</year>, <volume>11</volume>:<fpage>220</fpage>.</mixed-citation></ref>
<ref id="c4"><label>4.</label> <mixed-citation publication-type="journal"><string-name><surname>Gunaratne</surname> <given-names>PH</given-names></string-name>, <string-name><surname>Coarfa</surname> <given-names>C</given-names></string-name>, <string-name><surname>Soibam</surname> <given-names>B</given-names></string-name>, <string-name><surname>Tandon</surname> <given-names>A</given-names></string-name>: <article-title>miRNA data analysis: next-gen sequencing</article-title>. <source>Methods Mol Biol</source> <year>2012</year>, <volume>822</volume>:<fpage>273</fpage>-<lpage>288</lpage>.</mixed-citation></ref>
<ref id="c5"><label>5.</label> <mixed-citation publication-type="journal"><string-name><surname>Ulitsky</surname> <given-names>I</given-names></string-name>, <string-name><surname>Bartel</surname> <given-names>DP</given-names></string-name>: <article-title>lincRNAs: genomics, evolution, and mechanisms</article-title>. <source>Cell</source> <year>2013</year>, <volume>154</volume>:<fpage>26</fpage>-<lpage>46</lpage>.</mixed-citation></ref>
<ref id="c6"><label>6.</label> <mixed-citation publication-type="journal"><string-name><surname>Memczak</surname> <given-names>S</given-names></string-name>, <string-name><surname>Jens</surname> <given-names>M</given-names></string-name>, <string-name><surname>Elefsinioti</surname> <given-names>A</given-names></string-name>, <string-name><surname>Torti</surname> <given-names>F</given-names></string-name>, <string-name><surname>Krueger</surname> <given-names>J</given-names></string-name>, <string-name><surname>Rybak</surname> <given-names>A</given-names></string-name>, <string-name><surname>Maier</surname> <given-names>L</given-names></string-name>, <string-name><surname>Mackowiak</surname> <given-names>SD</given-names></string-name>, <string-name><surname>Gregersen</surname> <given-names>LH</given-names></string-name>, <string-name><surname>Munschauer</surname> <given-names>M</given-names></string-name>, <etal>et al</etal>: <article-title>Circular RNAs are a large class of animal RNAs with regulatory potency</article-title>. <source>Nature</source> <year>2013</year>, <volume>495</volume>:<fpage>333</fpage>-<lpage>338</lpage>.</mixed-citation></ref>
<ref id="c7"><label>7.</label> <mixed-citation publication-type="journal"><string-name><surname>Reddy</surname> <given-names>ASN</given-names></string-name>, <string-name><surname>Rogers</surname> <given-names>MF</given-names></string-name>, <string-name><surname>Richardson</surname> <given-names>DN</given-names></string-name>, <string-name><surname>Hamilton</surname> <given-names>M</given-names></string-name>, <string-name><surname>Ben-Hur</surname> <given-names>A</given-names></string-name>: <article-title>Deciphering the plant splicing code: experimental and computational approaches for predicting alternative splicing and splicing regulatory elements</article-title>. <source>Frontiers in Plant Science</source> <year>2012</year>, <volume>3</volume>.</mixed-citation></ref>
<ref id="c8"><label>8.</label> <mixed-citation publication-type="journal"><string-name><surname>Hooper</surname> <given-names>JE</given-names></string-name>: <article-title>A survey of software for genome-wide discovery of differential splicing in RNA-Seq data</article-title>. <source>Human Genomics</source> <year>2014</year>, <volume>8</volume>.</mixed-citation></ref>
<ref id="c9"><label>9.</label> <mixed-citation publication-type="journal"><string-name><surname>Morin</surname> <given-names>RD</given-names></string-name>, <string-name><surname>Bainbridge</surname> <given-names>M</given-names></string-name>, <string-name><surname>Fejes</surname> <given-names>A</given-names></string-name>, <string-name><surname>Hirst</surname> <given-names>M</given-names></string-name>, <string-name><surname>Krzywinski</surname> <given-names>M</given-names></string-name>, <string-name><surname>Pugh</surname> <given-names>TJ</given-names></string-name>, <string-name><surname>McDonald</surname> <given-names>H</given-names></string-name>, <string-name><surname>Varhol</surname> <given-names>R</given-names></string-name>, <string-name><surname>Jones</surname> <given-names>SJM</given-names></string-name>, <string-name><surname>Marra</surname> <given-names>MA</given-names></string-name>: <article-title>Profiling the HeLa S3 transcriptome using randomly primed cDNA and massively parallel short-read sequencing</article-title>. <source>Biotechniques</source> <year>2008</year>, <volume>45</volume>:<fpage>81</fpage>-<lpage>94</lpage>.</mixed-citation></ref>
<ref id="c10"><label>10.</label> <mixed-citation publication-type="journal"><string-name><surname>Wang</surname> <given-names>ET</given-names></string-name>, <string-name><surname>Sandberg</surname> <given-names>R</given-names></string-name>, <string-name><surname>Luo</surname> <given-names>S</given-names></string-name>, <string-name><surname>Khrebtukova</surname> <given-names>I</given-names></string-name>, <string-name><surname>Zhang</surname> <given-names>L</given-names></string-name>, <string-name><surname>Mayr</surname> <given-names>C</given-names></string-name>, <string-name><surname>Kingsmore</surname> <given-names>SF</given-names></string-name>, <string-name><surname>Schroth</surname> <given-names>GP</given-names></string-name>, <string-name><surname>Burge</surname> <given-names>CB</given-names></string-name>: <article-title>Alternative isoform regulation in human tissue transcriptions</article-title>. <source>Nature</source> <year>2008</year>, <volume>456</volume>:<fpage>470</fpage>-<lpage>476</lpage>.</mixed-citation></ref>
<ref id="c11"><label>11.</label> <mixed-citation publication-type="journal"><string-name><surname>Fullwood</surname> <given-names>MJ</given-names></string-name>, <string-name><surname>Wei</surname> <given-names>C-L</given-names></string-name>, <string-name><surname>Liu</surname> <given-names>ET</given-names></string-name>, <string-name><surname>Ruan</surname> <given-names>Y</given-names></string-name>: <article-title>Next-generation DNA sequencing of paired-end tags (PET) for transcriptome and genome analyses</article-title>. <source>Genome Research</source> <year>2009</year>, <volume>4</volume>:<fpage>521</fpage>-<lpage>532</lpage>.</mixed-citation></ref>
<ref id="c12"><label>12.</label> <mixed-citation publication-type="journal"><string-name><surname>Yassour</surname> <given-names>M</given-names></string-name>, <string-name><surname>Kaplan</surname> <given-names>T</given-names></string-name>, <string-name><surname>Fraser</surname> <given-names>HB</given-names></string-name>, <string-name><surname>Levin</surname> <given-names>JZ</given-names></string-name>, <string-name><surname>Pfiffner</surname> <given-names>J</given-names></string-name>, <string-name><surname>Adiconis</surname> <given-names>X</given-names></string-name>, <string-name><surname>Schroth</surname> <given-names>G</given-names></string-name>, <string-name><surname>Luo</surname> <given-names>S</given-names></string-name>, <string-name><surname>Khrebtukova</surname> <given-names>I</given-names></string-name>, <string-name><surname>Gnirke</surname> <given-names>A</given-names></string-name>, <etal>et al</etal>: <article-title>Ab initio construction of a eukaryotic transcriptome by massively parallel mRNA sequencing</article-title>. <source>Proc Natl Acad Sci USA 2009</source>, <volume>9</volume>:<fpage>3264</fpage>-<lpage>3269</lpage>.</mixed-citation></ref>
<ref id="c13"><label>13.</label> <mixed-citation publication-type="journal"><string-name><surname>Guttman</surname> <given-names>M</given-names></string-name>, <string-name><surname>Garber</surname> <given-names>M</given-names></string-name>, <string-name><surname>Levin</surname> <given-names>JZ</given-names></string-name>, <string-name><surname>Donaghey</surname> <given-names>J</given-names></string-name>, <string-name><surname>Robinson</surname> <given-names>J</given-names></string-name>, <string-name><surname>Adiconis</surname> <given-names>X</given-names></string-name>, <string-name><surname>Fan</surname> <given-names>L</given-names></string-name>, <string-name><surname>Koziol</surname> <given-names>MJ</given-names></string-name>, <string-name><surname>Gnirke</surname> <given-names>A</given-names></string-name>, <string-name><surname>Nusbaum</surname> <given-names>C</given-names></string-name>, <etal>et al</etal>: <article-title>Ab initio reconstruction of cell type-specific transcriptomes in mouse reveals the conserved multi-exomic structure of LineRNA</article-title>. <source>Nature Biotechnology</source> <year>2010</year>, <volume>28</volume>:<fpage>503</fpage>-<lpage>510</lpage>.</mixed-citation></ref>
<ref id="c14"><label>14.</label> <mixed-citation publication-type="journal"><string-name><surname>Trapnell</surname> <given-names>C</given-names></string-name>, <string-name><surname>Williams</surname> <given-names>BA</given-names></string-name>, <string-name><surname>Pertea</surname> <given-names>G</given-names></string-name>, <string-name><surname>Mortazavi</surname> <given-names>A</given-names></string-name>, <string-name><surname>Kwan</surname> <given-names>G</given-names></string-name>, <string-name><surname>van Baren</surname> <given-names>MJ</given-names></string-name>, <string-name><surname>Salzberg</surname> <given-names>SL</given-names></string-name>, <string-name><surname>Wold</surname> <given-names>BJ</given-names></string-name>, <string-name><surname>Pachter</surname> <given-names>L</given-names></string-name>: <article-title>Transcripts assembly and quantification by RNA-Seq reveals unannotated transcripts and isoform switching during cell differentiation</article-title>. <source>Nature Biotechnology</source> <year>2010</year>, <volume>28</volume>:<fpage>511</fpage>-<lpage>515</lpage>.</mixed-citation></ref>
<ref id="c15"><label>15.</label> <mixed-citation publication-type="journal"><string-name><surname>Schulz</surname> <given-names>MH</given-names></string-name>, <string-name><surname>Zerbino</surname> <given-names>DR</given-names></string-name>, <string-name><surname>Vingron</surname> <given-names>M</given-names></string-name>, <string-name><surname>Birney</surname> <given-names>E</given-names></string-name>: <article-title>Oases: Robust de novo RNA-seq assembly across the dynamic range of expression levels</article-title>. <source>Bioinformatics</source> <year>2012</year>, <volume>28</volume>:<fpage>1086</fpage>-<lpage>1092</lpage>.</mixed-citation></ref>
<ref id="c16"><label>16.</label> <mixed-citation publication-type="journal"><string-name><surname>Sze</surname> <given-names>S-H</given-names></string-name>, <string-name><surname>Tarone</surname> <given-names>AM</given-names></string-name>: <article-title>A memory-efficient algorithm to obtain splicing graphs and de novo expression estimates from de Bruijn graphs of RNA-Seq data</article-title>. <source>BMC Genomics</source> <year>2014</year>, <volume>15</volume>:<fpage>S6</fpage>.</mixed-citation></ref>
<ref id="c17"><label>17.</label> <mixed-citation publication-type="journal"><string-name><surname>Zerbino</surname> <given-names>DR</given-names></string-name>, <string-name><surname>Birney</surname> <given-names>E</given-names></string-name>: <article-title>Velvet: Algorithms for de novo short read assembly using de Bruijn graphs</article-title>. <source>Genome Research</source> <year>2008</year>, <volume>18</volume>:<fpage>821</fpage>-<lpage>829</lpage>.</mixed-citation></ref>
<ref id="c18"><label>18.</label> <mixed-citation publication-type="journal"><string-name><surname>Birol</surname> <given-names>I</given-names></string-name>, <string-name><surname>Jackman</surname> <given-names>SD</given-names></string-name>, <string-name><surname>Nielsen</surname> <given-names>CB</given-names></string-name>, <string-name><surname>Qian</surname> <given-names>JQ</given-names></string-name>, <string-name><surname>Varhol</surname> <given-names>R</given-names></string-name>, <string-name><surname>Stazyk</surname> <given-names>G</given-names></string-name>, <string-name><surname>Morin</surname> <given-names>RD</given-names></string-name>, <string-name><surname>Zhao</surname> <given-names>Y</given-names></string-name>, <string-name><surname>Hirst</surname> <given-names>M</given-names></string-name>, <string-name><surname>Schein</surname> <given-names>JE</given-names></string-name>, <etal>et al</etal>: <article-title>De novo transcriptome assembly with ABySS</article-title>. <source>Bioinformatics</source> <year>2009</year>, <volume>25</volume>:<fpage>2872</fpage>-<lpage>2877</lpage>.</mixed-citation></ref>
<ref id="c19"><label>19.</label> <mixed-citation publication-type="journal"><string-name><surname>Simpson</surname> <given-names>JT</given-names></string-name>, <string-name><surname>Wong</surname> <given-names>K</given-names></string-name>, <string-name><surname>Jackman</surname> <given-names>SD</given-names></string-name>, <string-name><surname>Schein</surname> <given-names>JE</given-names></string-name>, <string-name><surname>Jones</surname> <given-names>SJM</given-names></string-name>, <string-name><surname>Birol</surname> <given-names>I</given-names></string-name>: <article-title>ABySS: A parallel assembler for short read sequence data</article-title>. <source>Genome Research</source> <year>2009</year>, <volume>19</volume>:<fpage>1117</fpage>-<lpage>1123</lpage>.</mixed-citation></ref>
<ref id="c20"><label>20.</label> <mixed-citation publication-type="journal"><string-name><surname>Xie</surname> <given-names>Y</given-names></string-name>, <string-name><surname>Wu</surname> <given-names>G</given-names></string-name>, <string-name><surname>Tang</surname> <given-names>J</given-names></string-name>, <string-name><surname>Luo</surname> <given-names>R</given-names></string-name>, <string-name><surname>Patterson</surname> <given-names>J</given-names></string-name>, <string-name><surname>Liu</surname> <given-names>S</given-names></string-name>, <string-name><surname>Huang</surname> <given-names>W</given-names></string-name>, <string-name><surname>He</surname> <given-names>G</given-names></string-name>, <string-name><surname>Gu</surname> <given-names>S</given-names></string-name>, <string-name><surname>Li</surname> <given-names>S</given-names></string-name>, <etal>et al</etal>: <article-title>SOAPdenovo-Trans: De novo transcriptome assembly with short RNA-Seq reads</article-title>. <source>Bioinformatics</source> <year>2014</year>, <volume>30</volume>:<fpage>1660</fpage>-<lpage>1666</lpage>.</mixed-citation></ref>
<ref id="c21"><label>21.</label> <mixed-citation publication-type="journal"><string-name><surname>Li</surname> <given-names>R</given-names></string-name>, <string-name><surname>Zhu</surname> <given-names>H</given-names></string-name>, <string-name><surname>Ruan</surname> <given-names>J</given-names></string-name>, <string-name><surname>Qian</surname> <given-names>W</given-names></string-name>, <string-name><surname>Fang</surname> <given-names>X</given-names></string-name>, <string-name><surname>Shi</surname> <given-names>Z</given-names></string-name>, <string-name><surname>Li</surname> <given-names>Y</given-names></string-name>, <string-name><surname>Li</surname> <given-names>S</given-names></string-name>, <string-name><surname>Shan</surname> <given-names>G</given-names></string-name>, <string-name><surname>Kristiansen</surname> <given-names>K</given-names></string-name>, <etal>et al</etal>: <article-title>De novo assembly of human genomes with massively parallel short read sequencing</article-title>. <source>Genome Research</source> <year>2010</year>, <volume>20</volume>:<fpage>265</fpage>-<lpage>272</lpage>.</mixed-citation></ref>
<ref id="c22"><label>22.</label> <mixed-citation publication-type="journal"><string-name><surname>Grabherr</surname> <given-names>MG</given-names></string-name>, <string-name><surname>Haas</surname> <given-names>BJ</given-names></string-name>, <string-name><surname>Yassour</surname> <given-names>M</given-names></string-name>, <string-name><surname>Levin</surname> <given-names>JZ</given-names></string-name>, <string-name><surname>Thompson</surname> <given-names>DA</given-names></string-name>, <string-name><surname>Amit</surname> <given-names>I</given-names></string-name>, <string-name><surname>Adiconis</surname> <given-names>X</given-names></string-name>, <string-name><surname>Fan</surname> <given-names>L</given-names></string-name>, <string-name><surname>Raychowdhury</surname> <given-names>R</given-names></string-name>, <string-name><surname>Zeng</surname> <given-names>Q</given-names></string-name>, <etal>et al</etal>: <article-title>Full-length transcriptome assembly from RNA-seq data without a reference genome</article-title>. <source>Nature Biotechnology</source> <year>2011</year>, <volume>29</volume>:<fpage>644</fpage>-<lpage>652</lpage>.</mixed-citation></ref>
<ref id="c23"><label>23.</label> <mixed-citation publication-type="journal"><string-name><surname>Chang</surname> <given-names>Z</given-names></string-name>, <string-name><surname>Li</surname> <given-names>G</given-names></string-name>, <string-name><surname>Liu</surname> <given-names>J</given-names></string-name>, <string-name><surname>Zhang</surname> <given-names>Y</given-names></string-name>, <string-name><surname>Ashby</surname> <given-names>C</given-names></string-name>, <string-name><surname>Liu</surname> <given-names>D</given-names></string-name>, <string-name><surname>Cramer</surname> <given-names>CL</given-names></string-name>, <string-name><surname>Huang</surname> <given-names>X</given-names></string-name>: <article-title>Bridger: a new framework for de novo transcriptome assembly using RNA-seq data</article-title>. <source>Genome Biology</source> <year>2015</year>, <volume>16</volume>.</mixed-citation></ref>
<ref id="c24"><label>24.</label> <mixed-citation publication-type="journal"><string-name><surname>Liu</surname> <given-names>J</given-names></string-name>, <string-name><surname>Li</surname> <given-names>G</given-names></string-name>, <string-name><surname>Chang</surname> <given-names>Z</given-names></string-name>, <string-name><surname>Yu</surname> <given-names>T</given-names></string-name>, <string-name><surname>Liu</surname> <given-names>B</given-names></string-name>, <string-name><surname>McMullen</surname> <given-names>R</given-names></string-name>, <string-name><surname>Chen</surname> <given-names>P</given-names></string-name>, <string-name><surname>Huang</surname> <given-names>X</given-names></string-name>: <article-title>BinPacker: Packing-Based De Novo Transcriptome Assembly from RNA-seq Data</article-title>. <source>PLOS Computational Biology</source> <year>2016</year>, <volume>12</volume>: <fpage>e1004772</fpage>.</mixed-citation></ref>
<ref id="c25"><label>25.</label> <mixed-citation publication-type="book"><string-name><surname>Martello</surname> <given-names>S</given-names></string-name>, <string-name><surname>Toth</surname> <given-names>P</given-names></string-name>: <source>Knapsack Problems: Algorithms and Computer Implementations</source>. <publisher-name>John Wiley and Sons</publisher-name>; <year>1990</year>.</mixed-citation></ref>
<ref id="c26"><label>26.</label> <mixed-citation publication-type="journal"><string-name><surname>Cabau</surname> <given-names>C</given-names></string-name>, <string-name><surname>Escudi&#x00E9;</surname> <given-names>F</given-names></string-name>, <string-name><surname>Djari</surname> <given-names>A</given-names></string-name>, <string-name><surname>Guiguen</surname> <given-names>Y</given-names></string-name>, <string-name><surname>Bobe</surname> <given-names>J</given-names></string-name>, <string-name><surname>Klopp</surname> <given-names>C</given-names></string-name>: <article-title>Compacting and correcting Trinity and Oases RNA-Seq de novo assemblies</article-title>. <source>PeerJ</source> <year>2017</year>, <volume>5</volume>.</mixed-citation></ref>
<ref id="c27"><label>27.</label> <mixed-citation publication-type="journal"><string-name><surname>Zhao</surname> <given-names>Q-Y</given-names></string-name>, <string-name><surname>Wang</surname> <given-names>Y</given-names></string-name>, <string-name><surname>Kong</surname> <given-names>Y-M</given-names></string-name>, <string-name><surname>Luo</surname> <given-names>D</given-names></string-name>, <string-name><surname>Li</surname> <given-names>X</given-names></string-name>, <string-name><surname>Hao</surname> <given-names>P</given-names></string-name>: <article-title>Optimizing de novo transcriptome assembly from short-read RNA-Seq data: a comparative study</article-title>. <source>BMC Bioinformatics 2011</source>, <volume>12</volume>:<fpage>S2</fpage>.</mixed-citation></ref>
<ref id="c28"><label>28.</label> <mixed-citation publication-type="other"><string-name><surname>Sachdeva</surname> <given-names>V</given-names></string-name>, <string-name><surname>Kim</surname> <given-names>CS</given-names></string-name>, <string-name><surname>Jordan</surname> <given-names>KE</given-names></string-name>, <string-name><surname>Winn</surname> <given-names>MD</given-names></string-name>: <article-title>Parallelization of the Trinity pipeline for de novo transcriptome assembly</article-title>. pp. <fpage>566</fpage>-<lpage>575</lpage>; <year>2014</year>:566-575.</mixed-citation></ref>
<ref id="c29"><label>29.</label> <mixed-citation publication-type="other"><string-name><surname>Brown</surname> <given-names>CT</given-names></string-name>, <string-name><surname>Howe</surname> <given-names>A</given-names></string-name>, <string-name><surname>Zhang</surname> <given-names>Q</given-names></string-name>, <string-name><surname>Pyrkosz</surname> <given-names>AB</given-names></string-name>, <string-name><surname>Brom</surname> <given-names>TH</given-names></string-name>: <article-title>A reference-free algorithm for computational normalization of shotgun sequencing data</article-title>. <italic>arXiv</italic>:<pub-id pub-id-type="arxiv">12034802</pub-id> <year>2012</year>.</mixed-citation></ref>
<ref id="c30"><label>30.</label> <mixed-citation publication-type="journal"><string-name><surname>Dean</surname> <given-names>J</given-names></string-name>, <string-name><surname>Ghemawat</surname> <given-names>S</given-names></string-name>: <article-title>MapReduce: Simplified data processing on large clusters</article-title>. <source>Computing in Science and Engineering</source> <year>2009</year>, <volume>11</volume>:<fpage>29</fpage>-<lpage>41</lpage>.</mixed-citation></ref>
<ref id="c31"><label>31.</label> <mixed-citation publication-type="journal"><string-name><surname>McKenna</surname> <given-names>A</given-names></string-name>, <string-name><surname>Hanna</surname> <given-names>M</given-names></string-name>, <string-name><surname>Banks</surname> <given-names>E</given-names></string-name>, <string-name><surname>Sivachenko</surname> <given-names>A</given-names></string-name>, <string-name><surname>Kristian Cibulskis</surname> <given-names>AK</given-names></string-name>, <string-name><surname>Garimella</surname> <given-names>K</given-names></string-name>, <string-name><surname>Altshuler</surname> <given-names>D</given-names></string-name>, <string-name><surname>Gabriel</surname> <given-names>S</given-names></string-name>, <string-name><surname>Daly</surname> <given-names>M</given-names></string-name>, <string-name><surname>DePristo</surname> <given-names>MA</given-names></string-name>: <article-title>The Genome Analysis Toolkit: A MapReduce framework for analyzing next-generation DNA sequencing data</article-title>. <source>Genome Research</source> <year>2010</year>, <volume>20</volume>:<fpage>1297</fpage>-<lpage>1303</lpage>.</mixed-citation></ref>
<ref id="c32"><label>32.</label> <mixed-citation publication-type="journal"><string-name><surname>Mohammed</surname> <given-names>EA</given-names></string-name>, <string-name><surname>Far</surname> <given-names>BH</given-names></string-name>, <string-name><surname>Naugler</surname> <given-names>C</given-names></string-name>: <article-title>Applications of the MapReduce programming framework to clinical big data analysis: current landscape and future trends</article-title>. <source>Biodata Mining</source> <year>2014</year>, <volume>7</volume>:<fpage>22</fpage>.</mixed-citation></ref>
<ref id="c33"><label>33.</label> <mixed-citation publication-type="journal"><string-name><surname>Xu</surname> <given-names>B</given-names></string-name>, <string-name><surname>Gao</surname> <given-names>J</given-names></string-name>, <string-name><surname>Li</surname> <given-names>C</given-names></string-name>: <article-title>An efficient algorithm for DNA fragment assembly in MapReduce</article-title>. <source>Biochem Biophys Res Commun</source> <year>2012</year>, <volume>426</volume>:<fpage>395</fpage>-<lpage>398</lpage>.</mixed-citation></ref>
<ref id="c34"><label>34.</label> <mixed-citation publication-type="other"><collab>MapReduce-MPI Library</collab></mixed-citation></ref>
<ref id="c35"><label>35.</label> <mixed-citation publication-type="book"><string-name><surname>White</surname> <given-names>T</given-names></string-name>: <source>Hadoop: The Definitive Guide</source>. <publisher-name>O&#x2019;Reilly Media</publisher-name>; <year>2009</year>.</mixed-citation></ref>
<ref id="c36"><label>36.</label> <mixed-citation publication-type="journal"><string-name><surname>Ranger</surname> <given-names>C</given-names></string-name>, <string-name><surname>Raghuraman</surname> <given-names>R</given-names></string-name>, <string-name><surname>Penmetsa</surname> <given-names>A</given-names></string-name>, <string-name><surname>Bradski</surname> <given-names>G</given-names></string-name>, <string-name><surname>Kozyrakis</surname> <given-names>C</given-names></string-name>: <article-title>Evaluating MapReduce for Multi-core and Multiprocessor Systems</article-title>. <source>IEEE 13th International Symposium on High Performance Computer Architecture</source> <year>2007</year>:<fpage>13</fpage>-<lpage>24</lpage>.</mixed-citation></ref>
<ref id="c37"><label>37.</label> <mixed-citation publication-type="journal"><string-name><surname>Hopcroft</surname> <given-names>JE</given-names></string-name>, <string-name><surname>Tarjan</surname> <given-names>RE</given-names></string-name>: <article-title>Efficient algorithms for graph manipulation</article-title>. <source>Communications of the ACM</source> <year>1973</year>,<volume>16</volume>:<fpage>372</fpage>-<lpage>378</lpage>.</mixed-citation></ref>
<ref id="c38"><label>38.</label> <mixed-citation publication-type="journal"><string-name><surname>Plimpton</surname> <given-names>SJ</given-names></string-name>, <string-name><surname>Devine</surname> <given-names>KD</given-names></string-name>: <article-title>MapReduce in MPI for Large-Scale Graph Algorithms</article-title>. <source>Parallel Computing</source> <year>2011</year>, <volume>37</volume>:<fpage>610</fpage>-<lpage>632</lpage>.</mixed-citation></ref>
<ref id="c39"><label>39.</label> <mixed-citation publication-type="journal"><string-name><surname>Li</surname> <given-names>B</given-names></string-name>, <string-name><surname>Ruotti</surname> <given-names>V</given-names></string-name>, <string-name><surname>Stewart</surname> <given-names>RM</given-names></string-name>, <string-name><surname>Thomson</surname> <given-names>JA</given-names></string-name>, <string-name><surname>Dewey</surname> <given-names>CN</given-names></string-name>: <article-title>RNA-Seq gene expression estimation with read mapping uncertainty</article-title>. <source>Bioinformatics</source> <year>2010</year>, <volume>26</volume>:<fpage>493</fpage>-<lpage>500</lpage>.</mixed-citation></ref>
<ref id="c40"><label>40.</label> <mixed-citation publication-type="journal"><string-name><surname>Li</surname> <given-names>B</given-names></string-name>, <string-name><surname>Dewey</surname> <given-names>CN</given-names></string-name>: <article-title>RSEM: accurate transcript quantification from RNA-Seq data with or without a reference genome</article-title>. <source>BMC Bioinformatics</source> <year>2011</year>, <volume>12</volume>.</mixed-citation></ref>
<ref id="c41"><label>41.</label> <mixed-citation publication-type="journal"><string-name><surname>Li</surname> <given-names>B</given-names></string-name>, <string-name><surname>Fillmore</surname> <given-names>N</given-names></string-name>, <string-name><surname>Bai</surname> <given-names>Y</given-names></string-name>, <string-name><surname>Collins</surname> <given-names>M</given-names></string-name>, <string-name><surname>Thomson</surname> <given-names>JA</given-names></string-name>, <string-name><surname>Stewart</surname> <given-names>R</given-names></string-name>, <string-name><surname>Dewey</surname> <given-names>C</given-names></string-name>: <article-title>Evaluation of de novo transcriptome assemblies from RNA-Seq data</article-title>. <source>Genome Biology</source> <year>2014</year>, <volume>15</volume>:<fpage>553</fpage>.</mixed-citation></ref>
<ref id="c42"><label>42.</label> <mixed-citation publication-type="journal"><string-name><surname>Kent</surname> <given-names>WJ</given-names></string-name>: <article-title>BLAT-the BLAST-like alignment tool</article-title>. <source>Genome Research</source> <year>2002</year>, <volume>12</volume>:<fpage>654</fpage>-<lpage>664</lpage>.</mixed-citation></ref>
<ref id="c43"><label>43.</label> <mixed-citation publication-type="journal"><string-name><surname>Pedersen</surname> <given-names>BS</given-names></string-name>, <string-name><surname>Yang</surname> <given-names>IV</given-names></string-name>, <string-name><surname>De</surname> <given-names>S</given-names></string-name>: <article-title>CruzDB: software for annotation of genomic intervals with UCSC genome-browser database</article-title>. <source>Bioinformatics</source> <year>2013</year>, <volume>29</volume>:<fpage>3003</fpage>-<lpage>3006</lpage>.</mixed-citation></ref>
<ref id="c44"><label>44.</label> <mixed-citation publication-type="journal"><string-name><surname>Marcais</surname> <given-names>G</given-names></string-name>, <string-name><surname>Kingsford</surname> <given-names>C</given-names></string-name>: <article-title>A fast, lock-free approach for efficient parallel counting of occurrences of k-mers</article-title>. <source>Bioinformatics</source> <year>2011</year>, <volume>27</volume>:<fpage>764</fpage>-<lpage>770</lpage>.</mixed-citation></ref>
<ref id="c45"><label>45.</label> <mixed-citation publication-type="journal"><string-name><surname>Pell</surname> <given-names>J</given-names></string-name>, <string-name><surname>Hintze</surname> <given-names>A</given-names></string-name>, <string-name><surname>Canino-Koning</surname> <given-names>R</given-names></string-name>, <string-name><surname>Howe</surname> <given-names>A</given-names></string-name>, <string-name><surname>Tiedje</surname> <given-names>JM</given-names></string-name>, <string-name><surname>Brown</surname> <given-names>CT</given-names></string-name> <article-title>Scaling metagenome sequence assembly with probabilistic de Bruijn graphs</article-title>. <source>Proc Natl Acad Sci USA</source> <year>2012</year>, <volume>109</volume>:<fpage>13272</fpage>-<lpage>13277</lpage>.</mixed-citation></ref>
<ref id="c46"><label>46.</label> <mixed-citation publication-type="journal"><string-name><surname>Chikhi</surname> <given-names>R</given-names></string-name>, <string-name><surname>Rizk</surname> <given-names>G</given-names></string-name>: <article-title>Space-efficient and exact de Bruijn graph representation based on a Bloom filter</article-title>. <source>Algorithms for Molecular Biology</source> <year>2013</year>, <volume>8</volume>.</mixed-citation></ref>
<ref id="c47"><label>47.</label> <mixed-citation publication-type="journal"><string-name><surname>Peng</surname> <given-names>Y</given-names></string-name>, <string-name><surname>Leung</surname> <given-names>HCM</given-names></string-name>, <string-name><surname>Yiu</surname> <given-names>SM</given-names></string-name>, <string-name><surname>Chin</surname> <given-names>FYL</given-names></string-name>: <article-title>Meta-IDBA: a de novo assembler for metagenomic data</article-title>. <source>Bioinformatics</source> <year>2011</year>, <volume>27</volume>:<fpage>i94</fpage>-<lpage>i101</lpage>.</mixed-citation></ref>
<ref id="c48"><label>48.</label> <mixed-citation publication-type="journal"><string-name><surname>Leung</surname> <given-names>HCM</given-names></string-name>, <string-name><surname>Yiu</surname> <given-names>SM</given-names></string-name>, <string-name><surname>Parkinson</surname> <given-names>J</given-names></string-name>, <string-name><surname>Chin</surname> <given-names>FYL</given-names></string-name>: <article-title>IDBA-MT: De Novo Assembler for Metatranscriptomic Data Generated from Next-Generation Sequencing Technology</article-title>. <source>J Comp Biol</source> <year>2013</year>, <volume>20</volume>:<fpage>540</fpage>-<lpage>550</lpage>.</mixed-citation></ref>
</ref-list></back>
</article>