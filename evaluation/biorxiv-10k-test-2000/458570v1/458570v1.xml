<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.2d1 20170631//EN" "JATS-archivearticle1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" article-type="article" dtd-version="1.2d1" specific-use="production" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">BIORXIV</journal-id>
<journal-title-group>
<journal-title>bioRxiv</journal-title>
<abbrev-journal-title abbrev-type="publisher">bioRxiv</abbrev-journal-title>
</journal-title-group>
<publisher>
<publisher-name>Cold Spring Harbor Laboratory</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1101/458570</article-id>
<article-version>1.1</article-version>
<article-categories>
<subj-group subj-group-type="author-type">
<subject>Regular Article</subject>
</subj-group>
<subj-group subj-group-type="heading">
<subject>New Results</subject>
</subj-group>
<subj-group subj-group-type="hwp-journal-coll">
<subject>Neuroscience</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>Local online learning in recurrent networks with random feedback</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author"><name><surname>Murray</surname><given-names>James M.</given-names></name></contrib>
<aff id="a1"><institution>Zuckerman Mind, Brain and Behavior Institute, Columbia University</institution>, New York, 10032</aff>
</contrib-group>
<pub-date pub-type="epub">
<year>2018</year>
</pub-date>
<elocation-id>458570</elocation-id>
<history>
<date date-type="received">
<day>31</day>
<month>10</month>
<year>2018</year>
</date>
<date date-type="rev-recd">
<day>31</day>
<month>10</month>
<year>2018</year>
</date>
<date date-type="accepted">
<day>31</day>
<month>10</month>
<year>2018</year>
</date>
</history>
<permissions>
<copyright-statement>&#x00A9; 2018, Posted by Cold Spring Harbor Laboratory</copyright-statement>
<copyright-year>2018</copyright-year>
<license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by/4.0/"><license-p>This pre-print is available under a Creative Commons License (Attribution 4.0 International), CC BY 4.0, as described at <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link></license-p></license>
</permissions>
<self-uri xlink:href="458570.pdf" content-type="pdf" xlink:role="full-text"/>
<abstract>
<title>Abstract</title>
<p>A longstanding challenge for computational neuroscience has been the development of biologically plausible learning rules for recurrent neural networks (RNNs) enabling the production and processing of time-dependent signals such as those that might drive movement or facilitate working memory. Classic gradient-based algorithms for training RNNs have been available for decades, but they are inconsistent with known biological features of the brain, such as causality and locality. In this work we derive an approximation to gradient-based learning that comports with these biologically motivated constraints. Specifically, the online learning rule for the synaptic weights involves only local information about the pre- and postsynaptic activities, in addition to a random feedback projection of the RNN output error. In addition to providing mathematical arguments for the effectiveness of the new learning rule, we show through simulations that it can be used to train an RNN to successfully perform a variety of tasks. Finally, to overcome the difficulty of training an RNN over a very large number of timesteps, we propose an augmented circuit architecture that allows the RNN to concatenate short-duration patterns into sequences of longer duration.</p>
</abstract>
<counts>
<page-count count="24"/>
</counts>
</article-meta>
</front>
<body>
<sec id="s1">
<title>Introduction</title>
<p>Many tasks require computations that unfold over time. To accomplish tasks involving motor control, working memory, or other time-dependent phenomena, neural circuits must learn to produce the correct output at the correct time. Such learning is a difficult computational problem, as it generally involves temporal credit assignment, requiring synaptic weight updates at a particular time to minimize errors not only at the time of learning but also at earlier and later times. The problem is also a very general one, as such learning occurs in numerous brain areas and is thought to underlie many complex cognitive and motor tasks encountered in experiments.</p>
<p>To obtain insight into how the brain might perform challenging time-dependent computations, an increasingly common approach is to train high-dimensional dynamical systems known as recurrent neural networks (RNNs) to perform tasks similar to those performed by circuits of the brain, often with the goal of comparing the RNN with neural data to obtain insight about how the brain solves computational problems [<xref ref-type="bibr" rid="c1">1</xref>, <xref ref-type="bibr" rid="c2">2</xref>, <xref ref-type="bibr" rid="c3">3</xref>, <xref ref-type="bibr" rid="c4">4</xref>]. While such an approach can lead to useful insights about the neural representations that are formed once a task is learned, it so far cannot address in a satisfying way the process of learning itself, as the standard learning rules for training RNNs suffer from highly nonbiological features such as nonlocality and acausality, as we describe below.</p>
<p>The most straightforward approach to training an RNN to produce a desired output is to define a loss function based on the difference between the RNN output and the target output that we would like it to match, then to update each parameter in the RNN&#x2014;typically the synaptic weights&#x2014;by an amount proportional to the gradient of the loss function with respect to that parameter. The most widely used among these algorithms is backpropagation through time (BPTT) [<xref ref-type="bibr" rid="c5">5</xref>]. As its name suggests, BPTT is acausal, requiring that errors in the RNN output be accumulated incrementally from the end of a trial to the beginning in order to update synaptic weights. Real-time recurrent learning (RTRL) [<xref ref-type="bibr" rid="c6">6</xref>], the other classic gradient-based learning rule, is causal but nonlocal, with the update to a particular synaptic weight in the RNN depending on the full state of the network&#x2014;a limitation shared by more modern reservoir computing methods [<xref ref-type="bibr" rid="c7">7</xref>, <xref ref-type="bibr" rid="c8">8</xref>]. What&#x2019;s more, both BPTT and RTRL require fine tuning in the sense that the feedback weights from the RNN output back to the network must precisely match the readout weights from the RNN to its output.</p>
<p>The goal of this work is to derive a learning rule for RNNs that is both causal and local, without requiring fine tuning of the feedback weights. Our results depend crucially on two approximations. First, locality is enforced by dropping the nonlocal part of the loss function gradient, making our learning rule only approximately gradient-based. Second, we replace the finely tuned feedback weights required by gradient- based learning with random feedback weights, inspired by the success of a similar approach in nonrecurrent feedforward networks [<xref ref-type="bibr" rid="c9">9</xref>, <xref ref-type="bibr" rid="c10">10</xref>]. With these two approximations, we obtain a learning rule that is causal and local, without requiring fine tuning of feedback weights. In the sections that follow, we show that, despite these approximations, RNNs can be effectively trained to perform a variety of tasks. In the Appendices, we provide supplementary mathematical arguments showing why the algorithm remains effective despite its use of an inexact loss function gradient.</p>
</sec>
<sec id="s2">
<title>Results</title>
<sec id="s2a">
<title>The RFLO learning rule</title>
<p>To begin, we consider an RNN, as shown in <xref ref-type="fig" rid="fig1">Figure 1</xref>, in which a time-dependent input vector <bold>x</bold>(<italic>t</italic>) provides input to a recurrently connected hidden layer of <italic>N</italic> units described by activity vector <bold>h</bold>(<italic>t</italic>), and this activity is read out to form a time-dependent output <bold>y</bold>(<italic>t</italic>). Such a network is defined by the following equations:
<disp-formula id="eqn1">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn1.gif"/></alternatives>
</disp-formula></p>
<fig id="fig1" position="float"><label>Figure 1:</label><caption><p>Schematic illustration of a recurrent neural network. The network receives time-dependent input <bold>x</bold>(<italic>t</italic>), and its synaptic weights are trained so that the output <bold>y</bold>(<italic>t</italic>) matches a target function y&#x002A;(<italic>t</italic>). The projection of the error <italic>&#x03B5;</italic>(<italic>t</italic>) with feedback weights is used for learning the input weights and recurrent weights.</p></caption><graphic xlink:href="458570_fig1.tif"/></fig>
<p>For concreteness, we take the nonlinear function appearing in (<xref ref-type="disp-formula" rid="eqn1">1</xref>) to be <italic>&#x03D5;</italic>(&#x00B7;) &#x003D; tanh(&#x00B7;). The goal is to train this network to produce a target output function <bold>y</bold>&#x002A; (<italic>t</italic>) given a specified input function <bold>x</bold>(<italic>t</italic>) and initial activity vector <bold>h</bold>(0). The error is then the difference between the target output and the actual output, and the loss function is the squared error integrated over time:
<disp-formula id="eqn2">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn2.gif"/></alternatives>
</disp-formula></p>
<p>The goal of producing the target output function <bold>y</bold>&#x002A;(<italic>t</italic>) is equivalent to minimizing this loss function.</p>
<p>The derivation of the learning rules used in this paper is provided in Appendix 1, where their relation to other gradient-based learning rules (BPTT and RTRL) is also discussed in detail. In brief, the derivation proceeds by taking the gradient of the loss function with respect to the synaptic weights, as in RTRL or BPTT, and then performing gradient descent by updating the synaptic weights by an amount proportional to the gradient. Unlike those methods, however, two approximations are made when taking the gradient. One approximation consists of dropping a nonlocal term from the gradient, so that computing the update to a given synaptic weight requires only pre- and postsynaptic activities, rather than information about the entire state of the RNN including all of its synaptic weights. Second, as described in more detail below, we project the error back into the network for learning using random feedback weights, rather than feedback weights that are tuned to match the readout weights.</p>
<p>Following this procedure, the weight update equations are
<disp-formula id="eqn3">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn3.gif"/></alternatives>
</disp-formula>
where <italic>&#x03B7;<sub>i</sub></italic> are learning rates, and <bold>B</bold> is a random matrix of feedback weights. Here we have defined
<disp-formula id="eqn4">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn4.gif"/></alternatives>
</disp-formula>
which are the accumulated products of the pre- and (the derivative of the) postsynaptic activity at the recurrent and input synapses, respectively. We have also defined <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_inline1.gif"/></alternatives></inline-formula> as the total input current to unit <italic>a</italic>. While this form of the update equations does not require explicit integration and hence is more efficient for numerical simulation, it is instructive to take the continuous-time (<italic>&#x03C4;</italic> &#x226B; 1) limit of the (<xref ref-type="disp-formula" rid="eqn14">14</xref>) and the integral of (<xref ref-type="disp-formula" rid="eqn15">15</xref>), which yields
<disp-formula id="eqn5">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn5.gif"/></alternatives>
</disp-formula></p>
<p>In this way, it becomes clear that the integrals in the second and third equations are <italic>eligibility traces</italic> that accumulate the correlations between pre- and post-synaptic activity over a time window of duration &#x007E; t. The weight update is then proportional to this eligibility trace, multiplied by a feedback projection of the readout error. The fact that the timescale for the eligibility trace matches the RNN time constant t reflects the fact that the RNN dynamics are typically correlated only up to this timescale, so that the error is associated only with RNN activity up to time t in the past. If the error feedback were delayed rather than provided instantaneously, then eligibility traces with longer timescales might be beneficial [<xref ref-type="bibr" rid="c11">11</xref>].</p>
<p>Three features of the above learning rules are especially important. First, the updates are local, requiring information about the presynaptic activity and the postsynaptic input current, but no information about synaptic weights and activity levels elsewhere in the network. Second, the updates are online and can either be made at each timestep or accumulated over many timesteps and made at the end of each trial or of several trials. In either case, unlike the BPTT algorithm, it is not necessary to run the dynamics backward in time at the end of each trial to compute the weight updates. Third, the readout error is projected back to each unit in the network with weights <bold>B</bold> that are fixed and random. An exact gradient of the loss function, on the other hand, would lead to (<bold>W</bold><sup>out</sup>)<sup>T</sup>, where (&#x00B7;)<sup>T</sup> denotes matrix transpose, appearing in the place of <bold>B</bold>. As described above, the use of random feedback weights is inspired by a similar approach in feedforward networks [<xref ref-type="bibr" rid="c9">9</xref>] (see also [<xref ref-type="bibr" rid="c12">12</xref>]), and we shall show below that the same feedback alignment mechanism that is responsible for the success of the feedforward version is also at work in our recurrent version.<sup><xref ref-type="fn" rid="fn1">1</xref></sup></p>
<p>With the above observations in mind, we refer to the above learning rule as random feedback local online (RFLO) learning. In Appendix 1, we provide a full derivation of the learning rule, and describe in detail its relation to the other gradient-based methods mentioned above, BPTT and RTRL. Because the RFLO learning rule uses an approximation of the loss function gradient rather than the exact gradient for updating the synaptic weights, a natural question to ask is whether it can be expected to decrease the loss function at all. In Appendix 2 we show that, under certain simplifying assumptions including linearization of the RNN, the loss function does indeed decrease on average with each step of RFLO learning. In particular, we show that, as in the feedforward case [<xref ref-type="bibr" rid="c9">9</xref>], reduction of the loss function requires alignment between the learned readout weights W<sup>out</sup> and the fixed feedback weights B. We then proceed to show that this alignment tends to increase during training due to coordinated learning of the recurrent weights <bold>W</bold> and readout weights <bold>W</bold><sup>out</sup>. Because of the simplifying assumptions made in the mathematical derivations of Appendix 2, however, it remains to be shown that RFLO learning can be used to successfully train a nonlinear RNN in practice. In the following section, therefore, we show using simulated examples that RFLO learning can perform well on a variety of tasks.</p>
</sec>
<sec id="s2b">
<title>Performance of RFLO learning</title>
<p>In this section we illustrate the performance of the RFLO learning algorithm on a number of simulated tasks. As a benchmark, we compare the performance of RFLO learning with BPTT, the standard algorithm for training RNNs. (As described in Appendix 1, the weight updates in RTRL are, when performed in batches at the end of each trial, completely equivalent to those in BPTT. Hence in this section we compare RFLO learning with BPTT only in what follows.)</p>
</sec>
<sec id="s2c">
<title>Autonomous production of continuous outputs</title>
<p><xref ref-type="fig" rid="fig2">Figure 2</xref> illustrates the performance of an RNN trained with RFLO learning to produce a one-dimensional periodic output given no external input. <xref ref-type="fig" rid="fig2">Figure 2a</xref> shows the decrease of the loss function (the mean squared error of the RNN output) as the RNN is trained over many trials, where each trial corresponds to one period consisting of <italic>T</italic> timesteps, as well as the performance of the RNN at the end of training. In addition to the RFLO learning rule, BPTT was also used to train the RNN, as well as a variant of RFLO learning (RFLO&#x002B;Dale) in which all outbound synapses from a given unit were constrained to be of the same sign&#x2014;a biological constraint known as Dale&#x2019;s law [<xref ref-type="bibr" rid="c13">13</xref>]. In all cases, the sign-constrained network was capable of learning as well as the unconstrained network, as shown in previous modeling work using nonlocal learning rules [<xref ref-type="bibr" rid="c14">14</xref>].</p>
<fig id="fig2" position="float"><label>Figure 2:</label><caption><title>Periodic output task.</title><p>(a) <italic>Left panels:</italic> The mean squared output error during training for an RNN with <italic>N</italic> &#x003D; 30 recurrent units and no external input, trained to produce a one-dimensional periodic output with period of duration <italic>T</italic> &#x003D; 20<italic>&#x03C4;</italic> (left) or <italic>T</italic> &#x003D; 160<italic>&#x03C4;</italic> (right), where <italic>&#x03C4;</italic> &#x003D; 10 is the RNN time constant. The learning rules used for training were backpropagation through time (BPTT), RFLO, or RFLO with sign-constrained synapses (RFLO&#x002B;Dale). <italic>Right panels:</italic> The RNN output at the end of training for each of the three types of learning (dashed lines are target outputs). (b) The loss function at the end of training for target outputs having different periods. The three colors correspond to the three learning rules from (a), while the gray line is the loss computed for an untrained RNN. (c) The normalized alignment between the vector of readout weights <bold>W</bold><sup>out</sup> and the vector of feedback weights <bold>B</bold> during training with RFLO learning. (d) The loss function during training with <italic>T</italic> &#x003D; 80<italic>&#x03C4;</italic> for BPTT and RFLO, as well as versions of RFLO in which locality is enforced without random feedback (magenta) or random feedback is used without enforcing locality (cyan). In this figure, solid lines show median loss over 5 trained RNNs, learning rates were selected by grid search over <italic>&#x03B7;</italic><sub>1,2,3</sub> &#x003D; <italic>&#x03B7;</italic> &#x20AC; [10<sup>&#x2212;4</sup>, 10<sup>0</sup>], and the RNN time constant was <italic>&#x03C4;</italic> &#x003D; 10.</p></caption><graphic xlink:href="458570_fig2.tif"/></fig>
<p><xref ref-type="fig" rid="fig2">Figure 2b</xref> shows that, in the case where the number of timesteps in the target output was not too great, both versions of RFLO learning perform comparably well to BPTT. BPTT showed an advantage, however, when the number of timesteps became very large. Intuitively, this difference in performance is due to the accumulation of small errors in the estimated gradient of the loss function over many timesteps with RFLO learning. This is less of a problem for BPTT, on the other hand, in which the exact gradient is used.</p>
<p><xref ref-type="fig" rid="fig2">Figure 2c</xref> shows the increase in the alignment between the vector of readout weights <bold>W</bold><sup>out</sup> and the vector of feedback weights <bold>B</bold> during training with RFLO learning. As in the case of feedforward networks [<xref ref-type="bibr" rid="c9">9</xref>, <xref ref-type="bibr" rid="c12">12</xref>], the readout weights evolve over time to become increasingly similar to the feedback weights, which are fixed during training. In Appendix 2 we provide mathematical arguments for why this alignment occurs, showing that the alignment is not due to the change in <bold>W</bold><sup>out</sup> alone, but rather to coordinated changes in the readout and recurrent weights.</p>
<p>In deriving the RFLO learning rule, two independent approximations were made: locality was enforced by dropping the nonlocal term from the loss function gradient, and feedback weights were chosen randomly rather than tuned to match the readout weights. If these approximations are instead made independently, which will have the greater effect on the performance of the RNN&#x003F; <xref ref-type="fig" rid="fig2">Figure 2d</xref> answers this question by comparing RFLO and BPTT with two alternative learning rules: one in which the local approximation is made while symmetric error feedback is maintained, and another in which the nonlocal part of the loss function gradient is retained but the error feedback is random. The results show that the local approximation is essentially fully responsible for the performance difference between RFLO and BPTT, while there is no significant loss in performance due to the random feedback alone.</p>
</sec>
<sec id="s2d">
<title>Interval matching</title>
<p><xref ref-type="fig" rid="fig3">Figure 3</xref> illustrates the performance of the RFLO algorithm on a &#x201C;Ready Set Go&#x201D; task, in which the RNN is required to produce an output pulse after a time delay matching the delay between two preceding input pulses [<xref ref-type="bibr" rid="c15">15</xref>]. This task is more difficult than the production of a periodic output due to the requirement that the RNN must learn to store the information about the interpulse delay, and then produce responses at different times depending on what the delay was. <xref ref-type="fig" rid="fig3">Figures 3b,c</xref> illustrate the testing performance of an RNN trained with either RFLO learning or BPTT. If the RNN is trained and tested on interpulse delays satisfying <italic>T</italic><sub>delay</sub> &#x2264; 15<italic>&#x03C4;</italic>, the performance is similarly good for the two algorithms. If the RNN is trained and tested with longer <italic>T</italic><sub>delay</sub>, however, then BPTT performs better than RFLO learning. As in the case of the periodic output task from <xref ref-type="fig" rid="fig2">Figure 2</xref>, RFLO learning performs well for tasks on short and intermediate timescales, but not as well as BPTT for tasks involving longer timescales. We shall return to this point below in the following subsection.</p>
<fig id="fig3" position="float"><label>Figure 3:</label><caption><title>Interval-matching task.</title><p>(a) In the task, the RNN input consists of two input pulses, with a random delay <italic>T</italic><sub>delay</sub> between pulses in each trial. The target output (dashed line) is a pulse trailing the second input pulse by <italic>T</italic><sub>delay</sub>. (b) The time of the peak in the RNN output is observed after training with RFLO learning and testing in trials with various interpulse delays in the input. Red (blue) shows the case in which the RNN is trained with interpulse delays satisfying <italic>T</italic><sub>delay</sub> &#x2264; 15<italic>&#x03C4;</italic> (20<italic>&#x03C4;</italic>). (c) Same as (b), but with the RNN trained using BPTT using interpulse delays <italic>T</italic><sub>delay</sub> &#x2264; 25<italic>&#x03C4;</italic> for training and testing. The parameters used in all cases were <italic>N</italic> &#x003D; 100 and <italic>&#x03C4;</italic> &#x003D; 10, with 5000 trials of training.</p></caption><graphic xlink:href="458570_fig3.tif"/></fig>
</sec>
<sec id="s2e">
<title>Learning a sequence of actions</title>
<p>In the above examples, it was shown that, while the performance of RFLO learning is comparable to that of BPTT for tasks over short and intermediate timescales, it is less impressive for tasks involving longer timescales. From the perspective of machine learning, this represents a failure of RFLO learning. From the perspective of neuroscience, however, we can adopt a more constructive attitude. The brain, after all, suffers the same limitations that we have imposed in constructing the RFLO learning rule&#x2014;namely, causality and locality&#x2014;and cannot be performing BPTT for learned movements and working memory tasks over long timescales of seconds or more. So how might recurrent circuits in the brain learn to perform tasks over these long timescales&#x003F; One possibility is that they use a more sophisticated learning rule than the one that we have constructed. While we cannot rule out this possibility, it is worth keeping in mind that, due to the problem of vanishing or exploding gradients, all gradient-based training methods for RNNs fail eventually at long timescales. Another possibility is that a simple, fully connected recurrent circuit in the brain, like an RNN trained with RFLO learning, can only be trained directly with supervised learning over short timescales, and that a more complex circuit architecture is necessary for longer timescales.</p>
<p>It has long been recognized that long-duration behaviors tend to be sequences composed of short, stereotyped actions concatenated together [<xref ref-type="bibr" rid="c16">16</xref>]. Further, a great deal of experimental work suggests that learning of this type involves training of synaptic weights from cortex to striatum [<xref ref-type="bibr" rid="c17">17</xref>], the input structure of the basal ganglia, which in turn modifies cortical activity via thalamus. In this section we propose a circuit architecture, partially borrowed from Ref. [<xref ref-type="bibr" rid="c18">18</xref>] and inspired by the subcortical loop involving basal ganglia and thalamus, that allows an RNN to learn and perform sequences of &#x201C;behavioral syllables&#x201D;.</p>
<p>As illustrated in <xref ref-type="fig" rid="fig4">Figure 4a</xref>, the first stage of learning in this scheme involves training an RNN to produce a distinct time-dependent output in response to the activation of each of its tonic inputs. In this case, the RNN output is a two-dimensional vector giving the velocity of a cursor moving in a plane. Once the RNN has been trained in this way, the circuit is augmented with a loop structure, shown schematically in <xref ref-type="fig" rid="fig4">Figure 4b</xref>. At one end of the loop, the RNN activity is read out with weights <italic>W<sup>s</sup></italic>. At the other end of the loop, this readout is used to control the input to the RNN. The weights <italic>W<sup>s</sup></italic> can be learned such that, at the end of one behavioral syllable, the RNN input driving the next syllable in the sequence is activated by the auxiliary loop. This is done most easily by gating the RNN readout so that it can only drive changes at the end of a syllable.</p>
<fig id="fig4" position="float"><label>Figure 4:</label><caption><title>An RNN with multiple inputs controlled by an auxiliary loop learns to produce sequences.</title><p>(a) An RNN with a two-dimensional readout controlling the velocity of a cursor is trained to move the cursor in a different direction for each of the four possible inputs. (b) The RNN is augmented with a loop structure, which allows a readout from the RNN via learned weights <italic>W<sup>s</sup></italic> to change the state of the input to the RNN, enabling the RNN state at the end of each cursor movement to trigger the beginning of the next movement. (c) The trajectory of a cursor performing four movements and four holds, where RFLO learning was used to train the individual movements as in (a), and learning of the weights <italic>W<sup>s</sup></italic> was used to join these movements into a sequence, as illustrated in (b).</p></caption><graphic xlink:href="458570_fig4.tif"/></fig>
<p>In this example, each time the end of a syllable is reached, four readout units receive input <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_inline2.gif"/></alternatives></inline-formula>, and a winner-take-all rule is applied such that the most active unit activates a corresponding RNN input unit, which drives the RNN to produce the next syllable. Meanwhile, the weights are updated with the reward-modulated Hebbian learning rule <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_inline3.gif"/></alternatives></inline-formula>, where <italic>R</italic> &#x003D; 1 if the syllable transition matches the target and <italic>R</italic> &#x003D; 0 otherwise. By training over many trials, the network learns to match the target sequence of syllables. <xref ref-type="fig" rid="fig4">Figure 4c</xref> shows the output from an RNN trained in this way to produce a sequence of reaches and holds in a two-dimensional space. Importantly, while the duration of each behavioral syllable in this example (20<italic>&#x03C4;</italic>) is relatively short, the full concatenated sequence is long (160<italic>&#x03C4;</italic>) and would be very difficult to train directly in an RNN lacking such a loop structure.</p>
<p>How might the loop architecture illustrated in <xref ref-type="fig" rid="fig4">Figure 4</xref> be instantiated in the brain&#x003F; For learned motor control, motor cortex likely plays the role of the recurrent circuit controlling movements. In addition to projections to spinal cord for controlling movement directly, motor cortex also projects to striatum, and experimental evidence has suggested that modification of these corticostriatal synapses plays an important role in the learning of action sequences [<xref ref-type="bibr" rid="c19">19</xref>]. Via a loop through the basal ganglia output nucleus GPi and motor thalamus, these signals pass back to motor cortex, as illustrated schematically in <xref ref-type="fig" rid="fig4">Figure 4</xref>. According to the model, then, behavioral syllables are stored in motor cortex, and the role of striatum is to direct the switching from one syllable to the next. Experimental evidence for both the existence of behavioral syllables and the role played by striatum in switching between syllables on subsecond timescales has been found recently in mice [<xref ref-type="bibr" rid="c20">20</xref>, <xref ref-type="bibr" rid="c21">21</xref>]. How might the weights from motor cortex in this model be gated so that this projection is active at behavioral transitions&#x003F; It is well known that dopamine, in addition to modulating plasticity at corticostriatal synapses, also modulates the gain of cortical inputs to striatum [<xref ref-type="bibr" rid="c22">22</xref>]. Further, it has recently been shown that transient dopamine signals occur at the beginning of each movement in a lever-press sequence in mice [<xref ref-type="bibr" rid="c23">23</xref>]. Together, these experimental results support a model in which dopamine bursts enable striatum to direct switching between behavioral syllables, thereby allowing for learned behavioral sequences to occur over long timescales by enabling the RNN to control its own input. Within this framework, RFLO learning provides a biologically plausible means by which the behavioral syllables making up these sequences might be learned.</p>
</sec>
</sec>
<sec id="s3">
<title>Discussion</title>
<p>In this work we have derived an approximation to gradient-based learning rules for RNNs, yielding a learning rule that is local, online, and does not require fine tuning of feedback weights. We have shown that RFLO learning performs comparably well to BPTT when the duration of the task being trained is not too long, but that it performs less well when the task duration becomes very long. In this case, however, we showed that training can still be effective if the RNN architecture is augmented to enable the concatenation of short-duration outputs into longer output sequences. Further exploring how this augmented architecture might map onto cortical and subcortical circuits in the brain is an interesting direction for future work.</p>
<p>How might RFLO learning be implemented concretely in the brain&#x003F; As we have discussed above, motor cortex is an example of a recurrent circuit that can be trained to produce a particular time-dependent output. Neurons in motor cortex receive information about planned actions (<bold>y</bold>&#x002A;(<italic>t</italic>) in the language of the model) from premotor cortical areas, as well as information about the current state of the body (<bold>y</bold>(<italic>t</italic>)) from visual and/or proprioceptive inputs, giving them the information necessary to compute a time-dependent error <italic>&#x03B5;</italic>(<italic>t</italic>) &#x003D; <bold>y</bold>&#x002A;(<italic>t</italic>) &#x2014; y(<italic>t</italic>). Hence it is possible that neurons within motor cortex might use a projection of this error signal to learn to produce a target output trajectory. Such a computation might feature a special role for apical dendrites, as in recently developed theories for learning in feedforward cortical networks [<xref ref-type="bibr" rid="c31">31</xref>, <xref ref-type="bibr" rid="c32">32</xref>], though further work would be needed to build a detailed theory for its implementation in recurrent cortical circuits.</p>
<p>A possible alternative scenario is that neuromodulators might encode error signals. In particular, midbrain dopamine neurons project to many frontal cortical areas including prefrontal cortex and motor cortex, and their input is known to be necessary for learning certain time-dependent behaviors [<xref ref-type="bibr" rid="c33">33</xref>, <xref ref-type="bibr" rid="c34">34</xref>]. Further, recent experiments have shown that the signals encoded by dopamine neurons are significantly richer than the reward prediction error that has traditionally been associated with dopamine, and include phasic modulation during movements [<xref ref-type="bibr" rid="c35">35</xref>, <xref ref-type="bibr" rid="c23">23</xref>, <xref ref-type="bibr" rid="c36">36</xref>]. This interpretation of dopamine as a continuous online error signal used for supervised learning would be distinct from and complementary to its well known role as an encoder of reward prediction error for reinforcement learning.</p>
<p>In addition to RFLO learning, a number of other local and causal learning rules for training RNNs have been proposed. The oldest of these algorithms [<xref ref-type="bibr" rid="c24">24</xref>, <xref ref-type="bibr" rid="c25">25</xref>] operate within the framework of reinforcement learning rather than supervised learning, meaning that only a scalar&#x2014;and possibly temporally delayed&#x2014; reward signal is available for training the RNN, rather than the full target function <italic>y</italic>&#x002A;(<italic>t</italic>). Typical of such algorithms, which are often known as &#x201C;node perturbation&#x201D; algorithms, is the REINFORCE learning rule [<xref ref-type="bibr" rid="c25">25</xref>], which in our notation gives the following weight update at the end of each trial:
<disp-formula id="eqn6">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn6.gif"/></alternatives>
</disp-formula>
where <italic>R</italic> is the scalar reward signal (which might be defined as the negative of the loss function that we have used in RFLO learning), <italic>R&#x0305;</italic> is the average reward over recent trials, and <italic>&#x03BE;<sub>a</sub></italic>(<italic>t</italic>) is noise current injected into unit <italic>a</italic> during training. This learning rule means, for example, that (assuming the presynaptic unit <italic>b</italic> is active) if the postsynaptic unit <italic>a</italic> is more active than usual in a given trial (i.e. <italic>&#x03BE;<sub>a</sub></italic>(<italic>t</italic>) is positive) and the reward is greater than expected, then the synaptic weight <italic>W<sub>ab</sub></italic> should be increased so that this postsynaptic unit should be more active in future trials. A slightly more elaborate version of this learning rule replaces the summand in (<xref ref-type="disp-formula" rid="eqn6">6</xref>) with a low-pass filtered version of this same quantity, leading to eligibility traces of similar form to those appearing in (<xref ref-type="disp-formula" rid="eqn5">5</xref>). Fiete and Seung [<xref ref-type="bibr" rid="c26">26</xref>] have developed a version of this learning rule for spiking neurons.</p>
<p>A potential shortcoming of the REINFORCE learning rule is that it depends on the postsynaptic noise current rather than on the total postsynaptic input current (i.e. the noise current plus the input current from presynaptic units). Because it is arguably implausible that a neuron could keep track of these sources of input current separately, a recently proposed version [<xref ref-type="bibr" rid="c27">27</xref>] replaces <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_inline4.gif"/></alternatives></inline-formula>, where <italic>f</italic> (&#x00B7;) is a supralinear function, <italic>u<sub>a</sub></italic> (<italic>t</italic>) is the total input current (including noise) to unit <italic>a</italic>, and <italic>u&#x0305;<sub>a</sub></italic>(<italic>t</italic>) is the low-pass-filtered input current. This substitution is logical since the quantity <italic>u<sub>a</sub></italic>(<italic>t</italic>) &#x2014; <italic>u&#x0305;<sub>a</sub></italic>(<italic>t</italic>) tracks the fast fluctuations of each unit, which are mainly due to the rapidly fluctuating input noise rather than to the more slowly varying recurrent and feedforward inputs.</p>
<p>A severe limitation of reinforcement learning as formulated in (<xref ref-type="disp-formula" rid="eqn6">6</xref>) is the sparsity of reward information, which comes in the form of a single scalar value at the end of each trial. Clearly this provides the RNN with much less information to learn from than a vector of errors <italic>&#x03B5;</italic>(<italic>t</italic>) &#x003D; <bold>y</bold>&#x002A;(<italic>t</italic>) &#x2014; <bold>y</bold>(<italic>t</italic>) at every timestep, which is assumed to be available in supervised learning. As one would expect from this observation, reinforcement learning is typically much slower than supervised learning in RNNs, as in feedforward neural networks. A hybrid approach is to assume that reward information is scalar, as in reinforcement learning, but available at every timestep, as in supervised learning. This might correspond to setting <italic>R</italic>(<italic>t</italic>) &#x2161; &#x2014;&#x007C;<italic>&#x03B5;</italic>(<italic>t</italic>)&#x007C;<sup>2</sup> and including this reward in a learning rule such as the REINFORCE rule in (<xref ref-type="disp-formula" rid="eqn6">6</xref>). To our knowledge this has not been done for training recurrent weights in an RNN, though a similar idea has recently been used for training the readout weights of an RNN [<xref ref-type="bibr" rid="c28">28</xref>]. Ultimately, whether recurrent neural circuits in the brain use reinforcement learning or supervised learning is likely to depend on the task being learned and what feedback information about performance is available. For example, in a reach-to-target task such as the one modeled in <xref ref-type="fig" rid="fig4">Figure 4</xref>, it is plausible that a human or nonhuman primate might have a mental template of an ideal reach, and might make corrections to make the hand match the target trajectory at each timepoint in the trial. On the other hand, if only delayed binary feedback is provided in an interval-matching task such as the one modeled in <xref ref-type="fig" rid="fig3">Figure 3</xref>, neural circuits in the brain might be more likely to use reinforcement learning.</p>
<p>More recently, local, online algorithms for supervised learning in RNNs with spiking neurons have been proposed. Gilra and Gerstner [<xref ref-type="bibr" rid="c29">29</xref>] and Alemi et al [<xref ref-type="bibr" rid="c30">30</xref>] have trained spiking RNNs to produce particular dynamical trajectories of RNN readouts. These works constitute a large step toward greater biological plausibility, particularly in their use of local learning rules and spiking neurons. Here we describe the most important differences between those works and RFLO learning. In both Ref. [<xref ref-type="bibr" rid="c29">29</xref>] and [<xref ref-type="bibr" rid="c30">30</xref>], the RNN is driven by an input <bold>x</bold>(<italic>t</italic>) as well as the error signal <italic>&#x03B5;</italic>(<italic>t</italic>) &#x003D; <bold>y</bold>&#x002A;(<italic>t</italic>) &#x2014; <bold>y</bold>(<italic>t</italic>), where the target output is related to the input x(<italic>t</italic>) according to
<disp-formula id="eqn7">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn7.gif"/></alternatives>
</disp-formula>
where <italic>g<sub>j</sub></italic>(<bold>x</bold>) &#x003D; <italic>x<sub>j</sub></italic>(<italic>t</italic>) in Ref. [<xref ref-type="bibr" rid="c30">30</xref>], but is arbitrary in Ref. [<xref ref-type="bibr" rid="c29">29</xref>]. In either case, however, it is not possible to learn arbitrary, time-dependent mappings between inputs and outputs in these networks, since the RNN output must take the form of a dynamical system driven by the RNN input. This is especially limiting if one desires that the RNN dynamics should be autonomous, so that <bold>x</bold>(<italic>t</italic>) &#x003D; 0 in (<xref ref-type="disp-formula" rid="eqn7">7</xref>). It is not obvious, for example, what dynamical equations having the form of (<xref ref-type="disp-formula" rid="eqn7">7</xref>) would provide a solution to the interval-matching task studied in <xref ref-type="fig" rid="fig3">Figure 3</xref>. Of course, it is always possible to obtain an arbitrarily complex readout by making x(<italic>t</italic>) sufficiently large such that y(<italic>t</italic>) simply follows x(<italic>t</italic>) from (<xref ref-type="disp-formula" rid="eqn7">7</xref>). However, since x(<italic>t</italic>) is provided as input, the RNN essentially becomes an autoencoder in this limit.</p>
<p>Two other features of Refs. [<xref ref-type="bibr" rid="c29">29</xref>, <xref ref-type="bibr" rid="c30">30</xref>] differ from RFLO learning. First, the readout weights and the error feedback weights are related to one another in a highly specific way, being either symmetric with one another [<xref ref-type="bibr" rid="c30">30</xref>], or else configured such that the loop from the RNN to the readout and back to the RNN via the error feedback pathway forms an autoencoder [<xref ref-type="bibr" rid="c29">29</xref>]. In either case these weights are preset to these values before training of the RNN begins, unlike the randomly set feedback weights used in RFLO learning. Second, both approaches require that the error signal <italic>&#x03B5;</italic>(<italic>t</italic>) be fed back to the network with (at least initially) sufficiently large gain such that the RNN dynamics are essentially slaved to produce the target readout <bold>y</bold>&#x002A;(<italic>t</italic>), so that one has y(<italic>t</italic>) &#x2248; <bold>y</bold>&#x002A;(<italic>t</italic>) immediately from the beginning of training. (This follows as a consequence of the relation between the readout and feedback weights described above.) With RFLO learning, in contrast, forcing the output to always follow the target in this way is not necessary, and learning can work even if the RNN dynamics early in learning do not resemble the dynamics of the ultimate solution.</p>
<p>In summary, the random feedback learning rule that we propose offers a potential advantage over previous biologically plausible learning rules by making use of the full time-dependent, possibly multidimensional error signal, and also by training all weights in the network, including input, output, and recurrent weights. In addition, it does not require any special relation between the RNN inputs and outputs, nor any special relationship between the readout and feedback weights, nor a mechanism that restricts the RNN dynamics to always match the target from the start of training. Especially when extended to allow for sequence learning such as depicted in <xref ref-type="fig" rid="fig4">Figure 4</xref>, RFLO learning provides a plausible mechanism by which supervised learning might be implemented in recurrent circuits in the brain.</p>
</sec>
</body>
<back>
<ack>
<title>Acknowledgments</title>
<p>The author is grateful to L.F. Abbott, G.S. Escola, and A. Litwin-Kumar for helpful discussions and feedback on the manuscript. Support for this work was provided by the National Science Foundation NeuroNex program (DBI-1707398), the National Institutes of Health (DP5 OD019897), and the Gatsby Charitable Foundation.</p>
</ack>
<ref-list>
<title>References</title>
<ref id="c1"><label>[1]</label><mixed-citation publication-type="journal"><string-name><given-names>Valerio</given-names> <surname>Mante</surname></string-name>, <string-name><given-names>David</given-names> <surname>Sussillo</surname></string-name>, <string-name><given-names>Krishna V</given-names> <surname>Shenoy</surname></string-name>, and <string-name><given-names>William T</given-names> <surname>Newsome</surname></string-name>. <article-title>Context-dependent computation by recurrent dynamics in prefrontal cortex</article-title>. <source>nature</source>, <volume>503</volume>(<issue>7474</issue>):<fpage>78</fpage>, <year>2013</year>.</mixed-citation></ref>
<ref id="c2"><label>[2]</label><mixed-citation publication-type="journal"><string-name><given-names>Federico</given-names> <surname>Carnevale</surname></string-name>, <string-name><given-names>Victor</given-names> <surname>de Lafuente</surname></string-name>, <string-name><given-names>Ranulfo</given-names> <surname>Romo</surname></string-name>, <string-name><given-names>Omri</given-names> <surname>Barak</surname></string-name>, and <string-name><given-names>Nestor</given-names> <surname>Parga</surname></string-name>. <article-title>Dynamic control of response criterion in premotor cortex during perceptual detection under temporal uncertainty</article-title>. <source>Neuron</source>, <volume>86</volume>(<issue>4</issue>):<fpage>1067</fpage>&#x2013;<lpage>1077</lpage>, <year>2015</year>.</mixed-citation></ref>
<ref id="c3"><label>[3]</label><mixed-citation publication-type="journal"><string-name><given-names>David</given-names> <surname>Sussillo</surname></string-name>, <string-name><given-names>Mark M</given-names> <surname>Churchland</surname></string-name>, <string-name><given-names>Matthew T</given-names> <surname>Kaufman</surname></string-name>, and <string-name><given-names>Krishna V</given-names> <surname>Shenoy</surname></string-name>. <article-title>A neural network that finds a naturalistic solution for the production of muscle activity</article-title>. <source>Nature neuroscience</source>, <volume>18</volume>(<issue>7</issue>):<fpage>1025</fpage>, <year>2015</year>.</mixed-citation></ref>
<ref id="c4"><label>[4]</label><mixed-citation publication-type="journal"><string-name><given-names>Evan D</given-names> <surname>Remington</surname></string-name>, <string-name><given-names>Devika</given-names> <surname>Narain</surname></string-name>, <string-name><given-names>Eghbal A</given-names> <surname>Hosseini</surname></string-name>, and <string-name><given-names>Mehrdad</given-names> <surname>Jazayeri</surname></string-name>. <article-title>Flexible sensorimotor computations through rapid reconfiguration of cortical dynamics</article-title>. <source>Neuron</source>, <volume>98</volume>(<issue>5</issue>):<fpage>1005</fpage>&#x2013;<lpage>1019</lpage>, <year>2018</year>.</mixed-citation></ref>
<ref id="c5"><label>[5]</label><mixed-citation publication-type="book"><string-name><given-names>David E</given-names> <surname>Rumelhart</surname></string-name>, <string-name><given-names>Geoffrey E</given-names> <surname>Hinton</surname></string-name>, and <string-name><given-names>Ronald J</given-names> <surname>Williams</surname></string-name>. <chapter-title>Learning internal representations by error propagation</chapter-title>. <source>Technical report</source>, <publisher-name>California Univ San Diego La Jolla Inst for Cognitive Science</publisher-name>, <year>1985</year>.</mixed-citation></ref>
<ref id="c6"><label>[6]</label><mixed-citation publication-type="journal"><string-name><given-names>Ronald J</given-names> <surname>Williams</surname></string-name> and <string-name><given-names>David</given-names> <surname>Zipser</surname></string-name>. <article-title>A learning algorithm for continually running fully recurrent neural networks</article-title>. <source>Neural computation</source>, <volume>1</volume>(<issue>2</issue>):<fpage>270</fpage>&#x2013;<lpage>280</lpage>, <year>1989</year>.</mixed-citation></ref>
<ref id="c7"><label>[7]</label><mixed-citation publication-type="journal"><string-name><given-names>Herbert</given-names> <surname>Jaeger</surname></string-name> and <string-name><given-names>Harald</given-names> <surname>Haas</surname></string-name>. <article-title>Harnessing nonlinearity: Predicting chaotic systems and saving energy in wireless communication</article-title>. <source>science</source>, <volume>304</volume>(<issue>5667</issue>):<fpage>78</fpage>&#x2013;<lpage>80</lpage>, <year>2004</year>.</mixed-citation></ref>
<ref id="c8"><label>[8]</label><mixed-citation publication-type="journal"><string-name><given-names>David</given-names> <surname>Sussillo</surname></string-name> and <string-name><given-names>Larry F</given-names> <surname>Abbott</surname></string-name>. <article-title>Generating coherent patterns of activity from chaotic neural networks</article-title>. <source>Neuron</source>, <volume>63</volume>(<issue>4</issue>):<fpage>544</fpage>&#x2013;<lpage>557</lpage>, <year>2009</year>.</mixed-citation></ref>
<ref id="c9"><label>[9]</label><mixed-citation publication-type="journal"><string-name><given-names>Timothy P</given-names> <surname>Lillicrap</surname></string-name>, <string-name><given-names>Daniel</given-names> <surname>Cownden</surname></string-name>, <string-name><given-names>Douglas B</given-names> <surname>Tweed</surname></string-name>, and <string-name><given-names>Colin J</given-names> <surname>Akerman</surname></string-name>. <article-title>Random synaptic feedback weights support error backpropagation for deep learning</article-title>. <source>Nature communications</source>, <volume>7</volume>, <year>2016</year>.</mixed-citation></ref>
<ref id="c10"><label>[10]</label><mixed-citation publication-type="journal"><string-name><given-names>Qianli</given-names> <surname>Liao</surname></string-name>, <string-name><given-names>Joel Z</given-names> <surname>Leibo</surname></string-name>, and <string-name><given-names>Tomaso A</given-names> <surname>Poggio</surname></string-name>. <article-title>How important is weight symmetry in backpropaga- tion?</article-title> In <source>AAAI</source>, pages <fpage>1837</fpage>&#x2013;<lpage>1844</lpage>, <year>2016</year>.</mixed-citation></ref>
<ref id="c11"><label>[11]</label><mixed-citation publication-type="journal"><string-name><given-names>Wulfram</given-names> <surname>Gerstner</surname></string-name>, <string-name><given-names>Marco</given-names> <surname>Lehmann</surname></string-name>, <string-name><given-names>Vasiliki</given-names> <surname>Liakoni</surname></string-name>, <string-name><given-names>Dane</given-names> <surname>Corneil</surname></string-name>, and <string-name><given-names>Johanni</given-names> <surname>Brea</surname></string-name>. <article-title>Eligibility traces and plasticity on behavioral time scales: Experimental support of neohebbian three-factor learning rules</article-title>. <source>arXiv preprint arXiv:1801.05219</source>, <year>2018</year>.</mixed-citation></ref>
<ref id="c12"><label>[12]</label><mixed-citation publication-type="journal"><string-name><given-names>Arild</given-names> <surname>Nokland</surname></string-name>. <article-title>Direct feedback alignment provides learning in deep neural networks</article-title>. In <source>Advances in Neural Information Processing Systems</source>, pages <fpage>1037</fpage>&#x2013;<lpage>1045</lpage>, <year>2016</year>.</mixed-citation></ref>
<ref id="c13"><label>[13]</label><mixed-citation publication-type="journal"><string-name><given-names>Henry</given-names> <surname>Dale</surname></string-name>. <source>Pharmacology and nerve-endings</source>, <year>1935</year>.</mixed-citation></ref>
<ref id="c14"><label>[14]</label><mixed-citation publication-type="journal"><string-name><given-names>H</given-names> <surname>Francis Song</surname></string-name>, <string-name><given-names>Guangyu R</given-names> <surname>Yang</surname></string-name>, and <string-name><given-names>Xiao-Jing</given-names> <surname>Wang</surname></string-name>. <article-title>Training excitatory-inhibitory recurrent neural networks for cognitive tasks: a simple and flexible framework</article-title>. <source>PLoS computational biology</source>, <volume>12</volume>(<issue>2</issue>):<elocation-id>e1004792</elocation-id>, <year>2016</year>.</mixed-citation></ref>
<ref id="c15"><label>[15]</label><mixed-citation publication-type="journal"><string-name><given-names>Mehrdad</given-names> <surname>Jazayeri</surname></string-name> and <string-name><given-names>Michael N</given-names> <surname>Shadlen</surname></string-name>. <article-title>Temporal context calibrates interval timing</article-title>. <source>Nature neuroscience</source>, <volume>13</volume>(<issue>8</issue>):<fpage>1020</fpage>, <year>2010</year>.</mixed-citation></ref>
<ref id="c16"><label>[16]</label><mixed-citation publication-type="book"><string-name><given-names>Karl</given-names> <surname>Spencer Lashley</surname></string-name>. <source>The problem of serial order in behavior</source>, volume <volume>21</volume>. <publisher-name>Bobbs-Merrill</publisher-name>, <year>1951</year>.</mixed-citation></ref>
<ref id="c17"><label>[17]</label><mixed-citation publication-type="journal"><string-name><given-names>Ann M</given-names> <surname>Graybiel</surname></string-name>. <article-title>The basal ganglia and chunking of action repertoires</article-title>. <source>Neurobiology of learning and memory</source>, <volume>70</volume>(<issue>1-2</issue>):<fpage>119</fpage>&#x2013;<lpage>136</lpage>, <year>1998</year>.</mixed-citation></ref>
<ref id="c18"><label>[18]</label><mixed-citation publication-type="journal"><string-name><given-names>L</given-names> <surname>Logiaco</surname></string-name>, <string-name><given-names>LF</given-names> <surname>Abbott</surname></string-name>, and <string-name><given-names>GS</given-names> <surname>Escola</surname></string-name>. <article-title>The corticothalamic loop can control cortical dynamics for flexible robust motor output</article-title>, <year>2018</year>. <source>Poster at Cosyne2018</source> (<ext-link ext-link-type="uri" xlink:href="http://www.cosyne.org">http://www.cosyne.org</ext-link>).</mixed-citation></ref>
<ref id="c19"><label>[19]</label><mixed-citation publication-type="journal"><string-name><given-names>Xin</given-names> <surname>Jin</surname></string-name> and <string-name><given-names>Rui M</given-names> <surname>Costa</surname></string-name>. <article-title>Start/stop signals emerge in nigrostriatal circuits during sequence learning</article-title>. <source>Nature</source>, <volume>466</volume>(<issue>7305</issue>):<fpage>457</fpage>, <year>2010</year>.</mixed-citation></ref>
<ref id="c20"><label>[20]</label><mixed-citation publication-type="journal"><string-name><given-names>Alexander B</given-names> <surname>Wiltschko</surname></string-name>, <string-name><given-names>Matthew J</given-names> <surname>Johnson</surname></string-name>, <string-name><given-names>Giuliano</given-names> <surname>Iurilli</surname></string-name>, <string-name><given-names>Ralph E</given-names> <surname>Peterson</surname></string-name>, <string-name><given-names>Jesse M</given-names> <surname>Katon</surname></string-name>, <string-name><given-names>Stan L</given-names> <surname>Pashkovski</surname></string-name>, <string-name><given-names>Victoria E</given-names> <surname>Abraira</surname></string-name>, <string-name><given-names>Ryan P</given-names> <surname>Adams</surname></string-name>, and <string-name><given-names>Sandeep Robert</given-names> <surname>Datta</surname></string-name>. <article-title>Mapping sub-second structure in mouse behavior</article-title>. <source>Neuron</source>, <volume>88</volume>(<issue>6</issue>):<fpage>1121</fpage>&#x2013;<lpage>1135</lpage>, <year>2015</year>.</mixed-citation></ref>
<ref id="c21"><label>[21]</label><mixed-citation publication-type="journal"><string-name><given-names>Jeffrey E</given-names> <surname>Markowitz</surname></string-name>, <string-name><given-names>Winthrop F</given-names> <surname>Gillis</surname></string-name>, <string-name><given-names>Celia C</given-names> <surname>Beron</surname></string-name>, <string-name><given-names>Shay Q</given-names> <surname>Neufeld</surname></string-name>, <string-name><given-names>Keiramarie</given-names> <surname>Robertson</surname></string-name>, <string-name><given-names>Neha D</given-names> <surname>Bhagat</surname></string-name>, <string-name><given-names>Ralph E</given-names> <surname>Peterson</surname></string-name>, <string-name><given-names>Emalee</given-names> <surname>Peterson</surname></string-name>, <string-name><given-names>Minsuk</given-names> <surname>Hyun</surname></string-name>, <string-name><given-names>Scott W</given-names> <surname>Linderman</surname></string-name>, <etal>et al.</etal> <article-title>The striatum organizes 3d behavior via moment-to-moment action selection</article-title>. <source>Cell</source>, <year>2018</year>.</mixed-citation></ref>
<ref id="c22"><label>[22]</label><mixed-citation publication-type="journal"><string-name><given-names>Charles R</given-names> <surname>Gerfen</surname></string-name> and <string-name><given-names>D</given-names> <surname>James Surmeier</surname></string-name>. <article-title>Modulation of striatal projection systems by dopamine</article-title>. <source>Annual review of neuroscience</source>, <volume>34</volume>:<fpage>441</fpage>&#x2013;<lpage>466</lpage>, <year>2011</year>.</mixed-citation></ref>
<ref id="c23"><label>[23]</label><mixed-citation publication-type="journal"><collab>Joaquim Alves da Silva</collab>, <string-name><given-names>Fatuel</given-names> <surname>Tecuapetla</surname></string-name>, <string-name><given-names>Vitor</given-names> <surname>Paixao</surname></string-name>, and <string-name><given-names>Rui M</given-names> <surname>Costa</surname></string-name>. <article-title>Dopamine neuron activity before action initiation gates and invigorates future movements</article-title>. <source>Nature</source>, <volume>554</volume>(<issue>7691</issue>):<fpage>244</fpage>, <year>2018</year>.</mixed-citation></ref>
<ref id="c24"><label>[24]</label><mixed-citation publication-type="journal"><string-name><given-names>Pietro</given-names> <surname>Mazzoni</surname></string-name>, <string-name><given-names>Richard A</given-names> <surname>Andersen</surname></string-name>, and <string-name><given-names>Michael I</given-names> <surname>Jordan</surname></string-name>. <article-title>A more biologically plausible learning rule for neural networks</article-title>. <source>Proceedings of the National Academy of Sciences</source>, <volume>88</volume>(<issue>10</issue>):<fpage>4433</fpage>&#x2013;<lpage>4437</lpage>, <year>1991</year>.</mixed-citation></ref>
<ref id="c25"><label>[25]</label><mixed-citation publication-type="journal"><string-name><given-names>Ronald J</given-names> <surname>Williams</surname></string-name>. <article-title>Simple statistical gradient-following algorithms for connectionist reinforcement learning</article-title>. <source>Machine learning</source>, <volume>8</volume>(<issue>3-4</issue>):<fpage>229</fpage>&#x2013;<lpage>256</lpage>, <year>1992</year>.</mixed-citation></ref>
<ref id="c26"><label>[26]</label><mixed-citation publication-type="journal"><string-name><given-names>Ila R</given-names> <surname>Fiete</surname></string-name> and <string-name><given-names>H</given-names> <surname>Sebastian Seung</surname></string-name>. <article-title>Gradient learning in spiking neural networks by dynamic perturbation of conductances</article-title>. <source>Physical review letters</source>, <volume>97</volume>(<issue>4</issue>):<fpage>048104</fpage>, <year>2006</year>.</mixed-citation></ref>
<ref id="c27"><label>[27]</label><mixed-citation publication-type="journal"><string-name><given-names>Thomas</given-names> <surname>Miconi</surname></string-name>. <article-title>Biologically plausible learning in recurrent neural networks reproduces neural dynamics observed during cognitive tasks</article-title>. <source>eLife</source>, <volume>6</volume>:<elocation-id>e20899</elocation-id>, <year>2017</year>.</mixed-citation></ref>
<ref id="c28"><label>[28]</label><mixed-citation publication-type="journal"><string-name><given-names>Robert</given-names> <surname>Legenstein</surname></string-name>, <string-name><given-names>Steven M</given-names> <surname>Chase</surname></string-name>, <string-name><given-names>Andrew B</given-names> <surname>Schwartz</surname></string-name>, and <string-name><given-names>Wolfgang</given-names> <surname>Maass</surname></string-name>. <article-title>A reward-modulated hebbian learning rule can explain experimentally observed network reorganization in a brain control task</article-title>. <source>Journal of Neuroscience</source>, <volume>30</volume>(<issue>25</issue>):<fpage>8400</fpage>&#x2013;<lpage>8410</lpage>, <year>2010</year>.</mixed-citation></ref>
<ref id="c29"><label>[29]</label><mixed-citation publication-type="journal"><string-name><given-names>Aditya</given-names> <surname>Gilra</surname></string-name> and <string-name><given-names>Wulfram</given-names> <surname>Gerstner</surname></string-name>. <article-title>Predicting non-linear dynamics by stable local learning in a recurrent spiking neural network</article-title>. <source>Elife</source>, <volume>6</volume>:<elocation-id>e28295</elocation-id>, <year>2017</year>.</mixed-citation></ref>
<ref id="c30"><label>[30]</label><mixed-citation publication-type="journal"><string-name><given-names>Alireza</given-names> <surname>Alemi</surname></string-name>, <string-name><given-names>Christian</given-names> <surname>Machens</surname></string-name>, <string-name><given-names>Sophie</given-names> <surname>Deneve</surname></string-name>, and <string-name><given-names>Jean-Jacques</given-names> <surname>Slotine</surname></string-name>. <article-title>Learning arbitrary dynamics in efficient, balanced spiking networks using local plasticity rules</article-title>. <source>arXiv preprint arXiv:1705.08026</source>, <year>2017</year>.</mixed-citation></ref>
<ref id="c31"><label>[31]</label><mixed-citation publication-type="journal"><string-name><given-names>Jordan</given-names> <surname>Guerguiev</surname></string-name>, <string-name><given-names>Timothy P</given-names> <surname>Lillicrap</surname></string-name>, and <string-name><given-names>Blake A</given-names> <surname>Richards</surname></string-name>. <article-title>Towards deep learning with segregated dendrites</article-title>. <source>ELife</source>, <volume>6</volume>:<elocation-id>e22901</elocation-id>, <year>2017</year>.</mixed-citation></ref>
<ref id="c32"><label>[32]</label><mixed-citation publication-type="journal"><string-name><given-names>Joao</given-names> <surname>Sacramento</surname></string-name>, <string-name><given-names>Rui</given-names> <surname>Ponte Costa</surname></string-name>, <string-name><given-names>Yoshua</given-names> <surname>Bengio</surname></string-name>, and <string-name><given-names>Walter</given-names> <surname>Senn</surname></string-name>. <article-title>Dendritic error backpropagation in deep cortical microcircuits</article-title>. <source>arXiv preprint arXiv:1801.00062</source>, <year>2017</year>.</mixed-citation></ref>
<ref id="c33"><label>[33]</label><mixed-citation publication-type="journal"><string-name><given-names>Jonas A</given-names> <surname>Hosp</surname></string-name>, <string-name><given-names>Ana</given-names> <surname>Pekanovic</surname></string-name>, <string-name><given-names>Mengia S</given-names> <surname>Rioult-Pedotti</surname></string-name>, and <string-name><given-names>Andreas R</given-names> <surname>Luft</surname></string-name>. <article-title>Dopaminergic projections from midbrain to primary motor cortex mediate motor skill learning</article-title>. <source>Journal of Neuroscience</source>, <volume>31</volume>(<issue>7</issue>):<fpage>2481</fpage>&#x2013;<lpage>2487</lpage>, <year>2011</year>.</mixed-citation></ref>
<ref id="c34"><label>[34]</label><mixed-citation publication-type="journal"><string-name><given-names>Qian</given-names> <surname>Li</surname></string-name>, <string-name><given-names>Ho</given-names> <surname>Ko</surname></string-name>, <string-name><given-names>Zhong-Ming</given-names> <surname>Qian</surname></string-name>, <string-name><given-names>Leo YC</given-names> <surname>Yan</surname></string-name>, <string-name><given-names>Danny CW</given-names> <surname>Chan</surname></string-name>, <string-name><given-names>Gordon</given-names> <surname>Arbuthnott</surname></string-name>, <string-name><given-names>Ya</given-names> <surname>Ke</surname></string-name>, and <string-name><given-names>Wing-Ho</given-names> <surname>Yung</surname></string-name>. <article-title>Refinement of learned skilled movement representation in motor cortex deep output layer</article-title>. <source>Nature communications</source>, <volume>8</volume>:<fpage>15834</fpage>, <year>2017</year>.</mixed-citation></ref>
<ref id="c35"><label>[35]</label><mixed-citation publication-type="journal"><string-name><given-names>MW</given-names> <surname>Howe</surname></string-name> and <string-name><given-names>DA</given-names> <surname>Dombeck</surname></string-name>. <article-title>Rapid signalling in distinct dopaminergic axons during locomotion and reward</article-title>. <source>Nature</source>, <volume>535</volume>(<issue>7613</issue>):<fpage>505</fpage>, <year>2016</year>.</mixed-citation></ref>
<ref id="c36"><label>[36]</label><mixed-citation publication-type="journal"><string-name><given-names>Luke T</given-names> <surname>Coddington</surname></string-name> and <string-name><given-names>Joshua T</given-names> <surname>Dudman</surname></string-name>. <article-title>The timing of action determines reward prediction signals in identified midbrain dopamine neurons</article-title>. <source>Nature neuroscience</source>, page <fpage>1</fpage>, <year>2018</year>.</mixed-citation></ref>
<ref id="c37"><label>[37]</label><mixed-citation publication-type="book"><string-name><given-names>Ian</given-names> <surname>Goodfellow</surname></string-name>, <string-name><given-names>Yoshua</given-names> <surname>Bengio</surname></string-name>, and <string-name><given-names>Aaron</given-names> <surname>Courville</surname></string-name>. <source>Deep learning</source>. <publisher-name>MIT press</publisher-name>, <year>2016</year>.</mixed-citation></ref>
<ref id="c38"><label>[38]</label><mixed-citation publication-type="book"><string-name><given-names>Yann</given-names> <surname>Lecun</surname></string-name>. <chapter-title>A theoretical framework for back-propagation</chapter-title>. In <source>Proceedings of the 1988 Connectionist Models Summer School</source>, <publisher-loc>CMU, Pittsburg, PA</publisher-loc>. <publisher-name>Morgan Kaufmann</publisher-name>, <year>1988</year>.</mixed-citation></ref>
<ref id="c39"><label>[39]</label><mixed-citation publication-type="journal"><string-name><given-names>Francoise</given-names> <surname>Beaufays</surname></string-name> and <string-name><given-names>Eric A</given-names> <surname>Wan</surname></string-name>. <article-title>Relating real-time backpropagation and backpropagation-through- time: An application of flow graph interreciprocity</article-title>. <source>Neural computation</source>, <volume>6</volume>(<issue>2</issue>):<fpage>296</fpage>&#x2013;<lpage>306</lpage>, <year>1994</year>.</mixed-citation></ref>
<ref id="c40"><label>[40]</label><mixed-citation publication-type="journal"><string-name><given-names>Balasubrahmanyan</given-names> <surname>Srinivasan</surname></string-name>, <string-name><given-names>Upadrasta</given-names> <surname>Ravikirana Prasad</surname></string-name>, and <string-name><given-names>Nalam</given-names> <surname>Jaganmohan Rao</surname></string-name>. <article-title>Back propagation through adjoints for the identification of nonlinear dynamic systems using recurrent neural models</article-title>. <source>IEEE Transactions on Neural Networks</source>, <volume>5</volume>(<issue>2</issue>):<fpage>213</fpage>&#x2013;<lpage>228</lpage>, <year>1994</year>.</mixed-citation></ref>
<ref id="c41"><label>[41]</label><mixed-citation publication-type="book"><string-name><given-names>JJ</given-names> <surname>Sakurai</surname></string-name> <etal>et al.</etal> <source>Modern quantum mechanics</source>. <publisher-name>Addison-Wesley Pub. Co</publisher-name>., <year>1994</year>.</mixed-citation></ref>
</ref-list>
<fn-group>
<fn id="fn1"><label>1</label><p>While an RNN is often described as being &#x201C;unrolled in time&#x201C;, so that it becomes a feedforward network in which each layer corresponds to one timestep, it is important to note that the unrolled version of the problem that we consider here is not identical to the feedforward case considered in Refs. [<xref ref-type="bibr" rid="c9">9</xref>, <xref ref-type="bibr" rid="c12">12</xref>]. In the RNN, a readout error is defined at every &#x201C;layer&#x201D; <italic>t</italic>, whereas in the feedforward case, the error is defined only at the last layer (<italic>t</italic> = <italic>T</italic>) and is fed back to update weights in all preceding layers.</p></fn>
<fn id="fn2"><label>2</label><p>Thanks to A. Litwin-Kumar for discussion about this correspondence.</p></fn>
</fn-group>
<app-group>
<app id="app1">
<label>Appendix 1</label>
<title>Gradient-based RNN learning and RFLO learning</title>
<p>In the first subsection of this appendix, we begin by reviewing the derivation of RTRL [<xref ref-type="bibr" rid="c25">25</xref>], the classic gradient-based learning rule. We show that the update equation for the recurrent weights under the RTRL rule has two undesirable features from a biological point of view. First, the learning rule is nonlocal, with the update to weight <italic>W<sub>ij</sub></italic> depending on all of the other weights in the RNN, rather than just on information that is locally available to that particular synapse. Second, the RTRL learning rule requires that the error in the RNN readout be fed back into the RNN with weights that are precisely symmetric with the readout weights. In the second subsection, we implement approximations to the RTRL gradient in order to overcome these undesirable features, leading to the RFLO learning rules.</p>
<p>In the third subsection of this appendix, we review the derivation of BPTT, the most widely used algorithm for training RNNs. Because it is the standard gradient-based learning rule for RNN training, BPTT is the learning rule against which we compare RFLO learning in the main text. Finally, in the final subsection of this appendix we illustrate the equivalence of RTRL and BPTT. Although this is not strictly necessary for any of the results given in the main text, we expect that readers with an interest in gradient-based learning rules for training RNNs will be interested in this correspondence, which to our knowledge has not been very clearly explicated in the literature.</p>
<sec id="app1a">
<title>Real-time recurrent learning</title>
<p>In this section we review the derivation of the real-time recurrent learning (RTRL) algorithm [<xref ref-type="bibr" rid="c6">6</xref>] for an RNN such as the one shown in <xref ref-type="fig" rid="fig1">Figure 1</xref>. This rule is obtained by taking a gradient of the mean-squared output error of the RNN with respect to the synaptic weights, and, as we will show later in this appendix, is equivalent (when implemented in batches rather than online) to the more widely used backpropagation through time (BPTT) algorithm.</p>
<p>The standard RTRL algorithm is obtained by calculating the gradient of the loss function (<xref ref-type="disp-formula" rid="eqn2">2</xref>) with respect to the RNN weights, and then using gradient descent to find the weights that minimize the loss function [<xref ref-type="bibr" rid="c37">37</xref>]. Specifically, for each run of the network, one can calculate <italic>&#x2202;L</italic>/<italic>&#x2202;W<sub>ab</sub></italic> and then update the weights by an amount proportional to this gradient: &#x0394;<italic>W<sub>ab</sub></italic> &#x003D; &#x2014;<italic>&#x03B7;&#x2202;L</italic>/<italic>&#x2202;W<sub>ab</sub></italic>, where <italic>&#x03B7;</italic> determines the learning rate. This can be done similarly for the input and output weights, <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_inline5.gif"/></alternatives></inline-formula> and <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_inline6.gif"/></alternatives></inline-formula>, respectively. This results in the following update equations:
<disp-formula id="eqn8">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn8.gif"/></alternatives>
</disp-formula></p>
<p>In these equations, (&#x00B7;)<sup>T</sup> denotes matrix transpose, and the gradients of the hidden layer activities with respect to the recurrent and input weights are given by
<disp-formula id="eqn9">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn9.gif"/></alternatives>
</disp-formula>
where we have defined
<disp-formula id="eqn10">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn10.gif"/></alternatives>
</disp-formula>
and <bold>u</bold>(<italic>t</italic>) is the total input to each recurrent unit at time <italic>t</italic>:
<disp-formula id="eqn11">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn11.gif"/></alternatives>
</disp-formula></p>
<p>The recursions in (<xref ref-type="disp-formula" rid="eqn9">9</xref>) terminate with
<disp-formula id="eqn12">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn12.gif"/></alternatives>
</disp-formula></p>
<p>As many others have recognized previously, the synaptic weight updates given in the second and third lines of (<xref ref-type="disp-formula" rid="eqn8">8</xref>) are not biologically realistic for a number of reasons. First, the error is projected back into the network with the particular weight matrix (<italic>W</italic><sup>out</sup>)<sup>T</sup>, so that the feedback and readout weights must be related to one another in a highly specific way. Second, the terms involving <bold>W</bold> in (<xref ref-type="disp-formula" rid="eqn9">9</xref>) mean that information about the entire network is required to update any given synaptic weight, making the rules nonlocal. In contrast, a biologically plausible learning rule for updating a weight W<sub>ab</sub> or <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_inline7.gif"/></alternatives></inline-formula> ought to depend only on the activity levels of the pre- and post-synaptic units <italic>a</italic> and <italic>b</italic>, in addition to the error signal that is fed back into the network. Both of these shortcomings will be addressed in the following subsection.</p>
</sec>
<sec id="app1b">
<title>Random feedback local online learning</title>
<p>In order to obtain a biologically plausible learning rule, we can attempt to relax some of the requirements in the RTRL learning rule and see whether the RNN is still able to learn effectively. Inspired by a recently used approach in feedforward networks [<xref ref-type="bibr" rid="c9">9</xref>], we do this by replacing the (<italic>W</italic><sup>out</sup>)<sup>T</sup> appearing in the second and third lines of (<xref ref-type="disp-formula" rid="eqn8">8</xref>) with a fixed random matrix <bold>B</bold>, so that the feedback projection of the output error no longer needs to be tuned to match the other weights in the network in a precise way. Second, we simply drop the terms involving <bold>W</bold> in (<xref ref-type="disp-formula" rid="eqn9">9</xref>), so that nonlocal information about all recurrent weights in the network is no longer required to update a particular synaptic weight. In this case we can rewrite the approximate weight-update equations as
<disp-formula id="eqn13">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn13.gif"/></alternatives>
</disp-formula>
where
<disp-formula id="eqn14">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn14.gif"/></alternatives>
</disp-formula></p>
<p>Here we have defined rank-2 versions of the eligibility trace tensors from (<xref ref-type="disp-formula" rid="eqn10">10</xref>):
<disp-formula id="eqn15">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn15.gif"/></alternatives>
</disp-formula></p>
<p>As desired, the equations (<xref ref-type="disp-formula" rid="eqn13">13</xref>) are local, depending only on the pre- and post-synaptic activity, together with a random feedback projection of the error signal. In addition, because all of the quantities appearing in (<xref ref-type="disp-formula" rid="eqn13">13</xref>) are computed in real time as the RNN is run, the weight updates can be performed <italic>online</italic>, in contrast to BPTT, for which the dynamics over all timesteps must be run first forward and then backward before making any weight updates. Hence, we refer to the learning rule given by (<xref ref-type="disp-formula" rid="eqn13">13</xref>)-(<xref ref-type="disp-formula" rid="eqn10">10</xref>) as random feedback local online (RFLO) learning.</p>
</sec>
<sec id="app1c">
<title>Backpropagation through time</title>
<p>Because it is the standard algorithm used for training RNNs, in this section we review the derivation of the learning rules for backpropagation through time (BPTT) [<xref ref-type="bibr" rid="c5">5</xref>] in order to compare it with the learning rules presented above. The derivation here follows Ref. [<xref ref-type="bibr" rid="c38">38</xref>].</p>
<p>Consider the following Lagrangian function:
<disp-formula id="eqn16">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn16.gif"/></alternatives>
</disp-formula></p>
<p>The second line is the cost function that is to be minimized, while the first line uses the Lagrange multiplier z(<italic>t</italic>) to enforce the constraint that the dynamics of the RNN should follow (<xref ref-type="disp-formula" rid="eqn1">1</xref>). From (<xref ref-type="disp-formula" rid="eqn16">16</xref>) we can also define the following action:
<disp-formula id="eqn17">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn17.gif"/></alternatives>
</disp-formula></p>
<p>We now proceed by minimizing (<xref ref-type="disp-formula" rid="eqn17">17</xref>) with respect to each of its arguments. First, taking dS/dz<sub>i</sub>(<italic>t</italic>) just gives the dynamical equation (<xref ref-type="disp-formula" rid="eqn1">1</xref>). Next, we set <italic>&#x2202;S</italic>/<italic>&#x2202;h<sub>i</sub></italic>(<italic>t</italic>) &#x003D; 0, which yields
<disp-formula id="eqn18">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn18.gif"/></alternatives>
</disp-formula>
which applies at timesteps <italic>t</italic> &#x003D; 1,&#x2026;,<italic>T</italic> &#x2014; 1. To obtain the value at the final timestep, we take <italic>&#x2202;S</italic>/<italic>&#x2202;z<sub>i</sub></italic>(<italic>T</italic>), which leads to
<disp-formula id="eqn19">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn19.gif"/></alternatives>
</disp-formula></p>
<p>Finally, taking the derivative with respect to the weights leads to the following:
<disp-formula id="eqn20">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn20.gif"/></alternatives>
</disp-formula></p>
<p>Rather than setting these derivatives equal to zero, which may lead to an undesired solution that corresponds to a maximum or saddle point of the action and would in any case be intractable, we use the gradients in (<xref ref-type="disp-formula" rid="eqn20">20</xref>) to perform gradient descent, reducing the error in an iterative fashion:
<disp-formula id="eqn21">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn21.gif"/></alternatives>
</disp-formula>
where <italic>&#x03B7;<sub>i</sub></italic> are learning rates.</p>
<p>The BPTT algorithm then proceeds in three steps. First the dynamical equations (<xref ref-type="disp-formula" rid="eqn1">1</xref>) for <bold>h</bold>(<italic>t</italic>) are integrated forward in time, beginning with the initial condition <bold>h</bold>(0). Second, the auxiliary variable <bold>z</bold>(<italic>t</italic>) is integrated <italic>backwards</italic> in time using (<xref ref-type="disp-formula" rid="eqn18">18</xref>), using with the <bold>h</bold>(<italic>t</italic>) saved from the forward pass and the boundary condition <bold>z</bold>(<italic>t</italic>) from (<xref ref-type="disp-formula" rid="eqn19">19</xref>). Third, the weights are updated according to (<xref ref-type="disp-formula" rid="eqn21">21</xref>), using <bold>h</bold>(<italic>t</italic>) and <bold>z</bold>(<italic>t</italic>) saved from the preceding two steps.</p>
<p>Note that no approximations have been made in computing the gradients using either the RTRL or BPTT procedures. In fact, as we will show in the following section, the two algorithms are completely equivalent, at least in the case where RFLO weight updates are performed only at the end of each trial rather than at every timestep.</p>
</sec>
<sec id="app1d">
<title>A unified view of gradient-based learning in recurrent networks</title>
<p>As pointed out previously [<xref ref-type="bibr" rid="c39">39</xref>, <xref ref-type="bibr" rid="c40">40</xref>], the difference between RTRL and BPTT can ultimately be traced to distinct methods of bookkeeping in applying the chain rule to the gradient of the loss function.<sup><xref ref-type="fn" rid="fn2">2</xref></sup> In order to make this explicit, we begin by noting that, when taking implicit dependences into account, the loss function defined in (<xref ref-type="disp-formula" rid="eqn2">2</xref>) has the form
<disp-formula id="eqn22">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn22.gif"/></alternatives>
</disp-formula></p>
<p>In this section, we write <bold>h</bold><sup><italic>t</italic></sup> &#x2261; <bold>h</bold>(<italic>t</italic>) for notational convenience, and consider only updates to the recurrent weights <bold>W</bold>, ignoring the input x(<italic>t</italic>) to the RNN. In any gradient-based learning scheme, the weight update &#x0394;<italic>W<sub>ab</sub></italic> should be proportional to the gradient of the loss function, which has the form
<disp-formula id="eqn23">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn23.gif"/></alternatives>
</disp-formula></p>
<p>The difference between RTRL and BPTT arises from the two possible ways of keeping track of the implicit dependencies from (<xref ref-type="disp-formula" rid="eqn22">22</xref>), which give rise to the following equivalent formulations of (<xref ref-type="disp-formula" rid="eqn23">23</xref>):
<disp-formula id="eqn24">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn24.gif"/></alternatives>
</disp-formula></p>
<p>In RTRL, the first derivative is simple to compute because loss function is treated as an explicit function of the variables <bold>h</bold><sup><italic>t</italic></sup>. The dependence of <bold>h</bold><sup><italic>t</italic></sup> on <bold>W</bold> and <bold>h</bold><sup><italic>t&#x2032;</italic></sup> (where <italic>t&#x2032;</italic> &#x003C; <italic>t</italic>) is then taken into account in the second derivative, which must be computed recursively due to the nested dependence on <bold>W</bold>. In BPTT, on the other hand, the implicit dependencies are dealt with in the first derivative, which in this case must be computed recursively because all terms at times <italic>t&#x2032;</italic> &#x003E; <italic>t</italic> depend implicitly on <bold>h</bold><sup><italic>t</italic></sup>. The second derivative then becomes simple since these dependencies are no longer present.</p>
<p>Let us define the following:
<disp-formula id="eqn25">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn25.gif"/></alternatives>
</disp-formula></p>
<p>Then, using the definition of <italic>L</italic> from (<xref ref-type="disp-formula" rid="eqn2">2</xref>) and the dynamical equation (<xref ref-type="disp-formula" rid="eqn1">1</xref>) for <bold>h</bold><sup><italic>t</italic></sup> to take the other derivatives appearing in (<xref ref-type="disp-formula" rid="eqn24">24</xref>), we have
<disp-formula id="eqn26">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn26.gif"/></alternatives>
</disp-formula></p>
<p>The recursion relations follow from application of the chain rule in the definitions from (<xref ref-type="disp-formula" rid="eqn25">25</xref>):
<disp-formula id="eqn27">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn27.gif"/></alternatives>
</disp-formula></p>
<p>These recursion relations are identical to those appearing in (<xref ref-type="disp-formula" rid="eqn9">9</xref>) and (<xref ref-type="disp-formula" rid="eqn18">18</xref>). Notably, the first is computed forward in time, while the second is computed backward in time. Because no approximations have been made in computing the gradient in either case for (<xref ref-type="disp-formula" rid="eqn26">26</xref>), the two methods are equivalent, at least if RTRL weight updates are made only at the end of each trial, rather than online. For this reason, only one of the algorithms (BPTT) was compared against RFLO learningx in the main text.</p>
<p>As discussed in previous sections, RTRL has the advantages of obeying causality and of allowing for weights to be continuously updated. But, as discussed above, RTRL has the disadvantage of being nonlocal, and also features a greater computational cost due to the necessity of updating a rank-3 tensor <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_inline8.gif"/></alternatives></inline-formula> rather than a vector <italic>Z<sub>i</sub></italic>(<italic>t</italic>) at each timestep. By dropping the second term in the first line of (<xref ref-type="disp-formula" rid="eqn27">27</xref>), RFLO learning eliminates both of these undesirable features, so that the resulting algorithm is causal, online, local, and has a computational complexity (&#x007E; <italic>N</italic><sup>2</sup> per timestep, vs. &#x007E; <italic>N</italic><sup>4</sup> for RTRL) on par with BPTT.</p>
</sec>
</app>
<app id="app2">
<label>Appendix 2</label>
<title>Analysis of the RFLO learning rule</title>
<p>Given that the learning rules in (<xref ref-type="disp-formula" rid="eqn5">5</xref>) do not move the weights directly along the steepest path that would minimize the loss function (as would the learning rules in (<xref ref-type="disp-formula" rid="eqn8">8</xref>)), it is worthwhile to ask whether it can be shown that these learning rules in general decrease the loss function at all. To answer this question, we consider the change in weights after one trial lasting T timesteps, working in the continuous-time limit for convenience, and performing weight updates only at the end of the trial:
<disp-formula id="eqn28">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn28.gif"/></alternatives>
</disp-formula>
where <italic>&#x03B4;</italic><bold>W</bold> and <italic>&#x03B4;</italic><bold>W</bold><sup>out</sup> are given by (<xref ref-type="disp-formula" rid="eqn5">5</xref>). For simplicity in this section we ignore the updates to the input weights, since the results in this case are very similar to those for recurrent weight updates.</p>
<p>In the first subsection of this appendix, we show that, under some approximations, the loss function tends to decrease on average under RFLO learning if there is positive alignment between the readout weights W<sup>out</sup> and the feedback weights B. In the second subsection, we show that this alignment tends to increase during RFLO learning.</p>
<sec id="app2a">
<title>Decrease of the loss function</title>
<p>We first consider the change in the loss function defined in (<xref ref-type="disp-formula" rid="eqn2">2</xref>) after updating the weights:
<disp-formula id="eqn29">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn29.gif"/></alternatives>
</disp-formula></p>
<p>Assuming the weight updates to be small, we ignore terms beyond leading order in &#x0394;W and &#x0394;W<sup>out</sup>. Then, using the update rules in (<xref ref-type="disp-formula" rid="eqn28">28</xref>) and performing some algebra, (<xref ref-type="disp-formula" rid="eqn29">29</xref>) becomes
<disp-formula id="eqn30">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn30.gif"/></alternatives>
</disp-formula></p>
<p>Clearly the first term in (<xref ref-type="disp-formula" rid="eqn30">30</xref>) always tends to decrease the loss function, as we would expect given that the precise gradient of <italic>L</italic> with respect to <bold>W</bold><sup>out</sup> was used to determine this part of the learning rule. We now wish to show that, at least on average and with some simplifying assumptions, the second term in (<xref ref-type="disp-formula" rid="eqn30">30</xref>) tends to be negative as well. Before beginning, we note in passing that this term is manifestly nonpositive like the first term if we perform RTRL, in which case <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_inline9.gif"/></alternatives></inline-formula>, making the gradient exact.</p>
<p>In order to analyze &#x0394;<italic>L</italic><sup>(2)</sup>, we will assume that the RNN is linear, with <italic>&#x03D5;</italic>(<italic>x</italic>) &#x003D; <italic>x</italic>. Further, we will average over the RNN activity <bold>h</bold>(<italic>t</italic>), assuming that the activities are correlated from one timestep to the next, but not from one unit to the next:
<disp-formula id="eqn31">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn31.gif"/></alternatives>
</disp-formula></p>
<p>The correlation function should be peaked at a positive value at <italic>t</italic> &#x2014; <italic>t&#x2032;</italic> &#x003D; 0 and decay to 0 at much earlier and later times. Finally, because of the antisymmetry under <italic>x</italic> &#x2192; &#x2014;<italic>x</italic>, odd powers of <bold>h</bold> will average to zero: &#x3008;<italic>h<sub>i</sub></italic>&#x3009;<sub>h</sub> &#x003D; &#x3008;<italic>h<sub>i</sub>h<sub>j</sub>h<sub>k</sub></italic>&#x3009;<sub>h</sub> &#x003D; &#x00B0;.</p>
<p>With these assumptions, we can express the activity-averaged second line of (<xref ref-type="disp-formula" rid="eqn30">30</xref>) as &#x3008;&#x0394;<italic>L</italic><sup>(2)</sup>&#x3009;<sub>h</sub> &#x003D; <italic>F</italic><sub>1</sub> &#x002B; <italic>F</italic><sub>2</sub>, with
<disp-formula id="eqn32">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn32.gif"/></alternatives>
</disp-formula>
and
<disp-formula id="eqn33">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn33.gif"/></alternatives>
</disp-formula></p>
<p>In order to make further progress, we can perform an ensemble average over <bold>W</bold>, assuming that <italic>W<sub>ij</sub> N</italic>(0, <italic>g</italic><sup>2</sup>/<italic>N</italic>) is a random variable, which leads to
<disp-formula id="eqn34">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn34.gif"/></alternatives>
</disp-formula></p>
<p>This leads to
<disp-formula id="eqn35">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn35.gif"/></alternatives>
</disp-formula>
and
<disp-formula id="eqn36">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn36.gif"/></alternatives>
</disp-formula></p>
<p>Putting (<xref ref-type="disp-formula" rid="eqn35">35</xref>) and (<xref ref-type="disp-formula" rid="eqn36">36</xref>) together, changing one integration variable, and dropping the terms smaller than <italic>O</italic>(<italic>N</italic>) then gives
<disp-formula id="eqn37">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn37.gif"/></alternatives>
</disp-formula></p>
<p>Because we have assumed that <italic>C</italic>(<italic>t</italic>) &#x2265; 0, the sign of this quantity depends only on the sign of the two terms in the second line of (<xref ref-type="disp-formula" rid="eqn37">37</xref>).</p>
<p>Already we can see that (<xref ref-type="disp-formula" rid="eqn37">37</xref>) will tend to be negative when W<sup>out</sup> is aligned with <italic>B</italic>. To see this, suppose that <bold>B</bold> &#x003D; <italic>&#x03B1;</italic><bold>W</bold><sup>out</sup>, with <italic>&#x03B1;</italic> &#x003E; 0. Due to the exponential factor, the integrand will be vanishingly small except when <italic>t</italic> &#x2248;<italic>t&#x2032;</italic>, so that the first term in the second line in this case can be written as &#x2248; <italic>&#x03B1;</italic>&#x007C;(<bold>W</bold><sup>out</sup>)<sup>T</sup><bold>y</bold>&#x002A;(<italic>t</italic>)&#x007C;<sup>2</sup> &#x2265; 0. The second term, meanwhile, becomes <italic>&#x03B1;C</italic>(<italic>t</italic> &#x2014; <italic>t&#x2032;</italic>)Tr [((<bold>W</bold><sup>out</sup>)<sup>T</sup><bold>W</bold><sup>out</sup>)<sup>2</sup>] &#x2265; 0.</p>
<p>The situation is most transparent if we assume that the RNN readout is one-dimensional, in which case the readout and feedback weights become vectors <bold>w</bold><sup>out</sup> and b, respectively, and (<xref ref-type="disp-formula" rid="eqn37">37</xref>) becomes
<disp-formula id="eqn38">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn38.gif"/></alternatives>
</disp-formula></p>
<p>In this case it is clear that, as in the case of feedforward networks [<xref ref-type="bibr" rid="c9">9</xref>], the loss function tends to decrease when the readout weights become aligned with the feedback weights. In the following subsection we will show that, at least under similar approximations to the ones made here, such alignment does in fact occur.</p>
</sec>
<sec id="app2b">
<title>Alignment of readout weights with feedback weights</title>
<p>In the preceding subsection it was shown that, assuming a linear RNN and averaging over activities and recurrent weights, the loss function tends to decrease when the alignment between the readout weights <bold>W</bold><sup>out</sup> and the feedback weights <bold>B</bold> becomes positive. Does such alignment indeed occur&#x003F;</p>
<p>In order to address this question, we consider the quantity Tr(<bold>W</bold><sup>out</sup><bold>B</bold>) and ask how it changes following one cycle of training, with combined weight updates on <bold>W</bold> and <bold>W</bold><sup>out</sup>. (As in the preceding subsection, external input to the RNN is ignored here for simplicity.) The effect of modifying the readout weights is obvious from (<xref ref-type="disp-formula" rid="eqn13">13</xref>):
<disp-formula id="eqn39">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn39.gif"/></alternatives>
</disp-formula></p>
<p>The update to the recurrent weights, on the other hand, modifies <bold>h</bold>(<italic>t</italic>) in the above equation. Because we are interested in the combined effect of the two weight updates and are free to make the learning rates arbitrarily small, we focus on the following quantity:
<disp-formula id="eqn40">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn40.gif"/></alternatives>
</disp-formula></p>
<p>The goal of this subsection is thus to show that (at least on average) <italic>G</italic> &#x003E; 0.</p>
<p>In order to evaluate this quantity, we need to know how the RNN activity <bold>h</bold>(<italic>t</italic>) depends on the weight modification &#x0394;<bold>W</bold>. As in the preceding subsection, we will assume a linear RNN and will work in the continuous-time limit (<italic>&#x03C4;</italic> &#x226B; 1) for convenience. In this case, the dynamics are given by
<disp-formula id="eqn41">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn41.gif"/></alternatives>
</disp-formula></p>
<p>If we wish to integrate this equation to get <bold>h</bold>(<italic>t</italic>) and expand to leading order in &#x0394;<bold>W</bold>, care must be taken due to the fact that W and AW are non-commuting matrices. Taking a cue from perturbation theory in quantum mechanics [<xref ref-type="bibr" rid="c41">41</xref>], we can work in the &#x201C;interaction picture&#x201D; and obtain
<disp-formula id="eqn42">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn42.gif"/></alternatives>
</disp-formula>
where
<disp-formula id="eqn43">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn43.gif"/></alternatives>
</disp-formula></p>
<p>We can now expand (<xref ref-type="disp-formula" rid="eqn42">42</xref>) to obtain
<disp-formula id="eqn44">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn44.gif"/></alternatives>
</disp-formula></p>
<p>For a linear network, the update rule for <bold>W</bold> from (<xref ref-type="disp-formula" rid="eqn13">13</xref>) is then simply
<disp-formula id="eqn45">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn45.gif"/></alternatives>
</disp-formula>
where the bar denotes low-pass filtering:
<disp-formula id="eqn46">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn46.gif"/></alternatives>
</disp-formula></p>
<p>Combining (<xref ref-type="disp-formula" rid="eqn44">44</xref>)-(<xref ref-type="disp-formula" rid="eqn46">46</xref>), the time-dependent activity vector to leading order in <italic>&#x03B7;</italic><sub>2</sub> is
<disp-formula id="eqn47">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn47.gif"/></alternatives>
</disp-formula>
where <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_inline10.gif"/></alternatives></inline-formula> is the unperturbed RNN activity vector (i.e. without the weight update &#x0394;<bold>W</bold>). With this result, we can express (<xref ref-type="disp-formula" rid="eqn40">40</xref>) as <italic>G</italic> &#x003D; <italic>G</italic><sub>1</sub> &#x002B; <italic>G</italic><sub>2</sub>, where
<disp-formula id="eqn48">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn48.gif"/></alternatives>
</disp-formula>
and
<disp-formula id="eqn49">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn49.gif"/></alternatives>
</disp-formula></p>
<p>Here we have defined <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_inline11.gif"/></alternatives></inline-formula>.</p>
<p>In order to make further progress, we follow the approach of the previous subsection and perform an average over RNN activity vectors, which yields
<disp-formula id="eqn50">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn50.gif"/></alternatives>
</disp-formula>
and
<disp-formula id="eqn51">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn51.gif"/></alternatives>
</disp-formula></p>
<p>Similar to the integral in (<xref ref-type="disp-formula" rid="eqn37">37</xref>), both of these quantities will tend to be positive if we assume that <italic>C</italic>(<italic>t</italic>) &#x2265; 0 with a peak at <italic>t</italic> &#x003D; 0, and note that the integrand is large only when <italic>t</italic> &#x2248; <italic>t&#x2032;</italic>.</p>
<p>In order to make the result even more transparent, we can again consider the case of a one-dimensional readout, in which case (<xref ref-type="disp-formula" rid="eqn50">50</xref>) becomes
<disp-formula id="eqn52">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn52.gif"/></alternatives>
</disp-formula>
and
<disp-formula id="eqn53">
<alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="458570_eqn53.gif"/></alternatives>
</disp-formula></p>
<p>This version illustrates even more clearly that, given a well-behaved target output <italic>y</italic>&#x002A;(<italic>t</italic>), the right hand side of this equation tends to be positive.</p>
<p>Equation (<xref ref-type="disp-formula" rid="eqn50">50</xref>) (or, in the case of one-dimensional readout, (<xref ref-type="disp-formula" rid="eqn52">52</xref>)) shows that the overlap between the readout weights and feedback weights tends to increase with training. Equation (<xref ref-type="disp-formula" rid="eqn37">37</xref>) (or (<xref ref-type="disp-formula" rid="eqn38">38</xref>)) then shows that the readout error will tend to decrease during training given that this overlap is positive. While these mathematical results provide a compelling plausibility argument for the efficacy of RFLO learning, it is important to recall that some limiting assumptions were required in order to obtain them. Specifically, we assumed linearity of the RNN and vanishing of the cross-correlations in the RNN activity, neither of which is strictly true in a trained nonlinear network. In order to show that learning remains effective even without these limitations, we must turn to numerical simulations such as those performed in the main text.</p>
</sec>
</app>
</app-group>
</back>
</article>