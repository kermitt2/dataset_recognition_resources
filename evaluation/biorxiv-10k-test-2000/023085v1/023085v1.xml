<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.2d1 20170631//EN" "JATS-archivearticle1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" article-type="article" dtd-version="1.2d1" specific-use="production" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">BIORXIV</journal-id>
<journal-title-group>
<journal-title>bioRxiv</journal-title>
<abbrev-journal-title abbrev-type="publisher">bioRxiv</abbrev-journal-title>
</journal-title-group>
<publisher>
<publisher-name>Cold Spring Harbor Laboratory</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1101/023085</article-id>
<article-version>1.1</article-version>
<article-categories>
<subj-group subj-group-type="author-type">
<subject>Regular Article</subject>
</subj-group>
<subj-group subj-group-type="heading">
<subject>New Results</subject>
</subj-group>
<subj-group subj-group-type="hwp-journal-coll">
<subject>Bioinformatics</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>Ancestral gene synteny reconstruction improves extant species scaffolding</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<name><surname>Anselmetti</surname><given-names>Yoann</given-names></name>
<xref ref-type="aff" rid="a1">1</xref>
<xref ref-type="aff" rid="a3">3</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Berry</surname><given-names>Vincent</given-names></name>
<xref ref-type="aff" rid="a2">2</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Chauve</surname><given-names>Cedric</given-names></name>
<xref ref-type="aff" rid="a5">5</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Chateau</surname><given-names>Annie</given-names></name>
<xref ref-type="aff" rid="a2">2</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Tannier</surname><given-names>Eric</given-names></name>
<xref ref-type="aff" rid="a3">3</xref>
<xref ref-type="aff" rid="a4">4</xref>
</contrib>
<contrib contrib-type="author" corresp="yes">
<name><surname>B&#x00E9;rard</surname><given-names>S&#x00E8;verine</given-names></name>
<xref ref-type="aff" rid="a1">1</xref>
<xref ref-type="aff" rid="a2">2</xref>
<xref ref-type="corresp" rid="cor1">&#x002A;</xref>
</contrib>
<aff id="a1"><label>1</label><institution>Institut des Sciences de l&#x2019;&#x00C9;volution de Montpellier (ISE-M)</institution>, Place Eug&#x00E8;ne Bataillon, Montpellier, 34095, <country>France</country>.</aff>
<aff id="a2"><label>2</label><institution>Institut de Biologie Computationnelle (IBC), Laboratoire d&#x2019;Informatique, de Robotique et de Micro&#x00E9;lectronique de Montpellier (LIRMM), Universit&#x00E9; Montpellier - CNRS</institution>, 161 rue Ada, Montpellier, 34090, <country>France</country>.</aff>
<aff id="a3"><label>3</label><institution>Laboratoire de Biom&#x00E9;trie et Biologie &#x00C9;volutive (LBBE)</institution>, 43 boulevard du 11 novembre 1918, Villeurbanne, 69622, <country>France</country>.</aff>
<aff id="a4"><label>4</label><institution>Institut National de Recherche en Informatique et en Automatique (INRIA) Rh&#x00F4;ne-Alpes</institution>, 655 avenue de l&#x2019;Europe, Montbonnot-Saint-Martin, 38330, <country>France</country>.</aff>
<aff id="a5"><label>5</label><institution>Department of Mathematics, Simon Fraser University</institution>, 8888 University Drive, Burnaby, V5A 1S6, <country>Canada</country>.</aff>
</contrib-group>
<author-notes>
<corresp id="cor1"><label>&#x002A;</label>Correspondence: <email>severine.berard@umontpellier.fr</email></corresp>
</author-notes>
<pub-date pub-type="epub">
<year>2015</year>
</pub-date>
<elocation-id>023085</elocation-id>
<history>
<date date-type="received">
<day>22</day>
<month>7</month>
<year>2015</year>
</date>
<date date-type="accepted">
<day>23</day>
<month>7</month>
<year>2015</year>
</date>
</history>
<permissions>
<copyright-statement>&#x00A9; 2015, Posted by Cold Spring Harbor Laboratory</copyright-statement>
<copyright-year>2015</copyright-year>
<license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by/4.0/"><license-p>This pre-print is available under a Creative Commons License (Attribution 4.0 International), CC BY 4.0, as described at <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link></license-p></license>
</permissions>
<self-uri xlink:href="023085.pdf" content-type="pdf" xlink:role="full-text"/>
<abstract><title>Abstract</title>
<p>We exploit the methodological similarity between ancestral genome reconstruction and extant genome scaffolding. We present a method, called AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> that constructs neighborhood relationships between genes or contigs, in both ancestral and extant genomes, in a phylogenetic context. It is able to handle dozens of complete genomes, including genes with complex histories, by using gene phylogenies reconciled with a species tree, that is, annotated with speciation, duplication and loss events. Reconstructed ancestral or extant synteny comes with a support computed from an exhaustive exploration of the solution space. We compare our method with a previously published one that follows the same goal on a small number of genomes with universal unicopy genes. Then we test it on the whole Ensembl database, by proposing partial ancestral genome structures, as well as a more complete scaffolding for many partially assembled genomes on 69 eukaryote species. We carefully analyze a couple of extant adjacencies proposed by our method, and show that they are indeed real links in the extant genomes, that were missing in the current assembly. On a reduced data set of 39 eutherian mammals, we estimate the precision and sensitivity of AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> by simulating a fragmentation in some well assembled genomes, and measure how many adjacencies are recovered. We find a very high precision, while the sensitivity depends on the quality of the data and on the proximity of closely related genomes.</p>
</abstract>
<kwd-group kwd-group-type="author"><title>Keywords</title>
<kwd>ancestral genome reconstruction</kwd>
<kwd>genome scaffolding</kwd>
<kwd>parsimony</kwd>
<kwd>gene duplication/loss</kwd>
<kwd>gene tree/species tree reconciliation</kwd>
</kwd-group>
<counts>
<page-count count="22"/>
</counts>
</article-meta>
</front>
<body>
<sec id="s1"><title>Introduction</title>
<p>Knowledge of genome organization (gene content and order) and of its dynamics is an important question in several fields such as cancer genomics [<xref rid="c1" ref-type="bibr">1</xref>, <xref rid="c2" ref-type="bibr">2</xref>, <xref rid="c3" ref-type="bibr">3</xref>], to understand gene interactions involved in a common molecular pathway [<xref rid="c4" ref-type="bibr">4</xref>], or evolutionary biology, for example to establish a species phylogeny by comparative analysis of gene orders [<xref rid="c5" ref-type="bibr">5</xref>].</p>
<p>On one side, studying genome organization evolution, and in particular proposing gene orders for ancestral genomes, requires well assembled extant genomes, while, on the other side, the assembly of extant genomes can in return benefit from evolutionary studies. This calls for integrative methods for the joint scaffolding of extant genomes and reconstruction of ancestral genomes.</p>
<p>The reconstruction of ancestral genome organization is a classical computational biology problem [<xref rid="c6" ref-type="bibr">6</xref>], for which various methods have been developed [<xref rid="c7" ref-type="bibr">7</xref>, <xref rid="c8" ref-type="bibr">8</xref>, <xref rid="c9" ref-type="bibr">9</xref>, <xref rid="c10" ref-type="bibr">10</xref>, <xref rid="c11" ref-type="bibr">11</xref>, <xref rid="c12" ref-type="bibr">12</xref>, <xref rid="c13" ref-type="bibr">13</xref>]. The rapid accumulation of new genome sequences provides the opportunity to integrate a large number of genomes to reconstruct their structural evolution. However, a significant proportion of these genomes is incompletely assembled and remains at the state of contigs (permanent draft) as illustrated by statistics on GOLD [<xref rid="c14" ref-type="bibr">14</xref>]. To improve assemblies, methods known as scaffolding were developed to order contigs into scaffolds. Most scaffolding methods use either a reference genome, or the information provided by paired-end reads, or both [<xref rid="c15" ref-type="bibr">15</xref>, <xref rid="c16" ref-type="bibr">16</xref>, <xref rid="c17" ref-type="bibr">17</xref>, <xref rid="c18" ref-type="bibr">18</xref>, <xref rid="c19" ref-type="bibr">19</xref>, <xref rid="c20" ref-type="bibr">20</xref>, <xref rid="c21" ref-type="bibr">21</xref>, <xref rid="c22" ref-type="bibr">22</xref>]. We refer to Hunt et al. [<xref rid="c23" ref-type="bibr">23</xref>] for a detailed comparative analysis of recent scaffolding methods.</p>
<p>In recent developments, scaffolding methods taking into account multiple reference genomes and their phylogeny have been proposed [<xref rid="c24" ref-type="bibr">24</xref>, <xref rid="c25" ref-type="bibr">25</xref>, <xref rid="c26" ref-type="bibr">26</xref>, <xref rid="c27" ref-type="bibr">27</xref>]. It suggests a methodological link with ancestral genome reconstructions: if ancestral genes are considered as contigs, scaffolding extant or ancestral contigs in a phylogenetic context differs only in the location of the considered genome within the phylogeny (leaf or internal node). This link has been observed [<xref rid="c28" ref-type="bibr">28</xref>] and exploited to develop a method for combining scaffolding and ancestral genomes reconstruction [<xref rid="c29" ref-type="bibr">29</xref>]. However, the latter, due to the computational complexity of the ancestral genome reconstruction problem, is currently limited to a few genomes and to single-copy universal genes.</p>
<p>We propose to overcome this computational complexity by considering independent ancestral gene neighborhood reconstructions [<xref rid="c12" ref-type="bibr">12</xref>] instead of whole genomes, which allows to scale up to dozens of whole genomes and to use as input data genes with complex histories. We develop a method that scaffolds ancestral and extant genomes at the same time. The algorithm improves over previous methods of scaffolding by the full integration of the inference of evolutionary events within a phylogenetic context.</p>
<p>The principle of our method is imported from D<sc>E</sc>C<sc>O</sc> [<xref rid="c12" ref-type="bibr">12</xref>]. So we call it AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> for Assembly Recovery through D<sc>E</sc>C<sc>O</sc>. D<sc>E</sc>C<sc>O</sc> is an algorithm for ancestral synteny reconstruction. It is a dynamic programming scheme on pairs of reconciled gene tree, generalizing the classic dynamic programming scheme for parsimonious ancestral character reconstructions along a tree. It computes a parsimonious set of ancestral gene neighborhoods, the cost being computed as the weighted sum of gains and losses of such neighborhoods, due to genome rearrangements. In addition to D<sc>E</sc>C<sc>O</sc>, AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> considers a linkage probability for each couple of genes in extant genomes, that is included in the cost function in order to be able to propose gene neighborhoods in extant as well as in ancestral genomes.</p>
<p>We implemented AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> and tested it on several data sets. First we reproduced the experiment of [<xref rid="c29" ref-type="bibr">29</xref>] on 7 tetrapod genomes limited to universal unicopy genes, with comparable accuracy. Then we used all genes from 69 eukaryotic genomes from the Ensembl database [<xref rid="c30" ref-type="bibr">30</xref>]. The program runs in about 18h and is able to propose ancestral genome structures and thousands of extant scaffolding linkages. We examine in details one of them, chosen randomly on the panda genome, and show why it seems reasonable to propose it as an actual scaffolding adjacency. Then on a reduced data set of 39 whole mammalian genomes, we tested the precision and sensitivity of the scaffolding performed by AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> by simulating artificial fragmentation of the human or horse genomes, removing up to 75&#x0025; of the known gene neighborhoods of these well assembled genomes, and comparing the removed adjacencies with the ones proposed by AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc>. We measure a <italic>&#x003E;</italic> 95&#x0025; precision, while sensitivity, as expected, depends on the quality of the data and on the presence of closely related extant genomes. This denotes the domain of efficiency of our method: a vast majority of proposed adjacencies can be considered with confidence, but the final resulting scaffolding is still incomplete.</p>
</sec>
<sec id="s2"><title>Ancestral and extant adjacencies</title>
<p>We describe the AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> algorithm for the joint reconstruction of ancestral genomes and scaffolding of extant genomes. An overview is depicted in <xref ref-type="fig" rid="fig1">Figure 1</xref>.</p>
<fig id="fig1" position="float" fig-type="figure">
<label>Figure 1</label>
<caption><p>Input and output of the AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> method. The left box shows the input of AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc>: a species tree (here on extant species <italic>X</italic>, <italic>Y</italic> and <italic>Z</italic>), the adjacencies in the genome of extant species (each colored block represents a contig, that is, a linear arrangement of genes, linked by adjacencies) and the reconciled genes trees for their genes. The output of AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> is shown on the right-hand side in magenta color: the method computes both new adjacencies for extant species and contigs for the ancestral species.</p></caption>
<graphic xlink:href="023085_fig1.tif"/>
</fig>
<sec id="s2a"><title>Input</title>
<p>The input of the method is</p>
<list list-type="bullet">
<list-item><p>A species tree with all considered genomes and their descent pattern; We suppose the number of chromosomes of each extant genome is known.</p></list-item>
<list-item><p>A set of genes for all considered genomes, clustered into homologous families; for each family a rooted gene tree depicts the descent pattern of the genes.</p></list-item>
<list-item><p>A set of <italic>adjacencies</italic>, <italic>i.e.</italic>, pairwise relations between neighboring genes <italic>AB</italic> on extant chromosomes. Genes <italic>A</italic> and <italic>B</italic> are called the <italic>extremities</italic> of the adjacency <italic>AB</italic>. We consider as neighbors two genes that are not separated by another gene present in the dataset, but a relaxed definition can be used with no impact on the method itself.</p></list-item>
</list>
<p>Internal nodes of the species tree are labeled with ancestral species (we always consider ancestral species at the moment of a speciation) and leaves are labeled with extant species. Gene trees are reconciled with the species tree: all ancestral genes are labeled by the ancestral species they belong to, so the input yields a gene content for all ancestral species. Genes and species are partially ordered by the descent relation, so we may speak of a last, or lowest, or most recent common ancestor. Here, as in [<xref rid="c12" ref-type="bibr">12</xref>], we use a reconciliation minimizing the number of duplications and losses of genes.</p>
<p>A module of AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> is able to produce a suitable input from the raw Ensembl Compara [<xref rid="c30" ref-type="bibr">30</xref>] gene tree files and a species tree if needed. Once the input is given, two preliminaries are necessary: partitioning extant adjacencies and computing an a priori adjacency probability for each extant species. They are detailed in the two following subsections.</p>
</sec>
<sec id="s2b"><title>A partition of extant adjacencies</title>
<p>The goal of this step is, without loss of generality, to reduce the analysis of the whole data set to the independent analysis of pairs of gene trees and adjacencies, each having an extremity in each of the gene trees. Moreover, we want that the roots of the two gene trees correspond to ancestral genes mapping to the same ancestral species.</p>
<p>The partition is realized thanks to a necessary condition for two adjacencies to share a common ancestor. Two adjacencies <italic>A</italic><sub>1</sub><italic>B</italic><sub>1</sub> and <italic>A</italic><sub>2</sub><italic>B</italic><sub>2</sub>, for genes <italic>A</italic><sub>1</sub>, <italic>A</italic><sub>2</sub>, <italic>B</italic><sub>1</sub>, <italic>B</italic><sub>2</sub>, may have a common ancestor <italic>AB</italic> only if <italic>A</italic><sub>1</sub> and <italic>A</italic><sub>2</sub> (respectively <italic>B</italic><sub>1</sub> and <italic>B</italic><sub>2</sub>) are in the same gene family, so have a common ancestor <italic>A</italic> (respectively <italic>B</italic>), and such that <italic>A</italic> and <italic>B</italic> belong to the same species. In other words, the ancestral adjacency has the possibility to exist only when the genes of this adjacency are present in a same ancestral species.</p>
<p>It is easy to check that this relation is an equivalence relation, which then partitions adjacencies into equivalence classes. Each equivalence class <italic>C</italic> can be represented by two ancestral genes: they are the most ancient distinct <italic>A</italic> and <italic>B</italic> genes involved in the two-by-two comparisons of adjacencies <italic>A</italic><sub>1</sub><italic>B</italic><sub>1</sub> and <italic>A</italic><sub>2</sub><italic>B</italic><sub>2</sub> in this class. Necessarily every adjacency in this class has a gene which is a descendant of <italic>A</italic>, and another which is a descendant of <italic>B</italic>. <italic>A</italic> and <italic>B</italic> are in the same species (ancestral or extant), and cannot be the descendant one of another.</p>
<p>For a node <italic>N</italic> of a gene tree <italic>T</italic>, <italic>T</italic>(<italic>N</italic>) is the subtree of <italic>T</italic> rooted at <italic>N</italic>. Consider the two disjoint subtrees <italic>T</italic>(<italic>A</italic>) and <italic>T</italic>(<italic>B</italic>). All adjacencies in the equivalence class <italic>C</italic> have one extremity which is a leaf of <italic>T</italic>(<italic>A</italic>) and the other which is a leaf of <italic>T</italic>(<italic>B</italic>). So each equivalence class may be treated independently from the other, and the input can be restricted, without loss of generality, to <italic>T</italic>(<italic>A</italic>) and <italic>T</italic>(<italic>B</italic>).</p>
</sec>
<sec id="s2c"><title>An <italic>a priori</italic> probability for all adjacencies</title>
<p>Given two extant genes <italic>v</italic><sub>1</sub> and <italic>v</italic><sub>2</sub> from the same extant genome <italic>G</italic>, we give an <italic>a priori</italic> probability that there is an adjacency between <italic>v</italic><sub>1</sub> and <italic>v</italic><sub>2</sub>. If the genome <italic>G</italic> is perfectly assembled, then this probability is given by the input, that is, it is 1 if there is an adjacency in the input and 0 otherwise. But if the genome <italic>G</italic> is not perfectly assembled, then this probability depends on the quality of the assembly. It will allow the program to propose more adjacencies in extant genomes that are more fragmented.</p>
<p>We note <italic>n</italic> the number of contigs in an extant genome (which is the number of genes minus the number of adjacencies if all contigs are linear arrangements of genes), and <italic>p</italic> the number of chromosomes. We always have <italic>n</italic> &#x2265; <italic>p</italic> &#x003E; 0. All contigs are assumed to have two distinct extremities.</p>
<p>We call a <italic>solution</italic> of the scaffolding problem a set of <italic>n &#x2212; p</italic> adjacencies between the extremities of contigs, which forms <italic>p</italic> chromosomes from the <italic>n</italic> contigs. The number of different solutions for given <italic>n</italic> and <italic>p</italic> is denoted by <italic>f</italic>(<italic>n, p</italic>).</p>
<p>Let <italic>v</italic><sub>1</sub> and <italic>v</italic><sub>2</sub> be extremities of two different contigs; the <italic>a priori</italic> probability <italic>P</italic>(<italic>v</italic><sub>1</sub> &#x223C; <italic>v</italic><sub>2</sub>) of <italic>v</italic><sub>1</sub> and <italic>v</italic><sub>2</sub> to be adjacent if they are not seen adjacent in the data and <italic>n</italic> &#x003E; <italic>p</italic> is:
<disp-formula id="ueqn1"><alternatives><graphic xlink:href="023085_ueqn1.gif"/></alternatives></disp-formula>
where <italic>&#x03C1;</italic> is a correction function which is equal to 4 if <italic>v</italic><sub>1</sub> and <italic>v</italic><sub>2</sub> are the only genes in their contigs, 2 if one of <italic>v</italic><sub>1</sub> <italic>v</italic><sub>2</sub> is the only gene in its contig but not the other, and 1 otherwise. If <italic>n</italic> = <italic>p</italic>, we have <italic>P</italic>(<italic>v</italic><sub>1</sub> <italic>&#x223C; v</italic><sub>2</sub>) = 0 if the adjacency <italic>v</italic><sub>1</sub><italic>v</italic><sub>2</sub> is not in the data, and <italic>P</italic>(<italic>v</italic><sub>1</sub> <italic>&#x223C; v</italic><sub>2</sub>) = 1 otherwise.</p>
<p>For the computation of <italic>P</italic>(<italic>v</italic><sub>1</sub> <italic>&#x223C; v</italic><sub>2</sub>) we use the following formula for <italic>f</italic>(<italic>n, p</italic>).</p>
<statement id="stat1">
<label>Lemma 1</label>
<p><italic>For each n &#x2265;</italic> 1 <italic>and p</italic> &#x2208; &#x2115;&#x002A;, <italic>we have:</italic>
<disp-formula id="ueqn2"><alternatives><graphic xlink:href="023085_ueqn2.gif"/></alternatives></disp-formula>
<italic>Proof</italic> First remark that the formula <italic>f</italic>(<italic>n, p</italic>) can be extended to the case where <italic>p &#x003E; n</italic> and to the case where <italic>n &#x2265;</italic> 1 and <italic>p</italic> = 0, by setting its value to 0 in those cases (there is no possible way to transform <italic>n</italic> contigs into <italic>p</italic> chromosomes). In those cases, the equality is still true, since <inline-formula><alternatives><inline-graphic xlink:href="023085_inline1.gif"/></alternatives></inline-formula> is then equal to 0. Thus, in all what follows, we use this extension of definition when needed.</p>
<p>We proceed now by induction on <italic>n &#x2265;</italic> 1.</p>
<p>Base case: <italic>n</italic> = 1, it is straightforward since <inline-formula><alternatives><inline-graphic xlink:href="023085_inline2.gif"/></alternatives></inline-formula>, and for <italic>p &#x003E;</italic> 1, we have <inline-formula><alternatives><inline-graphic xlink:href="023085_inline3.gif"/></alternatives></inline-formula>, since the binomial coefficient is equal to 0 in this case.</p>
<p>Induction: we suppose that for each <italic>k &#x2264; n</italic>, for each <italic>p</italic> &#x2208; &#x2115;<italic>&#x002A;</italic>, we have:
<disp-formula id="ueqn3"><alternatives><graphic xlink:href="023085_ueqn3.gif"/></alternatives></disp-formula></p>
<p>We consider <italic>f</italic>(<italic>n</italic> &#x002B; 1, <italic>p</italic>), for a fixed <italic>p</italic> &#x2208; &#x2115;&#x002A;. We sum over all possibilities for one specific chromosome to be composed of <italic>x</italic> contigs. This gives the recurrence formula
<disp-formula id="ueqn4"><alternatives><graphic xlink:href="023085_ueqn4.gif"/></alternatives></disp-formula>
Where <inline-formula><alternatives><inline-graphic xlink:href="023085_inline4.gif"/></alternatives></inline-formula> is used to avoid couting the same solution several times. <inline-formula><alternatives><inline-graphic xlink:href="023085_inline5.gif"/></alternatives></inline-formula> can be written <inline-formula><alternatives><inline-graphic xlink:href="023085_inline6.gif"/></alternatives></inline-formula> representing the number of possibilities to sort <italic>x</italic> contigs, 2<sup><italic>x&#x2212;</italic>1</sup> allows to take into account contig orientations and <inline-formula><alternatives><inline-graphic xlink:href="023085_inline7.gif"/></alternatives></inline-formula> representsthe number of possibilities to pull <italic>x</italic> contigs of <italic>n</italic> &#x002B; 1.</p>
<p>By induction hypothesis, we have:
<disp-formula id="ueqn5"><alternatives><graphic xlink:href="023085_ueqn5.gif"/></alternatives></disp-formula>
which simplifies into:
<disp-formula id="ueqn6"><alternatives><graphic xlink:href="023085_ueqn6.gif"/></alternatives></disp-formula>
We change the variable in the sum, let <italic>h</italic> = <italic>n &#x2212; x</italic>. Then, we have:
<disp-formula id="ueqn7"><alternatives><graphic xlink:href="023085_ueqn7.gif"/></alternatives></disp-formula>
By the Hockey-stick&#x2019;s identity, namely for all <inline-formula><alternatives><inline-graphic xlink:href="023085_inline8.gif"/></alternatives></inline-formula> we finally obtain:
<disp-formula id="ueqn8"><alternatives><graphic xlink:href="023085_ueqn8.gif"/></alternatives></disp-formula>
which concludes the proof.</p>
<p>The expression of <italic>f</italic>(<italic>n, p</italic>) leads to the following simple expression for <italic>P</italic>:
<disp-formula id="ueqn9"><alternatives><graphic xlink:href="023085_ueqn9.gif"/></alternatives></disp-formula></p>
<p>We define <inline-formula><alternatives><inline-graphic xlink:href="023085_inline9.gif"/></alternatives></inline-formula> the part of this formula that does not depend on <italic>v</italic><sub>1</sub> and <italic>v</italic><sub>2</sub>, as an assembly fragmentation measure for genome <italic>S</italic>.</p>
</statement>
</sec>
<sec id="s2d"><title>A Dynamic programming scheme</title>
<p>We largely refer to D<sc>E</sc>C<sc>O</sc> [<xref rid="c12" ref-type="bibr">12</xref>] for a full description of the dynamic programming scheme, and only describe the overall principle and the differences we introduce. Adjacencies are constructed between ancestral genes (equivalently internal gene tree nodes), and propagate along gene trees. For two nodes <italic>v</italic><sub>1</sub> and <italic>v</italic><sub>2</sub> defining genes belonging to the same (ancestral or extant) species, we define a <italic>solution</italic> as a descent pattern of ancestral and extant adjacencies explaining the input extant adjacencies that have an extremity in <italic>T</italic>(<italic>v</italic><sub>1</sub>) and another in <italic>T</italic>(<italic>v</italic><sub>2</sub>). So a solution is a set of ancestral adjacencies and descent relations linking ancestral and extant adjacencies. The cost of a solution is the cumulative cost of gains and breakages of adjacencies (due to rearrangements) in the descent pattern, according to an individual cost for gains (<italic>Gain</italic>) and breakages (<italic>Br</italic>).</p>
<p>More precisely we define two costs <italic>c</italic><sub>0</sub>(<italic>v</italic><sub>1</sub>, <italic>v</italic><sub>2</sub>) (respectively <italic>c</italic><sub>1</sub>(<italic>v</italic><sub>1</sub>, <italic>v</italic><sub>2</sub>)), which are the minimum cost previously mentioned, given that there is an (respectively there is no) adjacency between <italic>v</italic><sub>1</sub> and <italic>v</italic><sub>2</sub> in a solution. All <italic>c</italic><sub>0</sub> and <italic>c</italic><sub>1</sub>, for every couple <italic>v</italic><sub>1</sub> and <italic>v</italic><sub>2</sub>, can be computed by the dynamic programming scheme described in [<xref rid="c12" ref-type="bibr">12</xref>]. AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> and D<sc>E</sc>C<sc>O</sc> have the same time complexity, that is <italic>O</italic>(<italic>g</italic><sup>2</sup> &#x00D7; <italic>k</italic><sup>2</sup>) where <italic>g</italic> is the number of gene trees in the input and <italic>k</italic> be the maximum size of a tree.</p>
<p>The main difference is that in [<xref rid="c12" ref-type="bibr">12</xref>] extant genomes were supposed to be perfectly assembled and in particular, if <italic>v</italic><sub>1</sub> and <italic>v</italic><sub>2</sub> are extant genes (or equivalently gene tree leaves, which corresponds to Case 1 in [<xref rid="c12" ref-type="bibr">12</xref>]), then D<sc>E</sc>C<sc>O</sc> would use the following scoring rules:</p>
<p><italic>c</italic><sub>0</sub>(<italic>v</italic><sub>1</sub>, <italic>v</italic><sub>2</sub>) = <italic>&#x221E;</italic> and <italic>c</italic><sub>1</sub>(<italic>v</italic><sub>1</sub>, <italic>v</italic><sub>2</sub>) = 0 if <italic>v</italic><sub>1</sub><italic>v</italic><sub>2</sub> is an adjacency in the data, otherwise <italic>c</italic><sub>0</sub>(<italic>v</italic><sub>1</sub>, <italic>v</italic><sub>2</sub>) = 0 and <italic>c</italic><sub>1</sub>(<italic>v</italic><sub>1</sub>, <italic>v</italic><sub>2</sub>) = <italic>&#x221E;</italic>.</p>
<p>Here we modify these rules (it is the only case different from the dynamic programming equations given in [<xref rid="c12" ref-type="bibr">12</xref>] and Additional file 1) and propose instead that
<disp-formula id="ueqn10"><alternatives><graphic xlink:href="023085_ueqn10.gif"/></alternatives></disp-formula></p>
<p>These formulas define a cost system which is consistent with the previous one: when <italic>n</italic> = <italic>p</italic> (perfectly assembled genomes) it gives the same result. When it is not the case, the costs are between 0 and <italic>&#x221E;</italic> as the probabilities go from 0 to 1.</p>
<p>We left the basis of the logarithm as a variable <italic>b</italic>. Giving a value to <italic>b</italic> determines a sensitivity for finding new adjacencies. It can be dependent on the genome <italic>S</italic> hosting <italic>v</italic><sub>1</sub> and <italic>v</italic><sub>2</sub>. We choose the basis so that <italic>c</italic><sub>1</sub>(<italic>v</italic><sub>1</sub>, <italic>v</italic><sub>2</sub>) <italic>&#x003C; c</italic><sub>0</sub>(<italic>v</italic><sub>1</sub>, <italic>v</italic><sub>2</sub>) &#x002B; <italic>Br</italic> where <italic>Br</italic> is the cost of an adjacency breakage. Thus an adjacency is systematically proposed when it is inferred in the closest ancestor of <italic>S</italic>. The adjacency is obviously not always true in that case, because a rearrangement can have broken it in <italic>S</italic>. But it is a necessary condition to be able to propose any adjacency. If a genome is highly fragmented, proposing such an adjacency is more likely to lead to a true scaffolding adjacency than to cancel an evolutionary rearrangement. The relation <italic>c</italic><sub>1</sub>(<italic>v</italic><sub>1</sub>, <italic>v</italic><sub>2</sub>) <italic>&#x003C; c</italic><sub>0</sub>(<italic>v</italic><sub>1</sub>, <italic>v</italic><sub>2</sub>) &#x002B; <italic>Br</italic> yields
<disp-formula id="ueqn11"><alternatives><graphic xlink:href="023085_ueqn11.gif"/></alternatives></disp-formula>
where <italic>p</italic>(<italic>S</italic>) represents the fragmentation of the genomes hosting <italic>v</italic><sub>1</sub> and <italic>v</italic><sub>2</sub>, defined in the previous section. Preliminary experiments show that there is indeed a phase change in the number of inferred adjacencies when <italic>b</italic> reaches the right hand side of the above equation (<xref ref-type="fig" rid="fig2">Figure 2</xref>). Above this value, the number of inferred adjacencies is mainly constant, while it changes radically for smaller values. In following experiments we then fixed <italic>b</italic> to 1.05 times the right hand side of the above equation, in order to be sure to be on the plateau following the phase change.</p>
<fig id="fig2" position="float" fig-type="figure">
<label>Figure 2</label>
<caption><title>Determination of a good value for base log b.</title><p>We simulated 550 fissions on a data set of 7 tetrapod species (see Section Results) and evaluate the ability of AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> to recover broken adjacencies by the simulated fissions for different values for the base log <italic>b</italic>. On the <italic>x</italic> axis is the multiplicative factor of <inline-formula><alternatives><inline-graphic xlink:href="023085_inline10.gif"/></alternatives></inline-formula>, where <italic>Br</italic> = 1. As we can see on the graph, there is a phase change at 1.0, meaning that from this value a good number of adjacencies can be proposed. Increasing the multiplicative factor does not qualitatively change the results. This experiment was repeated for different numbers of simulated fissions (see Additional file 2) and different species trees, and in all cases results exhibited the same profile.</p></caption>
<graphic xlink:href="023085_fig2.tif"/>
</fig>
</sec>
<sec id="s2e"><title>Exploration of the solution space</title>
<p>The dynamic programming scheme of D<sc>E</sc>C<sc>O</sc> allows the quantitative exploration of the whole solution space. This has been developed, in the D<sc>E</sc>C<sc>O</sc> model, in [<xref rid="c31" ref-type="bibr">31</xref>], where it was shown how to explore all solutions (<italic>i.e.</italic> evolutionary histories for adjacencies) under a Boltzmann probability distribution defined as follows: for a given instance (pair of gene trees and set of extant adjacencies) with solution space <italic>S</italic>, the parsimony score of an adjacency history <italic>h</italic> is denoted by <italic>s</italic>(<italic>h</italic>), and the Boltzmann probability of <italic>h</italic> is defined as <italic>e</italic><sup>&#x2212;<italic>s</italic>(<italic>h</italic>)/<italic>kT</italic></sup>/&#x2211;<sub><italic>g&#x2208;S</italic></sub> <italic>e</italic><sup>&#x2212;<italic>s</italic>(<italic>g</italic>)/<italic>kT</italic></sup>. Here <italic>kT</italic> is a constant that can be used to skew the probability distribution: when <italic>kT</italic> is small, parsimonious histories dominate the distribution, while a large <italic>kT</italic> leads to a more uniform distribution over the whole solution space.</p>
<p>This allows to associate to a feature of a solution (here an ancestral adjacency) a support defined as the ratio between the sum of the probabilities of the solutions that contain this feature and the sum of the probabilities of all solutions. This approach has been implemented in the DeClone software [<xref rid="c31" ref-type="bibr">31</xref>]. We integrated this possibility to AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> and thus associate a support to both extant and ancestral adjacencies. Computations were run with a value of the <italic>kT</italic> constant equal to 0.1 to ensure that the Boltzmann distribution is highly dominated by optimal and slightly sub-optimal solutions. This value was chosen after preliminary tests on a subset of instances that showed that scenarios sampled with this value of <italic>kT</italic> were in very large majority optimal scenarios.</p>
</sec>
</sec>
<sec id="s3"><title>Results</title>
<p>We tested AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> on three data sets. The first one is composed of 7 tetrapod species with only universal unicopy genes, and aims at comparing our method with the method of Aganezov <italic>et al.</italic> [<xref rid="c29" ref-type="bibr">29</xref>]; on this data set, we obtain comparable results. Then we ran AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> on the complete Ensembl Compara [<xref rid="c30" ref-type="bibr">30</xref>] database, including 69 eukaryotic species and 20,279 gene families with arbitrary numbers of duplications and losses. This shows that AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> scales up and can process large data sets of whole genomes; for this data set we examine carefully one scaffolding adjacency proposed by AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> in the poorly assembled panda genome and provide evidence it is likely a true scaffolding adjacency. The third data set we consider is the restriction to the 39 eutherian mammals genomes of the previous data set. The computational efficiency of AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> allows to reproduce the computation many times with simulated missing adjacencies, and replicates to obtain empirical error bars on the measures. We performed all experiments with fixed costs for adjacency gains (<italic>Gain</italic>) and breakages (<italic>Br</italic>), respectively set to 3 and 1. There are several reasons for this discrepancy: first the actual number of adjacencies is very low compared to the space of possible adjacencies, which makes more probable to break a particular one <inline-formula><alternatives><inline-graphic xlink:href="023085_inline11.gif"/></alternatives></inline-formula> than to gain a particular one <inline-formula><alternatives><inline-graphic xlink:href="023085_inline12.gif"/></alternatives></inline-formula> there is a huge unobserved space of possible solutions that should affect the costs; second it has been remarked that good statistical estimates of genomic distances when genomes are coded by the presence or absence of adjacencies are obtained with a state of possible adjacencies 3 times larger than the number of adjacencies (see paper &#x201C;Moments of genomes evolution by Double Cut-and-Join&#x201D;, BMC bioinformatics, to appear).</p>
<sec id="s3a"><title>Seven tetrapods - comparison with the method of Aganezov <italic>et al.</italic> [<xref rid="c29" ref-type="bibr">29</xref>]</title>
<p>By querying Biomart [<xref rid="c32" ref-type="bibr">32</xref>], we produced a data set similar to the one described in Aganezov <italic>et al.</italic> [<xref rid="c29" ref-type="bibr">29</xref>]: it consists in 8,818 universal unicopy gene families from Human, Chimp, Macaque, Mouse, Rat, Dog and Chicken. The latter was not present in the data set of Aganezov <italic>et al.</italic> [<xref rid="c29" ref-type="bibr">29</xref>], and we included it here because of a fundamental difference between the two methods: our method works with rooted phylogenies whereas Aganezov <italic>et al.</italic> [<xref rid="c29" ref-type="bibr">29</xref>] is not sensitive to the position of the root. This means that our method cannot scaffold an outgroup species, simply because, for any adjacency absent from the outgroup, it is more parsimonious to assume it is gained in all ingroup species. So we just added a distant outgroup to scaffold the 6 species used in [<xref rid="c29" ref-type="bibr">29</xref>].</p>
<p>We produced different sets of randomly fragmented genomes by considering <italic>n</italic> = 50 to <italic>n</italic> = 1050 random artificial breaks (or &#x201C;fissions&#x201D;) in genomes, sticking to the described experiments in [<xref rid="c29" ref-type="bibr">29</xref>]. This means we simply removed <italic>n</italic> random adjacencies per genome from the data set. For each <italic>n</italic>, we replicated the experiment 30 times.</p>
<p>For each replicate with <italic>n</italic> random artificial adjacency breaks, let <italic>T P</italic> be the number of removed adjacencies that AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> retrieves and <italic>F P</italic> be the number adjacencies not in the removed ones but proposed by AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc>.</p>
<p>We measured, following [<xref rid="c29" ref-type="bibr">29</xref>], approximations of the sensitivity and precision:
<disp-formula id="ueqn12"><alternatives><graphic xlink:href="023085_ueqn12.gif"/></alternatives></disp-formula></p>
<p>Aganezov <italic>et al.</italic> report that &#x201C;<italic>T rue positive</italic>&#x201D; takes values between 75&#x0025; and 87&#x0025;, and &#x201C;<italic>False positive</italic>&#x201D; takes values from 0.5&#x0025; to 9&#x0025;, varying in function of <italic>n</italic>. We report similar values for all our experiments (see <xref ref-type="table" rid="tbl1">Table 1</xref>).</p>
<table-wrap id="tbl1" orientation="portrait" position="float">
<label>Table 1</label>
<caption><p>Statistics on adjacencies recover by AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> on 7 tetrapods dataset with different number of simulated breaks.</p></caption>
<graphic xlink:href="023085_tbl1.tif"/>
</table-wrap>
<p>Thus, on small data sets and discarding gene families with complex histories, we obtain similar performance. The next experiments illustrate that the contribution of our method is then to be able to process much larger and much more complex data sets.</p>
</sec>
<sec id="s3b"><title>69 eukaryotes - a proof of scaling up</title>
<p>We ran AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> on the full Ensembl Compara database (1,222,543 protein coding extant genes in 69 extant species) in about 18h. The input contains 1,023,492 adjacencies in the extant genomes, showing that many genomes assemblies are highly fragmented, from 11 chromosomes for the perfectly assembled opossum genome to 12,704 contigs for the wallaby genome, an order of magnitude comparable to the number of genes. In <xref ref-type="fig" rid="fig3">Figure 3</xref>, the black bars show the proportion of genes with 0, 1 or 2 syntenic neighbors in the extant input genomes. Around 30&#x0025; of genes have at most one neighbor, while we would expect less than 1&#x0025; for perfectly assembled genomes.</p>
<fig id="fig3" position="float" fig-type="figure">
<label>Figure 3</label>
<caption><title>Number of syntenic neighbors of extant and ancestral genes.</title><p>Distribution of the proportion of genes with a given number of neighbors in extant and ancestral genomes before and after adjacency prediction for the data set on 69 eukaryotes.</p></caption>
<graphic xlink:href="023085_fig3.tif"/>
</fig>
<p>AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> predicts 36,445 new extant adjacencies. As shown in <xref ref-type="fig" rid="fig3">Figure 3</xref> (red bars) there is a significant increase in extant genes with 2 syntenic neighbors, as in a <italic>bona fide</italic> scaffolding, at the expense of a very small number of genes with more than two neighbors, corresponding to syntenic conflicts. Complementary computations show that more than 99.6&#x0025; contigs in extant species remain linear (two genes having degree 1 and others degree 2), in spite of the large number of contig connections inferred in some species (<italic>e.g.</italic>, the number of contigs goes from 2,599 down to 1,864 for <italic>Ailuropoda melanoleuca</italic> or from 11,528 down to 7,930 for <italic>Tarsius syrichta</italic>). <xref ref-type="fig" rid="fig4">Figure 4</xref> shows the percentage of improvement given by the method relatively to the initial data. Precisely, this percentage is obtained by computing <inline-formula><alternatives><inline-graphic xlink:href="023085_inline13.gif"/></alternatives></inline-formula> on extant species which are not completely assembled, where <italic>C</italic><sub><italic>I</italic></sub>, resp. <italic>C</italic><sub><italic>N</italic></sub> and <italic>p</italic> are the number of contigs in the initial genome, resp. the number of contigs after adjacency inference by AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> and the expected number of chromosomes. The figure shows that the more fragmented is the initial genome, the better AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> improves it.</p>
<fig id="fig4" position="float" fig-type="figure">
<label>Figure 4</label>
<caption><title>Percentage of improvement of genome assemblies, according to their initial fragmentation.</title><p>Statistics are obtained for the 69 eukaryotes dataset, excluding genomes that are already well assembled (bold figures between parenthesis indicate cardinalities of classes).</p></caption>
<graphic xlink:href="023085_fig4.tif"/>
</fig>
<p><xref ref-type="fig" rid="fig5">Figure 5</xref> shows the average degree of non-linearity of extant species with at least one non-linear contig, representing 43 of 69 species, computed only on non-linear contigs. Degree of non-linearity (<italic>D</italic><sub><italic>nl</italic></sub>) correspond to supplementary degree of genes that are not consistent with a linear conformation and computed as follow:
<disp-formula id="ueqn13"><alternatives><graphic xlink:href="023085_ueqn13.gif"/></alternatives></disp-formula>
<italic>n</italic> = <italic>Number of genes with degree &#x003E;</italic> 2
<italic>d</italic><sub><italic>x</italic></sub> = <italic>Number of degree of gene x
m</italic> = <italic>Number of genes with degree</italic> = 1</p>
<fig id="fig5" position="float" fig-type="figure">
<label>Figure 5</label>
<caption><title>Distribution of average degree of non-linearity on non-linear contigs by extant species.</title><p>On this graph, only species with at least one non-linear contig are shown, representing 43 of the 69 species. 23 of these species have an average degree of non-linearity of 2, meaning that their non-linear contigs contain an extra branch (one gene of degree 3 and one extra gene with degree 1).</p></caption>
<graphic xlink:href="023085_fig5.tif"/>
</fig>
<p>On 43 species with non-linear contigs, 23 have non-linear contigs with only one extra branch. For the 20 remaining species, contigs are more branchy and few are circular.</p>
<p>We also reconstruct 1,547,546 ancestral adjacencies on 3,245,572 ancestral genes. As previously noted [<xref rid="c33" ref-type="bibr">33</xref>], errors in gene trees artificially inflate the number of ancestral genes computed with gene tree/species tree reconciliations. Nevertheless, the pattern of ancestral gene neighborhood shows mainly ancestral genes with 0, 1 or 2 neighbors, and some conflicts rapidly decreasing (<xref ref-type="fig" rid="fig3">Figure 3</xref>, blue bars). More than 92&#x0025; inferred contigs in ancestral genomes are linear. <xref ref-type="fig" rid="fig6">Figure 6</xref> presents the density histogram of average degree of non-linearity for ancestral species on inferred contigs that are not linear. As we can see most of the species have an average of degree non-linearity less than 20 meaning that in average non-linear ancestral contigs have a degree of non-linearity less than 20.Moreover, more than 50&#x0025; of ancestral species have a degree of non-linearity less than 6 indicating that most of non-linear ancestral contigs are weakly branchy. However a large number of ancestral species have contigs strongly branchy and circular and need additional processes to obtain linear contigs. It is likely that better ancestral and extant genomes would result from better input gene trees.</p>
<fig id="fig6" position="float" fig-type="figure">
<label>Figure 6</label>
<caption><title>Density histogram of average degree of non-linearity for ancestral species on non-linear contigs.</title><p>Most of the ancestral species have an average degree of non-linearity of 20 meaning that in average contigs of ancestral species reconstructed by AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> have a degree of non-linearity less than 20. This figure shows that a large number are non-linear and additional operations are necessary to obtain linear contigs.</p></caption>
<graphic xlink:href="023085_fig6.tif"/>
</fig>
<p>We analyze in details one predicted extant adjacency, in order to understand why it is present in the output of AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> and not in the input. The adjacency we chose is randomly taken from the predicted ones between a contig and a chromosome in the panda genome (<italic>Ailuropoda melanoleuca</italic>). For this adjacency between genes RCSD1 and CREG1, we analyze gene neighborhoods around homologous adjacencies in others species. On <xref ref-type="fig" rid="fig7">Figure 7</xref>, we represent the species tree with information on evolutionary events that occurred along species tree (adjacency loss, duplication and gain, and gene loss and duplication) and adjacency status with color code on species name (red for species without RCSD1-CREG1 adjacency, blue for species with RCSD1-CREG1 adjacency in Ensembl database and green for species for which AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> infers an adjacency between RCSD1 and CREG1 while not present in Ensembl). To illustrate the validity of new adjacencies inferred by AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> we analyze the gene neighborhood around RCSD1-CREG1 adjacency. As, we can see on <xref ref-type="fig" rid="fig7">Figure 7</xref>, we observe that gene order and content is the same between cat (<italic>Felis catus</italic>), human (<italic>Homo sapiens</italic>) and panda except for ADCY10 gene (in black) that is not present in panda genome. The RCSD1-CREG1 adjacency is confirmed by adjacency support of <italic>&#x003E;</italic> 99.96&#x0025;, according to the exploration of the solution space. Due to the high fragmentation of panda genome and previous information it is reasonable to think that this adjacency is true. We observe the same results for the kangaroo rat (<italic>Dipodomys ordii</italic>) genome with gene content similarity with close species, high adjacency support (<italic>&#x003E;</italic> 99.99&#x0025;) and high genome fragmentation (9,720 contigs).</p>
<fig id="fig7" position="float" fig-type="figure">
<label>Figure 7</label>
<caption><title>Evolutionary history of the adjacency between RCSD1 (turquoise) and CREG1 (light green).</title><p>AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> infers the creation of this adjacency at the root of Amniots. We integrated the different evolutionary events concerning the RCSD1-CREG1 adjacency along the species tree. Empty red crosses represents an adjacency losses (<italic>i.e.</italic>, cases where both adjacent genes are lost at the same time); each full red cross represents a gene loss (only one of the genes is lost); each empty green square indicates an adjacency duplication (places where the two adjacent genes are duplicated together); a full green square indicates a gene duplication and an orange triangle represents an adjacency gain. Color code for species name gives information on adjacency status. In red species, RCSD1 and CREG1 genes are not adjacent, while blue species host the RCSD1-CREG1 adjacency as described by Ensembl, and green species have the RCSD1-CREG1 adjacency inferred by AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> (though it is absent from Ensembl). For green species, the adjacency support is indicated. For some species, representing most of the clades in Ensembl, we illustrate the gene content around the RCSD1-CREG1 adjacency, which illustrates strong similarities in the genomes of blue and green species.</p></caption>
<graphic xlink:href="023085_fig7.tif"/>
</fig>
<p>This analysis also allowed to see a possible lack of data in Ensembl. As can be seen on the mouse lemur (<italic>Microcebus murinus</italic>) genome, there is no adjacency between CREG1 and RCSD1 because no RCSD1 gene has been annotated in Ensembl for this species. However, the gene content and order around CREG1 is very similar to that of close genomes (<italic>e.g.</italic>, human). Moreover, Ensembl contains an incomplete DNA sequence for the equivalent position of CD247 and RCSD1 genes in mouse lemur. This implies that the genes CD247 and RCSD1 could be present in mouse lemur but are not annotated.</p>
</sec>
<sec id="s3c"><title>39 mammals - validity</title>
<p>We switched to a smaller dataset to measure the validity of the method, because the computing time don&#x2019;t allow too many replicates in the entire database. We selected all protein coding gene families from the 39 eutherian mammal genomes stored in the Ensembl database [<xref rid="c30" ref-type="bibr">30</xref>].</p>
<p>AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> proposes 1,056,418 ancestral adjacencies and 22,675 new adjacencies in extant genomes. A proportion of 95&#x0025; of these adjacencies have a <italic>&#x003E;</italic> 0.9 support,meaning that they are present in over 90&#x0025; of parsimonious solutions, computed as described in [<xref rid="c31" ref-type="bibr">31</xref>] for a <italic>kT</italic> value equal to 0.1 (chosen to ensure that the probability distribution over the solution space is highly dominated by optimal solutions).</p>
<p><xref ref-type="fig" rid="fig8">Figure 8A</xref> shows the shape of extant genomes through the number or cumulative support of adjacencies incident to one gene. The distribution for all genes is plotted for extant genomes in the input and in the output, taking support into account or not. The figure shows that the genomes scaffolded with AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> host more genes having exactly two neighbors (highest peak in the figure, the input is in black and output is in red). Peaks are integer numbers: unweighted measures have all their values integer while weighted measures still have peaks at integers. Complementary computations show that more than 99.7&#x0025; contigs in extant species are indeed linear.</p>
<fig id="fig8" position="float" fig-type="figure">
<label>Figure 8</label>
<caption><title>Weighted neighborhoods of extant (A) and ancestral genes (B).</title><p>Distribution of the proportion of extant and ancestral genes with a given neighborhood weight in extant genomes before and after adjacency prediction, with or without support, for the data set on 39 mammals. The neighborhood weight of a gene is the sum of the supports of all adjacencies involving this gene. Continuous values are binned by intervals.</p></caption>
<graphic xlink:href="023085_fig8.tif"/>
</fig>
<p><xref ref-type="fig" rid="fig8">Figure 8B</xref> is the analog of <xref ref-type="fig" rid="fig8">Figure 8A</xref> but for ancestral genomes: blue for the number of neighbors in the version of AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> without support (only one solution is given), and pink for the version of AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> with support. The several peaks of the graph illustrate that ancestral genomes are not in the shape of disjoint paths, as we would expect it from linear genomes. This was already remarked in [<xref rid="c12" ref-type="bibr">12</xref>], and is likely due to errors in gene trees in the Ensembl database [<xref rid="c34" ref-type="bibr">34</xref>, <xref rid="c35" ref-type="bibr">35</xref>]. Additional computations show that ancestral species indeed contain a larger proportion of nonlinear contigs: only 91.2&#x0025; contigs are linear for those species, among which contigs hosting only one gene are more represented than in extant genomes. Thus, a small part of the inferred adjacencies are incorrect, leading to some artificially tree-like or cyclic contigs.</p>
<p>The bars with supports are more dispersed, as expected, because they take their values from non integer numbers. It puts the conflicts into perspective: when a gene has more than two neighbors, usually one adjacency is less supported.</p>
<p>We also performed experiments with artificial adjacency breaks as in the 7 tetrapods experiment. We removed from 1 to 75&#x0025; input adjacencies from the human genome, and then from the horse genome. We chose the human and horse genome because of their phylogenetic position: one has many closely related genomes, while the other is rather distant from its closest neighbor inside the placentals. This allows us to measure the effect of the presence of closely related genomes in the given phylogeny. The two situations are very different because of the bias in taxonomic sampling around human. The presence of very close relatives in the data set makes the problem much easier for the human genome.</p>
<p>Indeed, as shown on <xref ref-type="fig" rid="fig9">Figure 9</xref>, the sensitivity (measured by the &#x201C;<italic>True positive</italic>&#x201D; rate as in the previous section, to keep a coherence and comparability with [<xref rid="c29" ref-type="bibr">29</xref>]) of the method is around 40&#x0025; for the human genome, and 5&#x0025; for the horse genome. The precision is high in all cases, decreasing with the number of broken adjacencies but the number of &#x201C;<italic>False positives</italic>&#x201D; stays quite low.</p>
<fig id="fig9" position="float" fig-type="figure">
<label>Figure 9</label>
<caption><title>Capacity of AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> to recover adjacencies after simulated breaks on human and horse genome</title></caption>
<graphic xlink:href="023085_fig9.tif"/>
</fig>
<p>The complexity of the data is a real issue here. While in a prepared, filtered data set of 7 tetrapods the sensitivity was above 80&#x0025; in all cases, here with all genes from 39 genomes including duplications and losses, it is much lower in all cases.</p>
<p>From all data sets, we observe that the precision of AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> is always high, while the sensitivity varies according to the conditions. So we can see the method as a rather sure predictor of a small number of scaffolding linkages, without the pretension to reconstruct fully assembled genomes.</p>
</sec>
</sec>
<sec id="s4"><title>Discussion and Conclusion</title>
<p>Ancestral gene order reconstruction, when ancestral genes are given, can be seen as a scaffolding problem. Indeed ancestral genes may be seen as contigs, and finding an order between contigs is a similar problem in both extant and ancestral genomes. If this similarity had already been remarked and exploited in some way [<xref rid="c24" ref-type="bibr">24</xref>, <xref rid="c26" ref-type="bibr">26</xref>, <xref rid="c36" ref-type="bibr">36</xref>], a fully integrated approach has only recently been achieved by Aganezov <italic>et al.</italic> [<xref rid="c29" ref-type="bibr">29</xref>], with a method which was limited to universal unicopy genes and a small number of genomes. Extending D<sc>E</sc>C<sc>O</sc> [<xref rid="c12" ref-type="bibr">12</xref>], a software aimed at reconstructing ancestral genomes and scaling up to dozens of genomes with possibly complex histories, we implement the additional possibility of scaffolding extant genomes in the same process, by handling equally ancestral and ancient genomes, with known and unknown parts in genome structures.</p>
<p>We demonstrate the efficiency of this approach on several eukaryote genomes data sets. It runs fast enough, proposes many additional supported adjacencies in extant genomes, and from several investigations we think we can state that such links are very likely to exist in reality. We are able to detect the less likely ones by assigning a support on ancestral and extant adjacencies by the same principle.</p>
<p>The main computational difference with the approach of Aganezov <italic>et al.</italic> [<xref rid="c29" ref-type="bibr">29</xref>] is that adjacencies are supposed to evolve independently. It has several notable consequences. The first one is the running time, because we switch from an NP-complete to a polynomial problem, and we are able to handle a large number of whole genomes. The second one is the shape of ancestral genomes. While methods modeling rearrangements [<xref rid="c29" ref-type="bibr">29</xref>] end up with <italic>bona fide</italic> genome structures, as linear arrangement of genes, our adjacency sets can be conflictual, both in ancestral and extant genomes. This means a gene can have more than two neighbors, unlike in real genomes. Whereas this can be seen as a serious drawback because genomes are not realistic, we would like to argue that it has several advantages, in addition to the running time. Indeed, the amount of conflicts can be a measure of uncertainty of the methods and data. It has been remarked many times that data sets, and in particular gene trees, are far from perfect. But better gene trees produce ancestral genomes with less conflicts [<xref rid="c33" ref-type="bibr">33</xref>]. Conflicts can point at problems that don&#x2019;t necessarily concern the method itself, but give an overview of the quality of the data. This overview is lost if we force the data to fit in a linear structure. But if a linear ancestral genome is really needed, linearization techniques exist [<xref rid="c37" ref-type="bibr">37</xref>], even if we would argue for linearization techniques that also put into question the input data.</p>
<p>Some limitations would be still to overcome. For example we don&#x2019;t handle the orientation of the genes. This would be desirable to have a finer account of ancestral and extant genomes, and to have a better fit between the <italic>a priori</italic> probability of an adjacency (computed in an oriented mode) and the reconstructed adjacencies. It would not be conceptually much complicated because adjacencies can be considered between gene extremities instead of between genes. But it would result in a loss of sensitivity because inversions of a single gene, which seem to be frequent, would fall into a rearrangement signal, increasing the probability to lose the traces of neighborhoods. We leave this open for a future work.</p>
<p>Another perspective is to be able to question extant adjacencies given in the input. In our framework they have probability 1, but a scaffolding is not necessarily only giving an order to the contigs. It can be inserting a contig inside another, or cutting a chimeric contig because a better arrangement can be proposed. Assembly errors are often numerous, not only because of a lack of information, but also because of false information [<xref rid="c38" ref-type="bibr">38</xref>]. It could be done by re-assigning an <italic>a priori</italic> probability to each extant adjacency, and not only to the ones outside the contigs. Finally, following the idea introduced in RACA [<xref rid="c26" ref-type="bibr">26</xref>], it could be interesting to pair the predictions of AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> with sequence information such as mate-pairs or even physical or optical maps in order to integrate both evolutionary signal and sequencing data.</p>
</sec>
</body>
<back>
<sec sec-type="COI-statement"><title>Competing interests</title>
<p>The authors declare that they have no competing interests.</p>
</sec>
<sec><title>Author&#x2019;s contributions</title>
<p>YA, AC, CC, VB, ET and SB conceived the method and the tests. YA and SB implemented AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> and YA tested it on all data sets. CC assigned the support scores on all retrieved adjacencies. YA, AC, CC, VB, ET and SB wrote the paper.</p>
</sec>
<ack><title>Acknowledgements</title>
<p>This work is funded by the Agence Nationale pour la Recherche, Ancestrome project ANR-10-BINF-01-01. AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> analyses benefited from the Montpellier Bioinformatics Biodiversity platform services. We thank Yann Ponty for technical help for patching DeClone to integrate the scaffolding and the exploration of the solution space.</p>
</ack>
<ref-list><title>References</title>
<ref id="c1"><label>1.</label><mixed-citation publication-type="journal"><string-name><surname>Raphael</surname>, <given-names>B.J.</given-names></string-name>, <string-name><surname>Volik</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>Collins</surname>, <given-names>C.</given-names></string-name>, <string-name><surname>Pevzner,</surname> <given-names>P.A.</given-names></string-name>: <article-title>Reconstructing tumor genome architectures</article-title>. <source>Bioinformatics</source> <volume>19</volume>(<issue>Suppl. 2</issue>) (<fpage>2003</fpage>)</mixed-citation></ref>
<ref id="c2"><label>2.</label><mixed-citation publication-type="journal"><string-name><surname>Fischer</surname>, <given-names>A.</given-names></string-name>, <string-name><surname>V&#x00E1;zquez-Garc&#x03AF;a</surname>, <given-names>I.</given-names></string-name>, <string-name><surname>Illingworth</surname>, <given-names>C.J.R.</given-names></string-name>, <string-name><surname>Mustonen</surname>, <given-names>V.</given-names></string-name>: <article-title>High-definition reconstruction of clonal composition in cancer</article-title>. <source>Cell Reports</source> <volume>7</volume>(<issue>5</issue>), <fpage>1740</fpage>&#x2013;<lpage>1752</lpage> (<year>2014</year>)</mixed-citation></ref>
<ref id="c3"><label>3.</label><mixed-citation publication-type="journal"><string-name><surname>McPherson</surname>, <given-names>A.</given-names></string-name>, <string-name><surname>Roth</surname>, <given-names>A.</given-names></string-name>, <string-name><surname>Ha</surname>, <given-names>G.</given-names></string-name>, <string-name><surname>Shah</surname>, <given-names>S.P.</given-names></string-name>, <string-name><surname>Chauve</surname>, <given-names>C.</given-names></string-name>, <string-name><surname>Sahinalp</surname>, <given-names>S.C.</given-names></string-name>: <article-title>Joint inference of genome structure and content in heterogeneous tumor samples. In: Research in Computational Molecular Biology</article-title>. <source>Lecture Notes in Computer Science</source>, vol. <volume>9029</volume>, pp. <fpage>256</fpage>&#x2013;<lpage>258</lpage> (<year>2015</year>)</mixed-citation></ref>
<ref id="c4"><label>4.</label><mixed-citation publication-type="journal"><string-name><surname>Hurst</surname>, <given-names>L.</given-names></string-name>, <string-name><surname>P&#x00E1;l</surname>, <given-names>C.</given-names></string-name>, <string-name><surname>Lercher</surname>, <given-names>M.</given-names></string-name>: <article-title>The evolutionary dynamics of eukaryotic gene order</article-title>. <source>Nat Rev Genet</source> <volume>5</volume>(<issue>4</issue>), <fpage>299</fpage>&#x2013;<lpage>310</lpage> (<year>2004</year>)</mixed-citation></ref>
<ref id="c5"><label>5.</label><mixed-citation publication-type="journal"><string-name><surname>Swenson</surname>, <given-names>K.</given-names></string-name>, <string-name><surname>Arndt</surname>, <given-names>W.</given-names></string-name>, <string-name><surname>Tang</surname>, <given-names>J.</given-names></string-name>, <string-name><surname>Moret</surname>, <given-names>B.</given-names></string-name>: <article-title>Phylogenetic reconstruction from complete gene orders of whole genomes</article-title>. In: <source>Proceedings of the 6th Asia Pacific Bioinformatics Conference</source>, pp. <fpage>241</fpage>&#x2013;<lpage>250</lpage> (<year>2008</year>)</mixed-citation></ref>
<ref id="c6"><label>6.</label><mixed-citation publication-type="journal"><string-name><surname>Sankoff</surname>, <given-names>D.</given-names></string-name>: <article-title>Mechanisms of genome evolution: models and inference</article-title>. <source>Bulletin of the International Statistical Institute</source> <volume>47</volume>, <fpage>461</fpage>&#x2013;<lpage>475</lpage> (<year>1989</year>)</mixed-citation></ref>
<ref id="c7"><label>7.</label><mixed-citation publication-type="journal"><string-name><surname>Ma</surname>, <given-names>J.</given-names></string-name>, <string-name><surname>Ratan</surname>, <given-names>A.</given-names></string-name>, <string-name><surname>Raney</surname>, <given-names>B.J.</given-names></string-name>, <string-name><surname>Suh</surname>, <given-names>B.B.</given-names></string-name>, <string-name><surname>Zhang</surname>, <given-names>L.</given-names></string-name>, <string-name><surname>Miller</surname>, <given-names>W.</given-names></string-name>, <string-name><surname>Haussler</surname>, <given-names>D.</given-names></string-name>: <article-title>DUPCAR: Reconstructing Contiguous Ancestral Regions with Duplications</article-title>. <source>Journal of Computational Biology</source> <volume>15</volume>(<issue>8</issue>), <fpage>1007</fpage>&#x2013;<lpage>1027</lpage> (<year>2008</year>)</mixed-citation></ref>
<ref id="c8"><label>8.</label><mixed-citation publication-type="journal"><string-name><surname>Chauve</surname>, <given-names>C.</given-names></string-name>, <string-name><surname>Tannier</surname>, <given-names>E.</given-names></string-name>: <article-title>A methodological framework for the reconstruction of contiguous regions of ancestral genomes and its application to mammalian genomes</article-title>. <source>PLoS Computational Biology</source> <volume>4</volume>(<issue>11</issue>), <fpage>1000234</fpage> (<year>2008</year>)</mixed-citation></ref>
<ref id="c9"><label>9.</label><mixed-citation publication-type="journal"><string-name><surname>Alekseyev</surname>, <given-names>M.A.</given-names></string-name>, <string-name><surname>Pevzner</surname>, <given-names>P.A.</given-names></string-name>: <article-title>Breakpoint graphs and ancestral genome reconstructions</article-title>. <source>Genome Research</source> <volume>19</volume>(<issue>5</issue>), <fpage>943</fpage>&#x2013;<lpage>957</lpage> (<year>2009</year>)</mixed-citation></ref>
<ref id="c10"><label>10.</label><mixed-citation publication-type="journal"><string-name><surname>Ma</surname>, <given-names>J.</given-names></string-name>: <article-title>A probabilistic framework for inferring ancestral genomic orders. In: IEEE International Conference on Bioinformatics and Biomedicine</article-title>, <source>BIBM</source>, pp. <fpage>179</fpage>&#x2013;<lpage>184</lpage> (<year>2010</year>)</mixed-citation></ref>
<ref id="c11"><label>11.</label><mixed-citation publication-type="journal"><string-name><surname>Zheng</surname>, <given-names>C.</given-names></string-name>, <string-name><surname>Sankoff</surname>, <given-names>D.</given-names></string-name>: <article-title>On the PATHGROUPS approach to rapid small phylogeny</article-title>. <source>BMC Bioinformatics</source> <volume>12</volume>(<issue>Suppl. 1</issue>), <fpage>4</fpage> (<year>2011</year>)</mixed-citation></ref>
<ref id="c12"><label>12.</label><mixed-citation publication-type="journal"><string-name><surname>B&#x00E9;rard</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>Gallien</surname>, <given-names>C.</given-names></string-name>, <string-name><surname>Boussau</surname>, <given-names>B.</given-names></string-name>, <string-name><surname>Sz&#x00F6;llosi</surname>, <given-names>G.J.</given-names></string-name>, <string-name><surname>Daubin</surname>, <given-names>V.</given-names></string-name>, <string-name><surname>Tannier</surname>, <given-names>E.</given-names></string-name>: <article-title>Evolution of gene neighborhoods within reconciled phylogenies</article-title>. <source>Bioinformatics</source> <volume>28</volume>(<issue>18</issue>), <fpage>382</fpage>&#x2013;<lpage>388</lpage> (<year>2012</year>)</mixed-citation></ref>
<ref id="c13"><label>13.</label><mixed-citation publication-type="journal"><string-name><surname>Hu</surname>, <given-names>F.</given-names></string-name>, <string-name><surname>Lin</surname>, <given-names>Y.</given-names></string-name>, <string-name><surname>Tang</surname>, <given-names>J.</given-names></string-name>: <article-title>MLGO: phylogeny reconstruction and ancestral inference from gene-order data</article-title>. <source>BMC Bioinformatics</source> <volume>15</volume>, <fpage>354</fpage>&#x2013;<lpage>359</lpage> (<year>2014</year>)</mixed-citation></ref>
<ref id="c14"><label>14.</label><mixed-citation publication-type="journal"><string-name><surname>Reddy</surname>, <given-names>T.B.K.</given-names></string-name>, <string-name><surname>Thomas</surname>, <given-names>A.D.</given-names></string-name>, <string-name><surname>Stamatis</surname>, <given-names>D.</given-names></string-name>, <string-name><surname>Bertsch</surname>, <given-names>J.</given-names></string-name>, <string-name><surname>Isbandi</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Jansson</surname>, <given-names>J.</given-names></string-name>, <string-name><surname>Mallajosyula</surname>, <given-names>J.</given-names></string-name>, <string-name><surname>Pagani</surname>, <given-names>I.</given-names></string-name>, <string-name><surname>Lobos</surname>, <given-names>E.A.</given-names></string-name>, <string-name><surname>Kyrpides</surname>, <given-names>N.C.</given-names></string-name>: <article-title>The Genomes OnLine Database (GOLD) v.5: a metadata management system based on a four level (meta)genome project classification</article-title>. <source>Nucleic Acids Research</source> <volume>43</volume>(<issue>D1</issue>), <fpage>1099</fpage>&#x2013;<lpage>1106</lpage> (<year>2014</year>). <ext-link ext-link-type="uri" xlink:href="https://gold.jgi-psf.org/distribution">https://gold.jgi-psf.org/distribution</ext-link></mixed-citation></ref>
<ref id="c15"><label>15.</label><mixed-citation publication-type="journal"><string-name><surname>Simpson</surname>, <given-names>J.T.</given-names></string-name>, <string-name><surname>Wong</surname>, <given-names>K.</given-names></string-name>, <string-name><surname>Jackman</surname>, <given-names>S.D.</given-names></string-name>, <string-name><surname>Schein</surname>, <given-names>J.E.</given-names></string-name>, <string-name><surname>Jones</surname>, <given-names>S.J.M.</given-names></string-name>, <string-name><surname>Birol</surname>, <given-names>I.</given-names></string-name>: <article-title>ABySS: A parallel assembler for short read sequence data</article-title>. <source>Genome Research</source> <volume>19</volume>(<issue>6</issue>), <fpage>1117</fpage>&#x2013;<lpage>1123</lpage> (<year>2009</year>)</mixed-citation></ref>
<ref id="c16"><label>16.</label><mixed-citation publication-type="journal"><string-name><surname>Koren</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>Treangen</surname>, <given-names>T.J.</given-names></string-name>, <string-name><surname>Pop</surname>, <given-names>M.</given-names></string-name>: <article-title>Bambus 2: Scaffolding metagenomes</article-title>. <source>Bioinformatics</source> <volume>27</volume>(<issue>21</issue>), <fpage>2964</fpage>&#x2013;<lpage>2971</lpage> (<year>2011</year>)</mixed-citation></ref>
<ref id="c17"><label>17.</label><mixed-citation publication-type="journal"><string-name><surname>Salmela</surname>, <given-names>L.</given-names></string-name>, <string-name><surname>M&#x00E4;kinen</surname>, <given-names>V.</given-names></string-name>, <string-name><surname>V&#x00E4;lim&#x00E4;ki</surname>, <given-names>N.</given-names></string-name>, <string-name><surname>Ylinen</surname>, <given-names>J.</given-names></string-name>, <string-name><surname>Ukkonen</surname>, <given-names>E.</given-names></string-name>: <article-title>Fast scaffolding with small independent mixed integer programs</article-title>. <source>Bioinformatics</source> <volume>27</volume>, <fpage>3259</fpage>&#x2013;<lpage>3265</lpage> (<year>2011</year>)</mixed-citation></ref>
<ref id="c18"><label>18.</label><mixed-citation publication-type="journal"><string-name><surname>Gao</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>Sung</surname>, <given-names>W.-K.</given-names></string-name>, <string-name><surname>Nagarajan</surname>, <given-names>N.</given-names></string-name>: <article-title>Opera: Reconstructing optimal genomic scaffolds with high-throughput paired-end sequences</article-title>. <source>Journal of Computational Biology</source> <volume>18</volume>(<issue>11</issue>), <fpage>1681</fpage>&#x2013;<lpage>1691</lpage> (<year>2011</year>)</mixed-citation></ref>
<ref id="c19"><label>19.</label><mixed-citation publication-type="journal"><string-name><surname>Boetzer</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Henkel</surname>, <given-names>C.V.</given-names></string-name>, <string-name><surname>Jansen</surname>, <given-names>H.J.</given-names></string-name>, <string-name><surname>Butler</surname>, <given-names>D.</given-names></string-name>, <string-name><surname>Pirovano</surname>, <given-names>W.</given-names></string-name>: <article-title>Scaffolding pre-assembled contigs using SSPACE</article-title>. <source>Bioinformatics</source> <volume>27</volume>(<issue>4</issue>), <fpage>578</fpage>&#x2013;<lpage>579</lpage> (<year>2011</year>)</mixed-citation></ref>
<ref id="c20"><label>20.</label><mixed-citation publication-type="journal"><string-name><surname>Gritsenko</surname>, <given-names>A.A.</given-names></string-name>, <string-name><surname>Nijkamp</surname>, <given-names>J.F.</given-names></string-name>, <string-name><surname>Reinders</surname>, <given-names>M.J.T.</given-names></string-name>, <string-name><surname>de Ridder</surname>, <given-names>D.</given-names></string-name>: <article-title>GRASS: A generic algorithm for scaffolding next-generation sequencing assemblies</article-title>. <source>Bioinformatics</source> <volume>28</volume>(<issue>11</issue>), <fpage>1429</fpage>&#x2013;<lpage>1437</lpage> (<year>2012</year>)</mixed-citation></ref>
<ref id="c21"><label>21.</label><mixed-citation publication-type="journal"><string-name><surname>Simpson</surname>, <given-names>J.T.</given-names></string-name>, <string-name><surname>Durbin</surname>, <given-names>R.</given-names></string-name>: <article-title>Efficient de novo assembly of large genomes using compressed data structures</article-title>. <source>Genome Research</source> <volume>22</volume>(<issue>3</issue>), <fpage>549</fpage>&#x2013;<lpage>556</lpage> (<year>2012</year>)</mixed-citation></ref>
<ref id="c22"><label>22.</label><mixed-citation publication-type="journal"><string-name><surname>Luo</surname>, <given-names>R.</given-names></string-name>, <string-name><surname>Liu</surname>, <given-names>B.</given-names></string-name>, <string-name><surname>Xie</surname>, <given-names>Y.</given-names></string-name>, <string-name><surname>Li</surname>, <given-names>Z.</given-names></string-name>, <string-name><surname>Huang</surname>, <given-names>W.</given-names></string-name>, <string-name><surname>Yuan</surname>, <given-names>J.</given-names></string-name>, <string-name><surname>He</surname>, <given-names>G.</given-names></string-name>, <string-name><surname>Chen</surname>, <given-names>Y.</given-names></string-name>, <string-name><surname>Pan</surname>, <given-names>Q.</given-names></string-name>, <string-name><surname>Liu</surname>, <given-names>Y.</given-names></string-name>, <string-name><surname>Tang</surname>, <given-names>J.</given-names></string-name>, <string-name><surname>Wu</surname>, <given-names>G.</given-names></string-name>, <string-name><surname>Zhang</surname>, <given-names>H.</given-names></string-name>, <string-name><surname>Shi</surname>, <given-names>Y.</given-names></string-name>, <string-name><surname>Liu</surname>, <given-names>Y.</given-names></string-name>, <string-name><surname>Yu</surname>, <given-names>C.</given-names></string-name>, <string-name><surname>Wang</surname>, <given-names>B.</given-names></string-name>, <string-name><surname>Lu</surname>, <given-names>Y.</given-names></string-name>, <string-name><surname>Han</surname>, <given-names>C.</given-names></string-name>, <string-name><surname>Cheung</surname>, <given-names>D.W.</given-names></string-name>, <string-name><surname>Yiu</surname>, <given-names>S.-M.</given-names></string-name>, <string-name><surname>Peng</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>Xiaoqian</surname>, <given-names>Z.</given-names></string-name>, <string-name><surname>Liu</surname>, <given-names>G.</given-names></string-name>, <string-name><surname>Liao</surname>, <given-names>X.</given-names></string-name>, <string-name><surname>Li</surname>, <given-names>Y.</given-names></string-name>, <string-name><surname>Yang</surname>, <given-names>H.</given-names></string-name>, <string-name><surname>Wang</surname>, <given-names>J.</given-names></string-name>, <string-name><surname>Lam</surname>, <given-names>T.-W.</given-names></string-name>, <string-name><surname>Wang</surname>, <given-names>J.</given-names></string-name>: <article-title>SOAPdenovo2: an empirically improved memory-efficient short-read de novo assembler</article-title>. <source>GigaScience</source> <volume>1</volume>(<issue>1</issue>), <fpage>18</fpage> (<year>2012</year>)</mixed-citation></ref>
<ref id="c23"><label>23.</label><mixed-citation publication-type="journal"><string-name><surname>Hunt</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Newbold</surname>, <given-names>C.</given-names></string-name>, <string-name><surname>Berriman</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Otto</surname>, <given-names>T.D.</given-names></string-name>: <article-title>A comprehensive evaluation of assembly scaffolding tools</article-title>. <source>Genome Biology</source> <volume>15</volume>(<issue>3</issue>), <fpage>42</fpage> (<year>2014</year>)</mixed-citation></ref>
<ref id="c24"><label>24.</label><mixed-citation publication-type="journal"><string-name><surname>Husemann</surname>, <given-names>P.</given-names></string-name>, <string-name><surname>Stoye</surname>, <given-names>J.</given-names></string-name>: <article-title>Phylogenetic comparative assembly</article-title>. <source>Algorithms for Molecular Biology</source> <volume>5</volume>(<issue>1</issue>), <fpage>3</fpage>&#x2013;<lpage>14</lpage> (<year>2010</year>)</mixed-citation></ref>
<ref id="c25"><label>25.</label><mixed-citation publication-type="journal"><string-name><surname>Rajaraman</surname>, <given-names>A.</given-names></string-name>, <string-name><surname>Tannier</surname>, <given-names>E.</given-names></string-name>, <string-name><surname>Chauve</surname>, <given-names>C.</given-names></string-name>: <article-title>FPSAC: Fast Phylogenetic Scaffolding of Ancient Contigs</article-title>. <source>Bioinformatics</source> <volume>29</volume>(<issue>23</issue>), <fpage>2987</fpage>&#x2013;<lpage>2994</lpage> (<year>2013</year>)</mixed-citation></ref>
<ref id="c26"><label>26.</label><mixed-citation publication-type="journal"><string-name><surname>Kim</surname>, <given-names>J.</given-names></string-name>, <string-name><surname>Larkin</surname>, <given-names>D.M.</given-names></string-name>, <string-name><surname>Cai</surname>, <given-names>Q.</given-names></string-name>, <string-name><surname>Asan, Zhang,</surname> <given-names>Y.</given-names></string-name>, <string-name><surname>Ge</surname>, <given-names>R.-L.</given-names></string-name>, <string-name><surname>Auvil</surname>, <given-names>L.</given-names></string-name>, <string-name><surname>Capitanu</surname>, <given-names>B.</given-names></string-name>, <string-name><surname>Zhang</surname>, <given-names>G.</given-names></string-name>, <string-name><surname>Lewin</surname>, <given-names>H.A.</given-names></string-name>, <string-name><surname>Ma</surname>, <given-names>J.</given-names></string-name>: <article-title>Reference-assisted chromosome assembly</article-title>. <source>Proceedings of the National Academy of Sciences (PNAS)</source> <volume>110</volume>(<issue>5</issue>), <fpage>1785</fpage>&#x2013;<lpage>1790</lpage> (<year>2013</year>)</mixed-citation></ref>
<ref id="c27"><label>27.</label><mixed-citation publication-type="journal"><string-name><surname>Kolmogorov</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Raney</surname>, <given-names>B.</given-names></string-name>, <string-name><surname>Paten</surname>, <given-names>B.</given-names></string-name>, <string-name><surname>Pham</surname>, <given-names>S.</given-names></string-name>: <article-title>Ragout - A reference-assisted assembly tool for bacterial genomes</article-title>. <source>Bioinformatics</source> <volume>30</volume>(<issue>12</issue>), <fpage>302</fpage>&#x2013;<lpage>309</lpage> (<year>2014</year>)</mixed-citation></ref>
<ref id="c28"><label>28.</label><mixed-citation publication-type="journal"><string-name><surname>Lin</surname>, <given-names>Y.</given-names></string-name>, <string-name><surname>Nurk</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>Pevzner</surname>, <given-names>P.A.</given-names></string-name>: <article-title>What is the difference between the breakpoint graph and the de Bruijn graph?</article-title> <source>BMC Genomics</source> <volume>15</volume>(<issue>Suppl. 6</issue>), <fpage>6</fpage> (<year>2014</year>)</mixed-citation></ref>
<ref id="c29"><label>29.</label><mixed-citation publication-type="journal"><string-name><surname>Aganezov</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>Sitdykovaa</surname>, <given-names>N.</given-names></string-name>, <string-name><surname>Alekseyev</surname>, <given-names>M.A.</given-names></string-name>, <article-title>AGCConsortium: Scaffold assembly based on genome rearrangement analysis</article-title>. <source>Computational Biology and Chemistry</source> <volume>57</volume>, <fpage>46</fpage>&#x2013;<lpage>53</lpage> (<year>2015</year>)</mixed-citation></ref>
<ref id="c30"><label>30.</label><mixed-citation publication-type="journal"><string-name><surname>Cunningham</surname>, <given-names>F.</given-names></string-name>, <string-name><surname>Amode</surname>, <given-names>M.R.</given-names></string-name>, <string-name><surname>Barrell</surname>, <given-names>D.</given-names></string-name>, <string-name><surname>Beal</surname>, <given-names>K.</given-names></string-name>, <string-name><surname>Billis</surname>, <given-names>K.</given-names></string-name>, <string-name><surname>Brent</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>Carvalho-Silva</surname>, <given-names>D.</given-names></string-name>, <string-name><surname>Clapham</surname>, <given-names>P.</given-names></string-name>, <string-name><surname>Coates</surname>, <given-names>G.</given-names></string-name>, <string-name><surname>Fitzgerald</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>Gil</surname>, <given-names>L.</given-names></string-name>, <string-name><surname>Gir&#x00F3;n</surname>, <given-names>C.G.</given-names></string-name>, <string-name><surname>Gordon</surname>, <given-names>L.</given-names></string-name>, <string-name><surname>Hourlier</surname>, <given-names>T.</given-names></string-name>, <string-name><surname>Hunt</surname>, <given-names>S.E.</given-names></string-name>, <string-name><surname>Janacek</surname>, <given-names>S.H.</given-names></string-name>, <string-name><surname>Johnson</surname>, <given-names>N.</given-names></string-name>, <string-name><surname>Juettemann</surname>, <given-names>T.</given-names></string-name>, <string-name><surname>K&#x00E4;h&#x00E4;ri</surname>, <given-names>A.K.</given-names></string-name>, <string-name><surname>Keenan</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>Martin</surname>, <given-names>F.J.</given-names></string-name>, <string-name><surname>Maurel</surname>, <given-names>T.</given-names></string-name>, <string-name><surname>McLaren</surname>, <given-names>W.</given-names></string-name>, <string-name><surname>Murphy</surname>, <given-names>D.N.</given-names></string-name>, <string-name><surname>Nag</surname>, <given-names>R.</given-names></string-name>, <string-name><surname>Overduin</surname>, <given-names>B.</given-names></string-name>, <string-name><surname>Parker</surname>, <given-names>A.</given-names></string-name>, <string-name><surname>Patricio</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Perry</surname>, <given-names>E.</given-names></string-name>, <string-name><surname>Pignatelli</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Riat</surname>, <given-names>H.S.</given-names></string-name>, <string-name><surname>Sheppard</surname>, <given-names>D.</given-names></string-name>, <string-name><surname>Taylor</surname>, <given-names>K.</given-names></string-name>, <string-name><surname>Thormann</surname>, <given-names>A.</given-names></string-name>, <string-name><surname>Vullo</surname>, <given-names>A.</given-names></string-name>, <string-name><surname>Wilder</surname>, <given-names>S.P.</given-names></string-name>, <string-name><surname>Zadissa</surname>, <given-names>A.</given-names></string-name>, <string-name><surname>Aken</surname>, <given-names>B.L.</given-names></string-name>, <string-name><surname>Birney</surname>, <given-names>E.</given-names></string-name>, <string-name><surname>Harrow</surname>, <given-names>J.</given-names></string-name>, <string-name><surname>Kinsella</surname>, <given-names>R.</given-names></string-name>, <string-name><surname>Muffato</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Ruffier</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Searle</surname>, <given-names>S.M.J.</given-names></string-name>, <string-name><surname>Spudich</surname>, <given-names>G.</given-names></string-name>, <string-name><surname>Trevanion</surname>, <given-names>S.J.</given-names></string-name>, <string-name><surname>Yates</surname>, <given-names>A.</given-names></string-name>, <string-name><surname>Zerbino</surname>, <given-names>D.R.</given-names></string-name>, <string-name><surname>Flicek</surname>, <given-names>P.</given-names></string-name>: <article-title>Ensembl 2015</article-title>. <source>Nucleic Acids Research</source> <volume>43</volume>, <fpage>662</fpage>&#x2013;<lpage>669</lpage> (<year>2015</year>)</mixed-citation></ref>
<ref id="c31"><label>31.</label><mixed-citation publication-type="book"><string-name><surname>Zanetti</surname>, <given-names>J.P.P.</given-names></string-name>, <string-name><surname>Ponty</surname>, <given-names>Y.</given-names></string-name>, <string-name><surname>Chauve</surname>, <given-names>C.</given-names></string-name>: <chapter-title>Evolution of genes neighborhood within reconciled phylogenies: an ensemble approach</chapter-title>. <source>BMC Bioinformatics</source> (<year>2015</year>). <publisher-name>Brazilian Symposium on Bioinformatics 2014 special issue, to appear</publisher-name></mixed-citation></ref>
<ref id="c32"><label>32.</label><mixed-citation publication-type="other"><string-name><surname>Kasprzyk</surname>, <given-names>A.</given-names></string-name>: <article-title>BioMart: Driving a paradigm change in biological data management</article-title>. <source>Database</source> 2011, 049 (<year>2011</year>)</mixed-citation></ref>
<ref id="c33"><label>33.</label><mixed-citation publication-type="journal"><string-name><surname>Boussau</surname>, <given-names>B.</given-names></string-name>, <string-name><surname>Szollosi</surname>, <given-names>G.J.</given-names></string-name>, <string-name><surname>Duret</surname>, <given-names>L.</given-names></string-name>, <string-name><surname>Gouy</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Tannier.,</surname> <given-names>E.</given-names></string-name>, <string-name><surname>Daubin</surname>, <given-names>V.</given-names></string-name>: <article-title>Genome-scale coestimation of species and gene trees</article-title>. <source>Genome Research</source> <volume>23</volume>, <fpage>323</fpage>&#x2013;<lpage>330</lpage> (<year>2013</year>)</mixed-citation></ref>
<ref id="c34"><label>34.</label><mixed-citation publication-type="journal"><string-name><surname>Nouhati</surname>, <given-names>E.</given-names></string-name>, <string-name><surname>Semeria</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Lafond</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Seguin</surname>, <given-names>J.</given-names></string-name>, <string-name><surname>Boussau</surname>, <given-names>B.</given-names></string-name>, <string-name><surname>Gu&#x00E9;guen</surname>, <given-names>L.</given-names></string-name>, <string-name><surname>El-Mabrouk</surname>, <given-names>N.</given-names></string-name>, <string-name><surname>Tannier</surname>, <given-names>E.</given-names></string-name>: <source>Genome evolution aware gene trees</source>. <ext-link ext-link-type="uri" xlink:href="https://hal.archives-ouvertes.fr/hal-01162963">https://hal.archives-ouvertes.fr/hal-01162963</ext-link> (<year>2015</year>)</mixed-citation></ref>
<ref id="c35"><label>35.</label><mixed-citation publication-type="journal"><string-name><surname>Rajaraman</surname>, <given-names>A.</given-names></string-name>, <string-name><surname>Chauve</surname>, <given-names>C.</given-names></string-name>, <string-name><surname>Ponty</surname>, <given-names>Y.</given-names></string-name>: <article-title>Assessing the robustness of parsimonious predictions for gene neighborhoods from reconciled phylogenies</article-title>. <source>Lecture Notes in Computer Science</source>, vol. <volume>9096</volume>, pp. <fpage>260</fpage>&#x2013;<lpage>271</lpage> (<year>2015</year>)</mixed-citation></ref>
<ref id="c36"><label>36.</label><mixed-citation publication-type="journal"><string-name><surname>Luhmann</surname>, <given-names>N.</given-names></string-name>, <string-name><surname>Chauve</surname>, <given-names>C.</given-names></string-name>, <string-name><surname>Stoye</surname>, <given-names>J.</given-names></string-name>, <string-name><surname>Wittler</surname>, <given-names>R.</given-names></string-name>: <article-title>Scaffolding of ancient contigs and ancestral reconstruction in a phylogenetic framework. In: Proceedings of Brazilian Symposium on Bioinformatics</article-title>. <source>Lecture Notes in Computer Science</source>, vol. <volume>8826</volume>, pp. <fpage>135</fpage>&#x2013;<lpage>143</lpage> (<year>2014</year>)</mixed-citation></ref>
<ref id="c37"><label>37.</label><mixed-citation publication-type="journal"><string-name><surname>Man&#x0148;uch</surname>, <given-names>J.</given-names></string-name>, <string-name><surname>Patterson</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Wittler</surname>, <given-names>R.</given-names></string-name>, <string-name><surname>Chauve</surname>, <given-names>C.</given-names></string-name>, <string-name><surname>Tannier</surname>, <given-names>E.</given-names></string-name>: <article-title>Linearization of ancestral multichromosomal genomes</article-title>. <source>BMC Bioinformatics</source> <volume>13</volume>(<issue>Suppl. 19</issue>), <fpage>11</fpage> (<year>2012</year>)</mixed-citation></ref>
<ref id="c38"><label>38.</label><mixed-citation publication-type="journal"><string-name><surname>Denton</surname>, <given-names>J.F.</given-names></string-name>, <string-name><surname>Lugo-Martinez</surname>, <given-names>J.</given-names></string-name>, <string-name><surname>Tucker</surname>, <given-names>A.E.</given-names></string-name>, <string-name><surname>Schrider</surname>, <given-names>D.R.</given-names></string-name>, <string-name><surname>Warren</surname>, <given-names>W.C.</given-names></string-name>, <string-name><surname>Hahn</surname>, <given-names>M.W.</given-names></string-name>: <article-title>Extensive error in the number of genes inferred from draft genome assemblies</article-title>. <source>PLoS Computational Biology</source> <volume>10</volume>(<issue>2</issue>), <fpage>1003998</fpage> (<year>2014</year>)</mixed-citation></ref>
</ref-list>
<sec sec-type="supplementary-material"><title>Additional Files</title>
<fig id="fig10" position="float" fig-type="figure">
<label>Figure 10 -</label>
<caption><title>Additional file 1 AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> dynamic programming scheme.</title><p>Recurrence formulas used in AR<sc>T</sc>-D<sc>E</sc>C<sc>O</sc> to reconstruct adjacencies in ancestral and extant genomes.</p></caption>
<graphic xlink:href="023085_fig10.tif"/>
</fig>
<fig id="fig11" position="float" fig-type="figure">
<label>Figure 11 -</label>
<caption><title>Additional file 2 Effect of number of adjacencies breaks on adjacencies recover in function of base log value.</title><p>On the left, graph represents the number of adjacencies recovery in function of multiplicative factor for the log base for 50 simulated breaks in each species of 7 tetrapods dataset. On the right, the same graph but with 1050 simulated breaks for each species. As we can see the histogram profile is quietly similar between these two experiments and the one with 550 simulated breaks (see <xref ref-type="fig" rid="fig2">Figure 2</xref>). In conclusion, Number of adjacencies breaks didn&#x2019;t impact the optimal value for the log base. (Values are available in <xref ref-type="table" rid="tbl1">Table 1</xref>).</p></caption>
<graphic xlink:href="023085_fig11.tif"/>
</fig>
</sec>
</back>
</article>