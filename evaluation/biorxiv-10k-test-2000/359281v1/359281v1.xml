<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.2d1 20170631//EN" "JATS-archivearticle1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" article-type="article" dtd-version="1.2d1" specific-use="production" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">BIORXIV</journal-id>
<journal-title-group>
<journal-title>bioRxiv</journal-title>
<abbrev-journal-title abbrev-type="publisher">bioRxiv</abbrev-journal-title>
</journal-title-group>
<publisher>
<publisher-name>Cold Spring Harbor Laboratory</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1101/359281</article-id>
<article-version>1.1</article-version>
<article-categories>
<subj-group subj-group-type="author-type">
<subject>Regular Article</subject>
</subj-group>
<subj-group subj-group-type="heading">
<subject>New Results</subject>
</subj-group>
<subj-group subj-group-type="hwp-journal-coll">
<subject>Systems Biology</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>Efficient Synthesis of Mutants Using Genetic Crosses</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<name><surname>Pratapa</surname><given-names>Aditya</given-names></name>
<xref ref-type="aff" rid="a1">1</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Jalihal</surname><given-names>Amogh P.</given-names></name>
<xref ref-type="aff" rid="a2">2</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Ravi</surname><given-names>S. S.</given-names></name>
<xref ref-type="aff" rid="a3">3</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Murali</surname><given-names>T. M.</given-names></name>
<xref ref-type="aff" rid="a4">4</xref>
</contrib>
<aff id="a1"><label>1</label><institution>Dept. of Computer Science</institution>, Virginia Tech, Blacksburg, VA</aff>
<aff id="a2"><label>2</label><institution>Genetics, Bioinformatics, and Computational Biology</institution>, Virginia Tech, Blacksburg, VA</aff>
<aff id="a3"><label>3</label><institution>Biocomplexity Institute</institution>, Virginia Tech, Blacksburg, VA</aff>
<aff id="a4"><label>4</label><institution>Dept. of Computer Science</institution>, Virginia Tech, Blacksburg, VA</aff>
</contrib-group>
<pub-date pub-type="epub"><year>2018</year></pub-date>
<elocation-id>359281</elocation-id>
<history>
<date date-type="received"><day>29</day><month>6</month><year>2018</year></date>
<date date-type="rev-recd"><day>29</day><month>6</month><year>2018</year></date>
<date date-type="accepted"><day>29</day><month>6</month><year>2018</year></date>
</history>
<permissions>
<copyright-statement>&#x00A9; 2018, Posted by Cold Spring Harbor Laboratory</copyright-statement>
<copyright-year>2018</copyright-year>
<license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by/4.0/"><license-p>This pre-print is available under a Creative Commons License (Attribution 4.0 International), CC BY 4.0, as described at <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link></license-p></license>
</permissions>
<self-uri xlink:href="359281.pdf" content-type="pdf" xlink:role="full-text"/>
<abstract><title>Abstract</title>
<p>The genetic cross is a fundamental, flexible, and widely-used experimental technique to create new mutant strains from existing ones. Surprisingly, the problem of how to efficiently compute a sequence of crosses that can make a desired target mutant from a set of source mutants has received scarce attention. In this paper, we make three contributions to this question.</p>
<p>First, we formulate several natural problems related to efficient synthesis of a target mutant from source mutants. Our formulations capture experimentally-useful notions of verifiability (e.g the need to confirm that a mutant contains mutations in the desired genes) and permissibility (e.g., the requirement that no intermediate mutants in the synthesis be inviable).</p>
<p>Second, we develop combinatorial techniques to solve these problems. We prove that checking the existence of a verifiable, permissible synthesis is <bold>NP</bold>-complete in general. We complement this result with three polynomial time or fixed-parameter tractable algorithms for optimal synthesis of a target mutant for special cases of the problem that arise in practice.</p>
<p>Third, we apply these algorithms to simulated data and to synthetic data. We use results from simulations of a mathematical model of the cell cycle to replicate realistic experimental scenarios where a biologist may be interested in creating several mutants in order to verify model predictions. Our results show that the consideration of permissible mutants can affect the existence of a synthesis or the number of crosses in an optimal one. Our algorithms gracefully handle the restrictions that permissible mutants impose. Results on synthetic data show that our algorithms scale well with increases in the size of the input and the fixed parameters.</p>
</abstract>
<counts>
<page-count count="23"/>
</counts>
</article-meta>
</front>
<body>
<sec id="s1"><label>1</label><title>Introduction</title>
<p>Engineering mutations in multiple genes is a powerful way to dissect cellular mechanisms, discover pathway structure, and understand the genetic basis of complex diseases. The genetic cross is a classical technique to create strains with mutations (e.g., knock-outs or overexpression) in multiple genes, especially in model organisms such as baker&#x2019;s yeast, the fruitfly, mice, and <italic>Arabidopsis thaliana</italic>. Traditionally, biologists have created new strains by crossing existing mutants that they already have in the lab or can purchase easily. Strains carrying mutations in four, six, and even as many as 11 genes have been made in this manner [<xref ref-type="bibr" rid="c1">1</xref>, <xref ref-type="bibr" rid="c20">20</xref>, <xref ref-type="bibr" rid="c26">26</xref>]. More recently, developments in genome editing tools such as CRISPR-Cas9 have made it feasible to create mutations at multiple sites in a single experiment. This field is advancing very rapidly, with CRISPR-Cas9-like systems becoming available in several model organisms and with the development of new methods for multiplex gene editing [<xref ref-type="bibr" rid="c31">31</xref>].</p>
<p>Despite these advances, the genetic cross continues to remain a fundamentally useful experimental tool, including in combination with genome editing [<xref ref-type="bibr" rid="c24">24</xref>]. Since CRISPR-Cas9 edits require considerable efforts for verification, crosses are preferable if the mutants are already readily available. Moreover, in model organisms that have short generation times, performing a cross is often quicker than trying to edit two wild-type genes using CRISPR-based techniques. Therefore, in conjunction with high-throughput experimental techniques [<xref ref-type="bibr" rid="c6">6</xref>], genetic crosses open up the possibility of routine construction and characterization of mutants carrying alterations in several genes.</p>
<p>These observations inspire our research. We envision a scenario where a biologist has access in the lab to several source mutants, each carrying mutations in one or more genes; these mutants may have been created using a variety of techniques including crosses and genome editing. The biologist seeks to synthesize a target mutant using the genetic cross as the primary experimental tool.</p>
<sec id="s1a"><title>Our contributions</title>
<p>Our primary contributions are the definition of problems related to efficient synthesis of a target mutant from a set of source mutants using genetic crosses (<xref rid="s3" ref-type="sec">Section 3</xref>) and combinatorial algorithms to solve these problems (<xref rid="s4" ref-type="sec">Section 4</xref>). We first prove that when each source mutant contains mutations in at most three genes the problem of determining if there exists a synthesis of a target mutant is <bold>NP</bold> -complete. Next, we present a polynomial time algorithm to minimize the size of the synthesis (the number of crosses) of a target mutant when each source mutant contains mutations in at most two genes (<xref rid="s4c" ref-type="sec">Section 4.2</xref>). Furthermore, we provide a fixed-parameter tractable (FPT) algorithm for this problem with respect to the number of source mutants with three or more gene mutations (<xref rid="s4f" ref-type="sec">Section 4.4</xref>). Our final result deals with checking the existence of a permissible synthesis of a target mutant, i.e., ensuring that every intermediate mutant in the synthesis belongs to a permissible set of mutants. This problem is also <bold>NP</bold> -complete, in general. We provide a FPT algorithm with respect to the number of mutated genes in the target mutant (<xref rid="s4g" ref-type="sec">Section 4.5</xref>). This algorithm also minimizes the number of crosses.</p>
<p>These problems match an experimentalist&#x2019;s growing repertoire of mutants. Initially, when there are only single gene mutants, the synthesis problem is trivial. Our first algorithm is useful when the experimentalist has made some double gene mutants. As triple mutants become available, the second algorithm is applicable, since it is FPT in the number of such mutants. When the set of available mutants increases further, the issue of permissibility becomes important, which our final algorithm addresses.</p>
<p>Two challenges confront us when we evaluate our algorithms: there is a dearth of prior literature on this problem (see <xref rid="s2" ref-type="sec">Section 2</xref>) and there are no databases describing multi-gene (three or more) mutant strains that have been made in the lab. We use two complementary strategies to circumvent these gaps. First, we create a rich dataset of rescued and synthetic lethal target mutants by simulating a mathematical model of the cell cycle [<xref ref-type="bibr" rid="c15">15</xref>] for mutations in up-to-six genes (<xref rid="s5a" ref-type="sec">Section 5.1</xref>). We use mutants predicted to be viable by this model as permissible mutants. We apply our algorithms to compute syntheses for four-, five-, and six-gene target mutants. Permissibility has a material impact on a small fraction of mutants by either precluding the existence of a synthesis or by increasing the number of crosses needed in optimal syntheses. Second, we create synthetic datasets to assess the running times of our algorithms as functions of the fixed parameters (<xref rid="s5b" ref-type="sec">Section 5.2</xref>). Our results on these datasets show that the running time does grow with an increase in the value of the relevant fixed parameter.</p>
</sec>
</sec>
<sec id="s2"><label>2</label><title>Related Research</title>
<p>Mathematical models of cellular processes permit <italic>in silico</italic> simulations of multiple gene mutations [<xref ref-type="bibr" rid="c8">8</xref>,<xref ref-type="bibr" rid="c27">27</xref>,<xref ref-type="bibr" rid="c21">21</xref>, <xref ref-type="bibr" rid="c28">28</xref>, <xref ref-type="bibr" rid="c15">15</xref>]. Research on designing experiments based on model predictions has focused mainly on prioritizing the next-best or a small number of experiments, e.g., to distinguish between Boolean network models that fit the available data equally [<xref ref-type="bibr" rid="c12">12</xref>, <xref ref-type="bibr" rid="c30">30</xref>, <xref ref-type="bibr" rid="c5">5</xref>, <xref ref-type="bibr" rid="c29">29</xref>, <xref ref-type="bibr" rid="c3">3</xref>], to estimate the kinetic parameters of an ODE-based model [<xref ref-type="bibr" rid="c4">4</xref>, <xref ref-type="bibr" rid="c17">17</xref>, <xref ref-type="bibr" rid="c22">22</xref>], or to resolve model ambiguity [<xref ref-type="bibr" rid="c2">2</xref>, <xref ref-type="bibr" rid="c11">11</xref>, <xref ref-type="bibr" rid="c16">16</xref>, <xref ref-type="bibr" rid="c18">18</xref>]. However, simulations of mathematical models or searching for informative experiments do not solve the problem of how to efficiently synthesize a strain carrying multiple mutations from existing strains.</p>
<p>This paper complements the only closely related research of which we are aware, which involves two of the current paper&#x2019;s authors [<xref ref-type="bibr" rid="c25">25</xref>]. There, we defined the CrossPlan problem of optimizing the number of crosses needed in a verifiable, permissible synthesis of multiple target mutants. We improve upon the CrossPlan paper in three ways: (a) That paper used a model of a genetic cross that could produce all possible genotypes allowed by Mendelian inheritance. This type of genetic cross is experimentally challenging to implement since it requires verification of a number of genotypes that is exponential in the total number of mutations in the input mutants. Now, we propose a model of a genetic cross with a single output that harbors all the mutations in the two input mutant strains. This type of cross is experimentally more tractable and is usable in high-throughput workflows. (b) Earlier, we required that the input also contain a &#x201C;genetic cross graph&#x201D; that represents all possible ways of crossing source and permissible mutants. The worst case size of this graph can be quadratic in the number of source and permissible mutants. In contrast, in the current paper, we formulate problems that are more natural since they avoid the specification of the genetic cross graph in the input and the concomitant quadratic increase in the input size. (c) In the earlier paper, we proved that the synthesis problem was <bold>NP</bold> -complete and developed an integer-linear program (ILP) to solve it, but did not formally analyze the running time of the ILP. Here, we provide fixed-parameter tractable algorithms in natural parameters. In practice, we show that our algorithm for computing an optimal permissible synthesis is over 28 times faster than our previous approach (<xref rid="s5b" ref-type="sec">Section 5.2</xref>).</p>
</sec>
<sec id="s3"><label>3</label><title>Definitions and Problem Formulations</title>
<p>A <italic>mutant &#x03BC;</italic> is equivalent to a set of genes, each of which has been mutated in some manner experimentally, e.g., a deletion (knock-out), disruption, point mutation, over-expression, etc. We will use the term <italic>representative set</italic> to denote the set of genes deleted in a mutant. An element of such a set represents the mutated gene as well as any other necessary experimental information, e.g., the name of the selectable marker introduced with a gene deletion (in budding yeast; see below) or the recessive deleterious mutations and balancers that accompany a mutation (in the fruitfly).</p>
<p>A <italic>cross</italic> is an operation that takes two mutants as input and produces another mutant as output. If <italic>&#x03BC;</italic><sub>1</sub> and <italic>&#x03BC;</italic><sub>2</sub> are the inputs to a cross with the corresponding representative sets <italic>R<sub>1</sub></italic> and <italic>R<sub>2</sub></italic>, then the output is a mutant whose representative set is <italic>R<sub>1</sub></italic> &#x222A; <italic>R<sub>2</sub></italic>. We say that a cross is <italic>verifiable</italic> if the representative sets of the two input mutants to the cross are disjoint.</p>
<p>We formulated these definitions based on experimental and biological considerations. In many organisms, e.g., budding yeast, each gene deletion construct in a mutant strain must have a unique selectable marker that can confirm the deletion, e.g., <italic>a&#x2206;::kanR</italic> represents a deletion of gene <italic>A</italic> and its replacement by the <italic>kanR</italic> G418 resistance gene. Only strains with gene <italic>A</italic> deleted will grow in the presence of the an tibiotic G418, which normally kills budding yeast cells. Similarly, <italic>b&#x0394;::nat</italic> represents a strain carrying a deletion of gene <italic>B</italic> that will grow in the presence of the antibiotic nourseothricin. An experimenter crossing these mutants can select for the <italic>a&#x2206;b&#x2206;</italic> double mutant by growing cells in the presence of both G418 and nourseothricin. Thus, markers or other strategies involving recessive mutations and balancers enable the experimenter to ignore any strain produced by the cross whose representative set is a subset of <italic>R<sub>1</sub></italic> U <italic>R<sub>2</sub></italic>. Moreover, the need to verify only one output strain for each genetic cross facilitates high-throughput experimental workflows. We based our definition of a genetic cross on this rationale. Note that in the example above, the selection of the <italic>a&#x0394;b&#x0394;</italic> double mutantis successful only if the two strains carry different markers. Hence, the notion of verifiability of a cross captures the natural requirement that when we cross two mutants, each gene in a representative set is (implicitly) associated with a marker that is not associated with any other gene in that or the other mutant. By abstracting away unimportant experimental details, these definitions cleanly capture the essential features of a cross while also leading to challenging computational problems.</p>
<p>Given a set of source mutants <italic>S</italic> and a set <italic>T</italic> of target mutants, we say that a sequence of crosses &#x27E8; <italic>x</italic><sub>1</sub>, <italic>x <sub>2</sub></italic>,&#x2026;, <italic>x<sub>k</sub></italic>&#x27E9; is a <italic>synthesis of T from S</italic> if (i) for every mutant <italic>&#x03BC;</italic> &#x03F5; <italic>T</italic>, there is a unique cross <italic>x<sub>i</sub></italic> such that <italic>&#x03BC;</italic> is the output of <italic>x<sub>i</sub></italic>, (ii) both the inputs to <italic>x<sub>1</sub></italic> are from <italic>S</italic> and (iii) for every <italic>i</italic>, 2 &#x2264; <italic>i &#x2206; &#x2264; k</italic>, each input to <italic>x<sub>i</sub> i</italic>is either a member of <italic>S</italic> or an output of one of the crosses <italic>x</italic><sub>1</sub>, <italic>x</italic><sub>2</sub>,&#x2026;, <italic>x</italic><sub>i</sub>&#x2013;1.</p>
<p>The <italic>size</italic> of a synthesis is the number of crosses it contains. We say that a synthesis is <italic>verifiable</italic> if every cross in it is verifiable. In such a synthesis, we say that a mutant is <italic>intermediate</italic> if it is not in <italic>S</italic> U <italic>T</italic> and is used as the input to another cross in the synthesis. Given a set <italic>P</italic> of mutants, we say that a synthesis is <italic>permissible with respect to P</italic> if every intermediate mutant in the synthesis is in <italic>P</italic>. The notion of permissibility takes inspiration from applications where we are interested in computing syntheses that avoid particular intermediate mutants, e.g., when we know that mutants involving a certain gene are certain to be lethal or when mathematical models predict that some mutants are likely to be inviable. Without loss of generality, we assume that a synthesis is <italic>minimal,</italic> i.e., for every cross <italic>x<sub>i</sub></italic>, 1 &#x2264;<italic>i &#x2264; k,</italic> where the output of <italic>x<sub>i</sub></italic> is not a member of <italic>T</italic>, this output is used as an input to a subsequent cross <italic>x<sub>j</sub></italic>, <italic>i</italic> &#x2264; <italic>j</italic> &#x2264; <italic>k</italic>. <xref rid="fig1" ref-type="fig">Figure 1</xref> illustrates several of these definitions.</p>
<fig id="fig1" position="float" orientation="portrait" fig-type="figure"><label>Figure 1:</label>
<caption><p>Illustration of different types of synthesis. Each rectangle denotes a mutant. Each figure shows a synthesis of <italic>{a, b, c}</italic> from source mutants (blue). The rectangle next to a cross denotes the output mutant of that cross. (a) A verifiable, permissible synthesis. (b) A verifiable synthesis that is not permissible because the intermediate mutant <italic>{b, c}</italic> is not permissible. (c) A permissible synthesis that is not verifiable since the two input mutants to the second cross both have gene a in their representative sets. (d) A synthesis that is neither verifiable nor permissible.</p></caption>
<graphic xlink:href="359281_fig1.tif"/>
</fig>
<p>We now formulate the main problem that we study followed by several important special cases:</p>
<sec id="s3a"><title>Minimum Verifiable and Permissible Synthesis (VPS)</title>
<p>Given a set <italic>S</italic> of source mutants, a target mutant <italic>&#x03BC;</italic>, and a set <italic>P</italic> of intermediate mutants, compute a verifiable synthesis of <italic>&#x03BC;</italic> of smallest size from <italic>S</italic> that is permissible with respect to <italic>P</italic>, provided such a synthesis exists.</p>
<p><bold>VS</bold> The inputs to this problem are the source set <italic>S</italic> and the target mutant <italic>&#x03BC;</italic>. We seek to compute a smallest synthesis of <italic>&#x03BC;</italic> starting from <italic>S</italic>. In other words, this problem is identical to VPS except that all mutants are permissible.</p>
<p><bold>VS-2</bold> This version of VS assumes that the representative set of each mutant in <italic>S</italic> has at most two elements. This problem simulates a scenario where an experimentalist has several single-gene mutants and has used them to make double-gene mutants as well.</p>
<p><bold>VS-FL</bold> This version of VS assumes that a fixed number <italic>q</italic> of mutants in <italic>S</italic> whose representative sets are of size three or more (i.e., <italic>q</italic> is a constant independent of the problem size). The name is an abbreviation for &#x201C;VS with a Few Large representative sets.&#x201D; Here, the experimentalist also has access to a small number of mutants with mutations in three or more genes. We are also interested in determining whether a synthesis with the appropriate properties exists. We will use <bold>EVS</bold> to denote the existence version of VS.</p>
</sec>
</sec>
<sec id="s4"><label>4</label><title>Algorithms for Verifiable and Permissible Synthesis</title>
<p>We first consider the VS problem and its variants. In <xref rid="s4a" ref-type="sec">Section 4.1</xref>, we show that EVS is <bold>NP</bold> -complete even when each source mutant has at most three deleted genes. It follows that VS is <bold>NP</bold> -hard, in general. Next, we show that VS-2 can be solved in polynomial time (<xref rid="s4c" ref-type="sec">Section 4.2</xref>). Using this algorithm as a sub-routine, we establish that VS-FL is FPT, where the parameter is the number of source mutants with three or more deleted genes (<xref rid="s4f" ref-type="sec">Section 4.4</xref>). Finally, we develop a FPT dynamic programming algorithm for VPS, where the parameter is the largest size of a representative set of the target mutant (<xref rid="s4g" ref-type="sec">Section 4.5</xref>).</p>
<p>We assume that all the problems take as input a starting set <italic>S</italic> of <italic>s</italic> mutants, specified by representative sets <italic>R<sub>1</sub></italic>, <italic>R<sub>2</sub></italic>, &#x2026;, <italic>R <sub>s</sub></italic> and a target mutant <italic>&#x03BC;&#x2019;</italic> with the representative set <italic>R&#x2019;</italic>, where <italic>r</italic> &#x003D; &#x007C; <italic>R&#x2019;</italic>&#x007C;. We assume without loss of generality that <inline-formula><alternatives><inline-graphic xlink:href="359281_inline1.gif"/></alternatives></inline-formula> since any mutant with a representative set containing a gene that is not in <italic>R&#x2019;</italic> may be removed from <italic>S</italic>. For the VPS problem, the set of permissible mutants is denoted by <italic>P</italic>.</p>
<sec id="s4a"><title>4.1 EVS is NP-complete</title>
<p>We first recall the definition of EVS.</p>
<sec id="s4a1"><title>Existence of a Verifiable Synthesis (EVS)</title>
<sec id="s4a1a"><title>Instance</title>
<p>A set <italic>S</italic> &#x003D; { <italic>&#x03BC;</italic><sub>1</sub>,<italic>&#x03BC;</italic><sub>2</sub>,&#x2026;,<italic>&#x03BC;<sub>s</sub></italic>} of s source mutants, the representative set <italic>R<sub>i</sub></italic> for each mutant <italic>&#x03BC;<sub>i</sub></italic>, 1 &#x2264; <italic>i</italic> &#x2264; <italic>s</italic>; the representative set <italic>R&#x2019;</italic> for a target mutant <italic>&#x03BC;&#x2019;</italic>.</p>
</sec>
<sec id="s4a1b"><title>Question</title>
<p>Is there a verifiable synthesis of <italic>&#x03BC;&#x2019;</italic> from the given set <italic>S</italic> of mutants?</p>
<p>To prove the <bold>NP</bold> -completeness of EVS, we use a reduction from the following problem.</p>
</sec>
</sec>
<sec id="s4a2"><title>Exact Cover by 3-Sets (X3C)</title>
<sec id="s4a2a"><title>Instance</title>
<p>A ground set <italic>Y &#x003D;</italic> {<italic>y</italic><sub>1</sub>,<italic>y</italic><sub>2</sub>,&#x2026;,<italic>y<sub>3n</sub></italic>} of 3<italic>n</italic> elements for some positive integern, a collection <italic>Z</italic> &#x003D; {<italic>Z</italic><sub>1</sub>,<italic>Z</italic><sub>2</sub>,&#x2026;,<italic>Z<sub>m</sub></italic>}, where <italic>Z<sub>j</sub></italic> &#x2286; <italic>Y</italic> and &#x007C;Z<sub>j</sub>&#x007C; &#x007C; &#x003D; 3,1 &#x2264; <italic>j</italic> &#x2264; <italic>m</italic>.</p>
</sec>
<sec id="s4a2b"><title>Question</title>
<p>Is there a subcollection <italic>Z&#x2019;</italic> &#x2286; <italic>Z</italic> such such that &#x007C; <italic>Z&#x2019;</italic>&#x007C; &#x003D; <italic>n</italic> and <inline-formula><alternatives><inline-graphic xlink:href="359281_inline2.gif"/></alternatives></inline-formula></p>
<p>It is well known that X3C is <bold>NP</bold> -complete [<xref ref-type="bibr" rid="c10">10</xref>]. Note that in the specification of X3C, the ground set <italic>Y</italic> has 3<italic>n</italic> elements, the required subcollection <italic>Z<sup>&#x2019;</sup></italic> is of <italic>size n</italic> and each subset in <italic>Z<sup>&#x2019;</sup></italic> has exactly three elements. Therefore, when there is a solution <italic>Z<sup>&#x2019;</sup></italic> to an X3C instance, the subsets in <italic>Z<sup>&#x2019;</sup></italic> are pairwise disjoint.</p>
<statement>
<label>Theorem 4.1.</label><title>EVS is NP-complete even when the representative set for each source mutant has at most three elements</title>
<p><italic>Proof</italic>. It is easy to see that EVS is in <bold>NP</bold> since one can guess a subset <italic>S&#x2019;</italic> of <italic>S</italic> and verify in polynomial time that the sets in <italic>S&#x2019;</italic> are pairwise disjoint and that their union is equal to <italic>S&#x2019;</italic>, the representative set of the target mutant <italic>&#x03BC;&#x2019;</italic>.</p>
<p>To prove <bold>NP</bold> -hardness, we use a reduction from X3C. Let an instance of X3C be specified by the set <italic>Y</italic> (with 3n elements) and the collection <italic>Z</italic> of <italic>m</italic> 3-element subsets of <italic>Y</italic>. We construct an instance of EVS as follows.</p>
<p>1. The set <italic>S &#x003D;</italic> { <italic>&#x03BC;</italic><sub>1</sub>, <italic>&#x03BC;</italic> <sub>2</sub>,&#x2026;, <italic>&#x03BC;<sub>m</sub></italic>} of available mutants is in one-to-one correspondence with the collection of sets <italic>Z</italic> of the X3C instance. For mutant <italic>&#x03BC;j,</italic> the representative set is <italic>Zj</italic>, 1 &#x2264; <italic>j</italic> &#x2264; <italic>m</italic>. Thus, the number of source mutants is <italic>m</italic> and the representative set for each input mutant has exactly three elements.</p>
<p>2. The representative set <italic>S<sup>&#x2019;</sup></italic> for the target mutant <italic>&#x03BC;&#x2019;</italic> is <italic>Y</italic>.</p>
<p>It is easy to see that this construction can be carried out in polynomial time.</p>
<p>Suppose there is a solution <inline-formula><alternatives><inline-graphic xlink:href="359281_inline3.gif"/></alternatives></inline-formula> to the X3C instance. A verifiable synthesis of <italic>&#x03BC;&#x2019;</italic> consisting of the sequence &#x27E8; <italic>x</italic><sub>1</sub>, <italic>x</italic><sub>2</sub>,&#x2026;, <italic>x<sub>n&#x2014;1</sub></italic>&#x27E9; of crosses is as follows:
<list list-type="alpha-lower">
<list-item><p>The inputs to <italic>x</italic><sub>1</sub> are mutants <inline-formula><alternatives><inline-graphic xlink:href="359281_inline4.gif"/></alternatives></inline-formula> and <inline-formula><alternatives><inline-graphic xlink:href="359281_inline5.gif"/></alternatives></inline-formula></p></list-item>
<list-item><p>For each <italic>j</italic>, 2 &#x2264; <italic>j</italic> &#x2264; <italic>n</italic> &#x2014; 1, the inputs to <italic>x<sub>j</sub></italic> are the mutant <inline-formula><alternatives><inline-graphic xlink:href="359281_inline6.gif"/></alternatives></inline-formula> and the output of <italic>x<sub>j</sub></italic>&#x2212;1.</p></list-item></list></p>
<p>Since the union of the sets in <italic>Z&#x2019;</italic> is equal to <italic>Y</italic>, the output of <italic>x<sub>n-1</sub></italic> is the mutant <italic>&#x03BC;&#x2019;</italic>. Further, since the sets in <italic>Z&#x2019;</italic> are pairwise disjoint, this is a verifiable synthesis. In other words, we have a solution to the EVS instance.</p>
<p>Suppose we have a solution to the EVS instance. Let <inline-formula><alternatives><inline-graphic xlink:href="359281_inline7.gif"/></alternatives></inline-formula> denote the source mutants used in the synthesis and let <inline-formula><alternatives><inline-graphic xlink:href="359281_inline8.gif"/></alternatives></inline-formula> denote their respective representative sets. Thus, <inline-formula><alternatives><inline-graphic xlink:href="359281_inline9.gif"/></alternatives></inline-formula>. Moreover, since we have a verifiable synthesis of <italic>&#x03BC;&#x2019;</italic>, each pair of representative sets used in the synthesis is disjoint. Further, each representative set has exactly three elements and their union is the set <italic>Z&#x2019;</italic>, where &#x007C;<italic>Z&#x2019;</italic>&#x007C; &#x003D; 3<italic>n</italic>. Thus, the number of representative sets used must be exactly <italic>n</italic>. In other words, the sets <inline-formula><alternatives><inline-graphic xlink:href="359281_inline10.gif"/></alternatives></inline-formula> constitute a solution to the X3C instance, and this argument completes the proof of Theorem 4.1.&#x20DE;</p>
</statement>
</sec>
</sec>
</sec>
<sec id="s4c"><title>4.2 An Efficient Algorithm for VS-2</title>
<p>Here, we consider VS-2, a restricted version of EVS, where the representative set of each input mutant has <italic>at most two</italic> elements. We show that VS-2 can be solved efficiently, thus providing a clear delineation between the <bold>NP</bold> -hard and efficiently solvable versions of EVS. Our polynomial time algorithm for VS-2 relies on a known algorithm for the following problem.</p>
<sec id="s4c1"><title>Degree Constrained Subgraph (DCS)</title>
<p>Given an undirected graph <italic>G</italic> (<italic>V, E</italic>) with &#x007C; <italic>V</italic>&#x007C; &#x003D; <italic>n</italic>, and non-negative integers a <sub>i</sub> and <italic>b</italic><sub>i</sub> for each node v<sub>i</sub> &#x03F5; <italic>V</italic>, 1 &#x2264; <italic>i</italic> &#x2264; <italic>n</italic>, is there a subgraph <italic>G&#x2019;</italic>(<italic>V, E&#x2019;</italic>) of G, where <italic>E&#x2019;</italic> &#x2286; <italic>E</italic>, such that for each node <italic>v<sub>i</sub></italic>, 1 &#x2264; <italic>i</italic> &#x2264; <italic>n</italic>, the degree of v<sub>i</sub> in <italic>G&#x2019;</italic>, denoted by <italic>d&#x2019;</italic>(<italic>v<sub>i</sub></italic>), satisfies the condition <italic>a <sub>i</sub></italic> &#x2264; <italic>d&#x2019;(v <sub>i</sub></italic>) &#x2264; <italic>b<sub>i</sub></italic>?</p>
<p>The DCS problem can be solved in time <inline-formula><alternatives><inline-graphic xlink:href="359281_inline11.gif"/></alternatives></inline-formula> [<xref ref-type="bibr" rid="c9">9</xref>]. Moreover, this algorithm can be modified to compute a subgraph with the fewest edges that satisfies the conditions of the problem with the same running time [<xref ref-type="bibr" rid="c13">13</xref>]. We obtain our result for VS-2 by reducing it to DCS and using the algorithm for DCS in [<xref ref-type="bibr" rid="c13">13</xref>]. The details of our algorithm for VS-2 appear in Algorithm 1. See <xref rid="fig2" ref-type="fig">Figure 2</xref> for an illustration.</p>
<fig id="fig2" position="float" orientation="portrait" fig-type="figure"><label>Figure 2:</label>
<caption><p>Reduction of VS to DCS. (a) The top show the input to VS with six source mutants (blue boxes) and one target mutant (yellow box). The bottom shows the corresponding DCS instance. Numbers in parentheses indicate bounds on degrees. (b) Feasible solution to DCS (edges with a blue outline). This solution is equivalent to three crosses to make the target mutant (<italic>g</italic><sub>1</sub>, <italic>g</italic><sub>2</sub>, <italic>g</italic><sub>4</sub>, <italic>g</italic><sub>4</sub>). (c) An optimal solution to DCS that yields two crosses to make (<italic>g</italic><sub>1</sub>, <italic>g</italic><sub>2</sub>, <italic>g</italic><sub>4</sub>, <italic>g</italic><sub>4</sub>). (d) An instance of VS that does not have a solution. Such an input may arise when single gene deletions of <italic>g</italic><sub>2</sub> and <italic>g</italic><sub>4</sub> make the cell inviable but the double deletions (<italic>g</italic><sub>2</sub>, <italic>g</italic><sub>3</sub>) and (<italic>g</italic><sub>3</sub>, <italic>g</italic><sub>4</sub>) are obtained via transformation.</p></caption>
<graphic xlink:href="359281_fig2.tif"/>
</fig>
<p>We now establish the correctness of the algorithm and estimate its running time to prove the following theorem.</p>
<statement><title>Theorem 4.2</title>
<p><italic>Algorithm 1 correctly solves the</italic> VS-2 <italic>problem in</italic> <inline-formula><alternatives><inline-graphic xlink:href="359281_inline12.gif"/></alternatives></inline-formula> <italic>time using O</italic>(<italic>r</italic> &#x002B; <italic>s</italic>) space, where s is number of source mutants and r is the size of the representative set of the target mutant.</p>
<p><italic>Proof</italic>. We will refer to the steps of this algorithm throughout this proof.</p>
<p><bold>Correctness</bold>: We first consider the case where the algorithm produces a solution and prove that the representative sets of the mutants in the solution are pairwise disjoint and their union is the set <italic>R&#x2019;</italic>. Let <inline-formula><alternatives><inline-graphic xlink:href="359281_inline13.gif"/></alternatives></inline-formula>, be the mutants chosen in the solution; their respective representative sets are <inline-formula><alternatives><inline-graphic xlink:href="359281_inline14.gif"/></alternatives></inline-formula>. Suppose there is a pair of representative sets in the solution, say <inline-formula><alternatives><inline-graphic xlink:href="359281_inline15.gif"/></alternatives></inline-formula> and <inline-formula><alternatives><inline-graphic xlink:href="359281_inline16.gif"/></alternatives></inline-formula>, which are not disjoint. Let <italic>g<sub>p</sub></italic> be an element that appears in both <inline-formula><alternatives><inline-graphic xlink:href="359281_inline17.gif"/></alternatives></inline-formula> and <inline-formula><alternatives><inline-graphic xlink:href="359281_inline18.gif"/></alternatives></inline-formula>. Since each representative set represents an edge in the DCS instance, it follows that the degree of the node <italic>w<sub>p</sub></italic> &#x03F5; <italic>V</italic><sub>1</sub> corresponding to <italic>g<sub>p</sub></italic> is at least two. This contradicts the requirement that the upper bound on the degree of each node in V<sub>1</sub> is one. Thus, the representative sets in the solution are indeed pairwise disjoint. Now suppose that <inline-formula><alternatives><inline-graphic xlink:href="359281_inline19.gif"/></alternatives></inline-formula>. Thus, some element g <sub>q</sub> &#x03F5; <italic>R&#x2019;</italic> does not appear in any of the sets in the solution. In other words, in the solution to the DCS instance, the degree of node <italic>w<sub>q</sub></italic> &#x03F5; <italic>V</italic><sub>1</sub> corresponding to <italic>x<sub>q</sub></italic> is zero. This contradicts the requirement that the lower bound on the degree of each node in <italic>V</italic><sub>1</sub> is one. Thus, whenever the algorithm produces a solution, the chosen mutants can be used to construct a verifiable synthesis of the required mutant <italic>&#x03BC;&#x2019;</italic>.
<fig id="Alg1" position="float" orientation="portrait" fig-type="figure"><label>Algorithm 1:</label>
<caption><title>An algorithm for VS-2.</title></caption>
<graphic xlink:href="359281_Alg1.tif"/>
</fig></p>
<p>Now, suppose the algorithm outputs &#x201C;No&#x201D;. We show by contradiction that there is no solution to the VS-2 instance. Assume to the contrary that there is indeed a solution with mutants <inline-formula><alternatives><inline-graphic xlink:href="359281_inline20.gif"/></alternatives></inline-formula> with corresponding representative sets <inline-formula><alternatives><inline-graphic xlink:href="359281_inline21.gif"/></alternatives></inline-formula>. Since each of these sets is represented by an edge in the DCS instance, let <inline-formula><alternatives><inline-graphic xlink:href="359281_inline22.gif"/></alternatives></inline-formula> represent the corresponding edges in G. We argue that the subgraph <italic>G&#x2019;(V, E</italic>&#x2019;) is a solution to the DCS instance by considering each node in <italic>V</italic>. There are two cases depending on whether the node is in <italic>V</italic><sub>1</sub> or in <italic>V</italic><sub>2</sub>.</p>
<p><underline>Case 1:</underline> Consider any node <italic>w<sub>p</sub></italic> &#x03F5; <italic>V <sub>1</sub></italic> We need to show that the degree of <italic>w<sub>p</sub></italic> in <italic>G&#x2019;</italic> is 1. To see this, note that node <italic>w<sub>p</sub></italic> appears in some edge of <italic>E</italic>&#x2019; since <inline-formula><alternatives><inline-graphic xlink:href="359281_inline23.gif"/></alternatives></inline-formula>. Thus, the degree of <italic>w<sub>p</sub></italic> in <italic>G&#x2019;</italic> is at least 1. If degree of <italic>w<sub>p</sub></italic> is &#x2265; 2, then the corresponding element <italic>x<sub>p</sub></italic> appears in two or more sets of the solution; this contradicts the assumption that the solution sets are pairwise disjoint. Thus, the degree of <italic>w<sub>p</sub></italic> is 1.</p>
<p><underline>Case 2:</underline> Consider any node <italic>h<sub>q</sub></italic> &#x03F5; <italic>V</italic><sub>2</sub>. The degree of <italic>h<sub>q</sub></italic> in <italic>G&#x2019;</italic> is at most 1 since each node <italic>h<sub>q</sub></italic> in <italic>V</italic><sub>2</sub> has a degree of 1 in <italic>G</italic>.</p>
<p>Thus, we contradict the assumption that the algorithm outputs &#x201C;No&#x201D;. This argument completes the proof of correctness.</p>
<p><bold>Analysis of running time and space used.</bold> The constructed DCS instance has <italic>r</italic> &#x002B; <italic>q</italic> nodes (where <italic>r &#x003D;</italic> &#x007C; <italic>R&#x2019;</italic>&#x007C; and <italic>q</italic> &#x2264; <italic>s</italic> is the number of singleton representative sets of source mutants) and <italic>s</italic> edges. Thus, we can construct the graph in <italic>O</italic> (<italic>r</italic> &#x002B;<italic>s</italic>) time. The upper bound on the degree of each node is 1. Thus, we can obtain the optimal solution to the DCS instance in <inline-formula><alternatives><inline-graphic xlink:href="359281_inline24.gif"/></alternatives></inline-formula> time [<xref ref-type="bibr" rid="c9">9</xref>, <xref ref-type="bibr" rid="c13">13</xref>]. Since the solution produced by the algorithm for DCS has at most s edges, we can find the representative sets in the solution in <italic>O</italic> (<italic>s</italic>) time. Thus, the overall running time of the algorithm is <inline-formula><alternatives><inline-graphic xlink:href="359281_inline25.gif"/></alternatives></inline-formula>. Further, since the size of each representative set of a source mutant is at most two and that of the target mutant is <italic>r,</italic> the space used by the algorithm is <italic>O</italic> (<italic>r</italic> &#x002B; s). This discussion completes the proof of the theorem.&#x20DE;</p>
</statement>
</sec>
</sec>
<sec id="s4e"><title>4.3 An ILP for the DCS Problem</title>
<p>In <xref rid="s4c" ref-type="sec">Section 4.2</xref> we showed that VS-2 can be solved in polynomial time by a reduction to the DCS problem. In this section, we develop a simple {0,1} integer linear program (ILP) to solve the DCS problem. We use this ILP in lieu of Algorithm 1 in our experimental results in <xref rid="s5" ref-type="sec">Section 5</xref> since our problem instances are reasonably small in practice.</p>
<p>Consider a DCS problem instance specified by a graph <italic>G(V,E</italic>), where <italic>V &#x003D;</italic> {<italic>v</italic><sub>1</sub>, <italic>v</italic><sub>2</sub>,&#x2026;, <italic>v<sub>n</sub></italic>} and <italic>E &#x003D;</italic> {<italic>e<sub>1</sub></italic>, <italic>e</italic><sub>2</sub>,&#x2026;, <italic>e<sub>r</sub></italic>}. Let the lower and upper bounds on the degree of node <italic>v<sub>i</sub></italic> be <italic>a<sub>i</sub></italic> and <italic>b<sub>i</sub></italic> respectively; that is, in the subgraph <italic>G&#x2019;(V,E&#x2019;)</italic> to be found, degree of <italic>v<sub>i</sub></italic> must satisfy the condition <italic>a<sub>i</sub></italic>&#x2264; degree of <italic>v<sub>i</sub></italic> &#x2264; <italic>b<sub>i</sub></italic>,1 &#x2264; <italic>i</italic> &#x2264; <italic>n</italic>. We also want to minimize the number of edges in <italic>E<sup>&#x2019;</sup></italic>.</p>
<p>The ILP has a {0,1} variable <italic>x<sub>i</sub></italic> for each edge <italic>e<sub>i</sub></italic>, 1 &#x2264; <italic>i</italic> &#x2264; <italic>r,</italic> with the following interpretation: if <italic>x<sub>i</sub></italic> &#x003D; 1, edge <italic>e<sub>i</sub></italic> is included in the solution; otherwise, <italic>e<sub>i</sub></italic> is not in the solution. So, the objective of the ILP is:
<disp-formula><alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="359281_ueqn1.gif"/></alternatives></disp-formula>
For each node <italic>v<sub>i</sub>,</italic> there are two constraints, corresponding to the upper and lower bounds on the degree of <italic>v<sub>i</sub></italic> in <italic>G&#x2019;</italic>. Let <italic>Q<sub>i</sub></italic> &#x2286; <italic>E</italic> be set of edges of <italic>G</italic> which are incident on node <italic>v<sub>i</sub></italic>. The constraints for node <italic>v<sub>i</sub></italic> are:
<disp-formula><alternatives><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="359281_ueqn2.gif"/></alternatives></disp-formula>
Thus, we get a total of 2<italic>n</italic> constraints. For any node <italic>v<sub>i</sub></italic> whose the lower bound <italic>a<sub>i</sub></italic> is 0, we omit the corresponding constraint. We solve this ILP using IBM CPLEX software.</p>
<fig id="Alg2" position="float" orientation="portrait" fig-type="figure"><label>Algorithm 2:</label>
<caption><title>An algorithm for VS-FL.</title></caption>
<graphic xlink:href="359281_Alg2.tif"/>
</fig>
</sec>
<sec id="s4f"><label>4.4</label><title>Fixed Parameter Tractability of VS</title>
<p>Here, we consider VS-FL, another restricted version of VS, where the number <italic>q</italic> of mutants whose representative sets are of size 3 or more is <italic>fixed</italic> (i.e a constant independent of the problem size). We assume that <italic>q ></italic> 0; otherwise, we have the VS-2 problem which can be solved in polynomial time (<xref rid="s4c" ref-type="sec">Section 4.2</xref>). We show that VS-FL can be solved in <inline-formula><alternatives><inline-graphic xlink:href="359281_inline26.gif"/></alternatives></inline-formula> time using <italic>O</italic> (<italic>rs</italic>) space, where <italic>r</italic> &#x003D; &#x007C;<italic>R&#x2019;</italic>&#x007C; and s is the number of source mutants. More importantly, this result points out that VS-FL is <italic>fixed parameter tractable,</italic> with respect to the parameter <italic>q</italic> [<xref ref-type="bibr" rid="c19">19</xref>], since the component of the running time that is independent of <italic>q</italic> is polynomial in the input size.</p>
<p>The principle underlying our algorithm for VS-FL is simple. Let <italic>L</italic> denote the collection of representative sets (of source mutants) whose size is at least three. We use <italic>q</italic> to denote the fixed size of <italic>L</italic>. We consider all the possible 2<sup>q</sup> subcollections (including the empty subcollection) of <italic>L</italic>. For each such subcollection <italic>L&#x2019;</italic>, the union of the sets in <italic>L<sup>&#x2019;</sup></italic> contributes some of the elements of the representative set <italic>R&#x2019;</italic> of the target mutant <italic>&#x03BC;&#x2019;</italic>. The remaining elements of <italic>R&#x2019;</italic> must be synthesized using mutants whose representative sets are of size at most two, giving rise to an instance of the VS-2 problem, which can be solved using the algorithm of <xref rid="s4c" ref-type="sec">Section 4.2</xref>. The details of our method appear in Algorithm 2. Note that this algorithm determines if a verifiable synthesis of <italic>&#x03BC;&#x2019;</italic> exists. It is easy to modify it to compute a verifiable synthesis of smallest size: In Step 2(iii), instead of stopping when we find a synthesis, we record the size of the synthesis and return a smallest synthesis computed over all executions of this step.</p>
<p>We now prove the following theorem.</p>
<statement><title>Theorem 4.3.</title>
<p><italic>Algorithm 2 solves the</italic> VS-FL <italic>problem in</italic> <inline-formula><alternatives><inline-graphic xlink:href="359281_inline27.gif"/></alternatives></inline-formula><italic>time using O(rs) space. Thus, the</italic> VS-FL <italic>problem is fixed parameter tractable in q, the number of representative sets of input mutants with three or more elements</italic>.</p>
<p><italic>Proof</italic>. We prove the theorem by establishing the correctness of Algorithm 2 and then showing that its running time has the appropriate form to imply the fixed parameter tractability of VS-FL.</p>
<p><bold>Correctness:</bold> It is obvious that when the algorithm returns a solution, the representative sets in the solution are pairwise disjoint and their union is equal to <italic>R&#x2019;</italic>, the representative set of the target mutant <italic>&#x03BC;&#x2019;</italic>. So, we need only consider the case when the algorithm outputs &#x201C;No&#x201D;. For the sake of contradiction, assume that the algorithm outputs &#x201C;No&#x201D;, yet there is a solution to the VS-FL instance. Suppose the solution uses a subcollection <italic>L&#x2019;</italic> of <italic>L</italic> (where <italic>L&#x2019;</italic> may be empty) and subcollection <italic>B&#x2019;</italic> of <italic>B</italic> &#x003D; <italic>{R<sub>q&#x002B;1</sub></italic>,&#x2026;,<italic>R<sub>s</sub></italic>}. Since the algorithm considers all subcollections of <italic>L</italic> (including the empty subcollection), it considers <italic>L <sup>&#x2019;</sup></italic> at some stage. The sets in the solution are pairwise disjoint and the union of the sets in <italic>B&#x2019;</italic> &#x222A; <italic>L&#x2019;</italic> is equal to <italic>R&#x2019;</italic>. Let the union of the sets in <italic>L&#x2019;</italic> be denoted by A. Thus, the union of the sets in <italic>B&#x2019;</italic> must be equal to <italic>R&#x2019;&#x2019;</italic> &#x003D; <italic>R&#x2019; &#x2014; A</italic>. Note that each set in <italic>B&#x2019;</italic> has size at most two. Hence, the subcollection <italic>B&#x2019;</italic> and set <italic>R&#x2019;&#x2019;</italic> constitute an instance of VS-2 for which a solution is B&#x2019;. Therefore, the algorithm for VS-2 cannot output &#x201C;No&#x201D;. This contradiction completes the correctness proof.</p>
<p><bold>Analysis of running time and space used:</bold> Since &#x007C; <italic>L</italic>&#x007C; &#x003D; <italic>q</italic>, the number of iterations of the for loop in Step 2 of Algorithm 2 is at most 2<italic><sup>q</sup></italic>. Let &#x007C; <italic>R&#x2019;</italic>&#x007C; &#x003D; <italic>r</italic>. Thus, each representative set has size at most r. For each subcollection <italic>L&#x2019;</italic> (which has at most <italic>q</italic> sets), the set <italic>R&#x2019;&#x2019;</italic> in Step 2(i) of Algorithm 2 can be computed in <italic>O</italic> (<italic>rq</italic>) time. Further, the subcollection <italic>B&#x2019;</italic> of <italic>B</italic> &#x003D; {<italic>R<sub>q</sub></italic>&#x002B;1,&#x2026;,<italic>R<sub>s</sub></italic>} such that the intersection between any set in <italic>B&#x2019;</italic> and any set in <italic>L&#x2019;</italic> is empty can be constructed in <italic>O(qrs)</italic> time. The resulting instance of VS-2 has at most <italic>s</italic> sets (each of size one or two) and a representative set <italic>R&#x2019;&#x2019;</italic> of size at most <italic>r</italic>. Therefore, by Theorem 4.2, the VS-2 instance can be solved in time <inline-formula><alternatives><inline-graphic xlink:href="359281_inline28.gif"/></alternatives></inline-formula> time. Thus, the running time for each subcollection <italic>L&#x2019;</italic> is <inline-formula><alternatives><inline-graphic xlink:href="359281_inline29.gif"/></alternatives></inline-formula>. Since the algorithm tries at most 2<italic><sup>q</sup></italic> subcollections, the overall running time is <inline-formula><alternatives><inline-graphic xlink:href="359281_inline30.gif"/></alternatives></inline-formula>. This running time has the form <italic>O(h(q)N<sup>O</sup></italic><sup>(1)</sup>), where <italic>h(q)</italic> &#x003D; <italic>q2<sup>q</sup></italic>depends only on the parameter <italic>q</italic> and <italic>N &#x003D; rs</italic> is the size of the VS-FL instance. Hence, VS-FL is fixed parameter tractable with respect to the parameter <italic>q</italic>. Further, since the size of the representative set of each mutant is at most <italic>r</italic> and the total number of mutants (i.e., source and target mutants) is s &#x002B; 1, the space used by the algorithm is <italic>O</italic>(<italic>rs</italic>). This completes the proof of the theorem.&#x20DE;</p>
</statement>
</sec>
<sec id="s4g"><label>4.5</label><title>Fixed Parameter Tractability of VPS</title>
<p>We now turn our attention to the VPS problem. Recall that we are given a set <italic>S</italic> of <italic>s</italic> source mutants, a set <italic>P</italic> of <italic>p</italic> permissible mutants, and a target mutant <italic>&#x03BC;&#x2019;</italic>. Our goal is to compute a verifiable synthesis of <italic>&#x03BC;&#x2019;</italic> of smallest size from the mutants in <italic>S</italic> that is permissible with respect to <italic>P,</italic> if such a synthesis exists. We present an FPT algorithm for this problem in the parameter <italic>k</italic> &#x003D; &#x007C; <italic>R&#x2019;</italic>&#x007C;, where <italic>R&#x2019;</italic> is the representative set of the target mutant <italic>&#x03BC;&#x2019;</italic>.</p>
<p>We assume that every mutants in <italic>S</italic> and in <italic>P</italic> has a representative set of size at most <italic>k,</italic> since only such a mutant can be used in the synthesis of <italic>&#x03BC;&#x2019;</italic>. We also assume that each source mutant is permissible, as is the target mutant. We start with a simple definition that captures the notion of verifiable and permissible synthesis.</p>
<fig id="Alg3" position="float" orientation="portrait" fig-type="figure"><label>Algorithm 3:</label>
<caption><title>A dynamic programming algorithm for EVPS.</title></caption>
<graphic xlink:href="359281_Alg3.tif"/>
</fig>
<sec id="s4g1"><title>Definition 4.1</title>
<p><italic>A target mutant &#x03BC;&#x2019; is</italic> P-realizable <italic>(for &#x201C;Physically realizable &#x201C;) if (&#x03B1;) &#x03BC;&#x2019; is a source mutant or (b) there is a verifiable synthesis of &#x03BC;&#x2019; from the source mutants such that each intermediate mutant in the synthesis is permissible</italic>.</p>
<p>Thus, our goal is to determine whether a given target mutant <italic>&#x03BC;&#x2019;</italic> is P-realizable. In developing our algorithm, it is useful to define a computational notion of realizability, which we call C-realizability. A recursive definition of this notion is as follows.</p>
</sec>
<sec id="s4g2"><title>Definition 4.2</title>
<p><italic>A target mutant &#x03BC;&#x2019; with representative set R&#x2019; is</italic> C-realizable <italic>(for &#x201C;Computationally realizable&#x201D;) if (a) &#x03BC;&#x2019; is a source mutant or (b) there is a partition of R&#x2019; into two subsets</italic> <inline-formula><alternatives><inline-graphic xlink:href="359281_inline31.gif"/></alternatives></inline-formula> <italic>and</italic> <inline-formula><alternatives><inline-graphic xlink:href="359281_inline32.gif"/></alternatives></inline-formula> <italic>such that the two corresponding mutants</italic> <inline-formula><alternatives><inline-graphic xlink:href="359281_inline33.gif"/></alternatives></inline-formula> <italic>and</italic> <inline-formula><alternatives><inline-graphic xlink:href="359281_inline34.gif"/></alternatives></inline-formula> <italic>are both permissible and C-realizable</italic>.</p>
<p>The following theorem states that the notions of P-realizability and C-realizability are equivalent.</p>
<statement><title>Theorem 4.4</title>
<p><italic>A permissible target mutant &#x03BC;&#x2019; is C-realizable if and only if it is P-realizable</italic>.</p>
<p><italic>Proof</italic>. <bold>Part 1 (If):</bold> Suppose <italic>&#x03BC;&#x2019;</italic> is permissible and P-realizable. We use induction on the size of <italic>R&#x2019;</italic>, the representative set of <italic>&#x03BC;&#x2019;</italic> to show that <italic>&#x03BC;&#x2019;</italic> is C-realizable. Let <italic>&#x03B1; &#x2265;</italic> 1 be the minimum size of the representative set of a source mutant. Since <italic>&#x03BC;&#x2019;</italic> is permissible, &#x007C; <italic>R&#x2019;</italic>&#x007C; &#x2265;<italic>&#x03B1;</italic>.</p>
<p><bold>Basis:</bold> &#x007C;<italic>R&#x2019;</italic>&#x007C; &#x003D; <italic>&#x03B1;</italic>. In this case, since <italic>&#x03BC;&#x2019;</italic> is permissible, it is a source mutant. By definition, each source mutant is C-realizable. Hence, the basis holds.</p>
<p><bold>Inductive hypothesis:</bold> Assume that for some <italic>r</italic> &#x2265; <italic>&#x03B1;</italic>, every permissible and P-realizable mutant <italic>&#x03BC;</italic> whose representative set is of size &#x2264; <italic>r</italic> is also C-realizable.</p>
<p><bold>Inductive proof:</bold> Let <italic>&#x03BC;&#x2019;</italic> be a permissible and P-realizable mutant whose representative set <italic>R&#x2019;</italic> is of size <italic>r</italic> &#x002B; 1. We need to prove that <italic>&#x03BC;&#x2019;</italic> is also C-realizable.</p>
<p>If <italic>&#x03BC;&#x2019;</italic> is a source mutant, then it is C-realizable by definition. So, assume that <italic>&#x03BC;&#x2019;</italic> is not a source mutant. Thus, there is a verifiable synthesis of <italic>&#x03BC;&#x2019;</italic> such that each intermediate mutant in the synthesis is permissible.</p>
<p>Consider the last cross operation x in this synthesis. Let <inline-formula><alternatives><inline-graphic xlink:href="359281_inline35.gif"/></alternatives></inline-formula> and <inline-formula><alternatives><inline-graphic xlink:href="359281_inline36.gif"/></alternatives></inline-formula> denote the mutants which form the inputs to <italic>x</italic>. Hence, both <inline-formula><alternatives><inline-graphic xlink:href="359281_inline37.gif"/></alternatives></inline-formula> and <inline-formula><alternatives><inline-graphic xlink:href="359281_inline38.gif"/></alternatives></inline-formula> are permissible and the corresponding representative sets <inline-formula><alternatives><inline-graphic xlink:href="359281_inline39.gif"/></alternatives></inline-formula> and <inline-formula><alternatives><inline-graphic xlink:href="359281_inline40.gif"/></alternatives></inline-formula> are disjoint. Thus, there is a verifiable synthesis of <inline-formula><alternatives><inline-graphic xlink:href="359281_inline41.gif"/></alternatives></inline-formula> and <inline-formula><alternatives><inline-graphic xlink:href="359281_inline42.gif"/></alternatives></inline-formula> such that each intermediate mutant in the synthesis is permissible. In other words, both <inline-formula><alternatives><inline-graphic xlink:href="359281_inline43.gif"/></alternatives></inline-formula> and <inline-formula><alternatives><inline-graphic xlink:href="359281_inline44.gif"/></alternatives></inline-formula> are permissible and P-realizable. Further, the sizes of the corresponding representative sets <inline-formula><alternatives><inline-graphic xlink:href="359281_inline45.gif"/></alternatives></inline-formula> and <inline-formula><alternatives><inline-graphic xlink:href="359281_inline46.gif"/></alternatives></inline-formula> are &#x2264; <italic>r</italic>. Therefore, by the inductive hypothesis, both <inline-formula><alternatives><inline-graphic xlink:href="359281_inline47.gif"/></alternatives></inline-formula> and <inline-formula><alternatives><inline-graphic xlink:href="359281_inline48.gif"/></alternatives></inline-formula> are C-realizable. In addition, sets <inline-formula><alternatives><inline-graphic xlink:href="359281_inline49.gif"/></alternatives></inline-formula> and <inline-formula><alternatives><inline-graphic xlink:href="359281_inline50.gif"/></alternatives></inline-formula> are disjoint and their union is <italic>R&#x2019;</italic>. In other words, <inline-formula><alternatives><inline-graphic xlink:href="359281_inline51.gif"/></alternatives></inline-formula> and <inline-formula><alternatives><inline-graphic xlink:href="359281_inline52.gif"/></alternatives></inline-formula> form a partition of <italic>R&#x2019;</italic> and the two corresponding mutants <inline-formula><alternatives><inline-graphic xlink:href="359281_inline53.gif"/></alternatives></inline-formula> and <inline-formula><alternatives><inline-graphic xlink:href="359281_inline54.gif"/></alternatives></inline-formula> are both C-realizable. Thus, by definition, <italic>&#x03BC;&#x2019;</italic> is also C-realizable. This completes the proof of Part 1.</p>
<p><bold>Part 2 (Only If):</bold> Suppose <italic>&#x03BC;&#x2019;</italic> is permissible and C-realizable. We again use induction on the size of <italic>R&#x2019;</italic> to show that <italic>&#x03BC;&#x2019;</italic> is also P-realizable. As before, let <italic>&#x03B1;</italic> &#x2265; 1 be the minimum size of the representative set of a source mutant. Since <italic>&#x03BC;&#x2019;</italic> is permissible, &#x007C; <italic>R&#x2019;</italic>&#x007C; &#x2265; <italic>&#x03B1;</italic>.</p>
<p><bold>Basis:</bold> &#x007C; <italic>R&#x2019;</italic>&#x007C; &#x003D; <italic>&#x03B1;</italic>. In this case, since <italic>&#x03BC;&#x2019;</italic> is permissible, it is a source mutant. By definition, each source mutant is P-realizable. Hence, the basis holds.</p>
<p><bold>Inductive hypothesis:</bold> Assume that for some <italic>r</italic> &#x2265; <italic>&#x03B1;</italic>, every permissible and C-realizable mutant <italic>&#x03BC;</italic> whose representative set is of size &#x2264; <italic>r</italic> is also P-realizable.</p>
<p><bold>Inductive proof:</bold> Let <italic>&#x03BC;&#x2019;</italic> be a permissible and C-realizable mutant whose representative set <italic>R&#x2019;</italic> is of size <italic>r</italic> &#x002B; 1. We will prove that <italic>&#x03BC;&#x2019;</italic> is also P-realizable.</p>
<p>If <italic>&#x03BC;&#x2019;</italic> is a source mutant, then it is P-realizable by definition. So, assume that <italic>&#x03BC;&#x2019;</italic> is not a source mutant. Since <italic>&#x03BC;&#x2019;</italic> is C-realizable, there is a partition of <italic>R&#x2019;</italic> into two two subsets <inline-formula><alternatives><inline-graphic xlink:href="359281_inline55.gif"/></alternatives></inline-formula> and <inline-formula><alternatives><inline-graphic xlink:href="359281_inline56.gif"/></alternatives></inline-formula> such that the two corresponding mutants <inline-formula><alternatives><inline-graphic xlink:href="359281_inline57.gif"/></alternatives></inline-formula> and <inline-formula><alternatives><inline-graphic xlink:href="359281_inline58.gif"/></alternatives></inline-formula> are both permissible and C-realizable. Note that <inline-formula><alternatives><inline-graphic xlink:href="359281_inline59.gif"/></alternatives></inline-formula> and <inline-formula><alternatives><inline-graphic xlink:href="359281_inline60.gif"/></alternatives></inline-formula>. Thus, by the induction hypothesis, both <inline-formula><alternatives><inline-graphic xlink:href="359281_inline61.gif"/></alternatives></inline-formula> and <inline-formula><alternatives><inline-graphic xlink:href="359281_inline62.gif"/></alternatives></inline-formula> are permissible and P-realizable. Now, construct a synthesis of <italic>&#x03BC;&#x2019;</italic> by adding a new cross operation x whose inputs are the mutants <inline-formula><alternatives><inline-graphic xlink:href="359281_inline63.gif"/></alternatives></inline-formula> and <inline-formula><alternatives><inline-graphic xlink:href="359281_inline64.gif"/></alternatives></inline-formula>. (Note that these may be source mutants or outputs of cross operations.) It is easy to see that this is a verifiable synthesis of <italic>&#x03BC;&#x2019;</italic> where each intermediate mutant is permissible. In other words,<italic>&#x03BC;&#x2019;</italic> is P-realizable, and this completes the proof of Part 2 as well as that of the theorem.&#x20DE;</p>
</statement>
<p>In view of the above theorem, we can use the notion of C-realizability to develop a dynamic programming (DP) algorithm to solve the EVPS problem for a target mutant <italic>&#x03BC;&#x2019;</italic>. Let &#x007C; <italic>R&#x2019;</italic>&#x007C; &#x003D; <italic>k</italic> and let &#x2286;(R&#x2019;) &#x003D; <inline-formula><alternatives><inline-graphic xlink:href="359281_inline65.gif"/></alternatives></inline-formula> denote an ordered collection of all the non-empty subsets of where the subsets are in <italic>non-decreasing</italic> order of size; thus, for each i, 1 &#x2264; <italic>i</italic> &#x2264;<italic>k</italic> &#x2014; 1, all subsets of size i precede all those with size <italic>i</italic> &#x002B; 1. The DP algorithm uses a Boolean array &#x0392; of size 2<sup>k</sup> &#x2014; 1. For convenience, we will index the elements of B with the subsets in <italic>&#x2119; (R&#x2019;</italic>); that is, &#x0392;[<italic>&#x03B3;</italic>] denotes the entry of the array corresponding to the subset <italic>&#x03B3;</italic> &#x2286;&#x2119; (<italic>R&#x2019;</italic>). (In the running time analysis presented in <xref rid="s4h" ref-type="sec">Section 4.6</xref>, we discuss a data structure to implement this scheme.) The significance of &#x0392; is as follows. For each <italic>&#x03B3;</italic> &#x2286; &#x2119; (<italic>R&#x2019;</italic>), <italic>&#x0392;</italic>[<italic>&#x03B3;</italic>] &#x003D; TRUE if the mutant whose representative set is <italic>&#x03B3;</italic> is permissible and C-realizable; otherwise, <italic>&#x0392;</italic>[<italic>&#x03B3;</italic>] &#x003D; FALSE.</p>
<p>Algorithm 3 shows how the entries of <italic>&#x0392;</italic> can be computed using DP. We can then determine whether <italic>&#x03BC;&#x2019;</italic> can be synthesized from the value of &#x0392;[<italic>R</italic>&#x2019;]. The correctness of Algorithm 3 is a direct consequence of Theorem 4.4. In <xref rid="s4h" ref-type="sec">Section 4.6</xref>, we show that the algorithm can be implemented to run in <italic>O</italic>(<italic>k</italic> 2<sup>2k</sup> &#x002B;k <italic>2<sup>k</sup></italic> (<italic>p</italic> &#x002B; <italic>s</italic>)) time, which establishes that EVPS is FPT with respect to k. In <xref rid="s4h" ref-type="sec">Section 4.6</xref>, we also explain how to modify the algorithm to produce a permissible and verifiable synthesis with a minimum number of crosses; the running time and space requirements remain the same.</p>
</sec>
<sec id="s4h"><label>4.6</label><title>Running Time Analysis and Extensions of Algorithm 3 for the EVPS Problem</title>
<p>Throughout this section, we will refer to the steps of the dynamic programming algorithm for the EVPS problem shown in Algorithm 3.</p>
<sec id="s4h1"><title>Analysis of running time and space used</title>
<p>We start with a discussion of a data structure that can be used in the implementation of the algorithm. Since &#x007C; <italic>R&#x2019;</italic>&#x007C; &#x003D; <italic>k</italic>, each subset of <italic>R&#x2019;</italic> can be represented by a <italic>k</italic>-bit vector.</p>
<p>The Boolean array <italic>&#x0392;</italic> can be implemented as a <italic>k</italic>-level <bold>binary trie</bold> [<xref ref-type="bibr" rid="c14">14</xref>] where the leaves represent the array elements. The amount of memory used by this data structure is <italic>O</italic>(2<italic><sup>k</sup></italic>). Given the <italic>k</italic>-bit vector for a particular subset <italic>&#x03B3;</italic> of <italic>R&#x2019;</italic>, the leaf node corresponding to &#x0392;[<italic>&#x03B3;</italic>] can be accessed in <italic>O</italic>(<italic>k</italic>) time by following the path from the root of the trie to the leaf node.</p>
<p>Using the trie data structure for the array <italic>B</italic>, Step 1 of the algorithm can be implemented to run in time <italic>O</italic>(<italic>k</italic><sup>2</sup>). The number of iterations of the for loop of Step 2 is at most 2<italic><sup>k</sup></italic>. In each iteration, testing whether the subset <italic>&#x03B3;</italic> is permissible (i.e whether it is in P) can be done in <italic>O</italic>(<italic>kp</italic>) time. Likewise, in each iteration, testing whether the subset <italic>&#x03B3;</italic> represents a source mutant can be done in <italic>O</italic>(<italic>ks</italic>) time. Thus, over all the 2<sup>k</sup> iterations of the loop in Step 2, these checks use <italic>O</italic>(2<italic><sup>k</sup>k</italic>(<italic>p</italic> &#x002B; <italic>s</italic>)) time.</p>
<p>Now, we estimate the time used in Step 2(d). In each iteration, Step 2(d) considers a subset <italic>&#x03B3;</italic> of <italic>R&#x2019;</italic>, with &#x007C;<italic>&#x03B3;</italic>&#x007C; &#x2264; <italic>k</italic>. For such a subset <italic>&#x03B3;</italic>, there are at most 2<italic><sup>k-1</sup></italic> partitions into two subsets. For any partition of <italic>&#x03B3;</italic> into <italic>&#x03B3;</italic><sub>1</sub> and we can determine the values of <italic>&#x0392;</italic> [<italic>&#x03B3;</italic><sub>&#x03B9;</sub>] and <italic>&#x0392;</italic> [&#x03B3;<sub>2</sub>] in <italic>O</italic>(<italic>k</italic>) time. Thus, the time for Step 2(d) in each iteration is <italic>O</italic>(2<italic><sup>k</sup></italic>-1 <italic>k</italic>). Since the number of iterations of the loop is at most 2<sup>k</sup>, the running time of Step 2(d) over all the iterations is <italic>O</italic>(2<italic><sup>k</sup></italic> 2<italic><sup>k</sup></italic>-1 <italic>k</italic>) &#x003D; <italic>O</italic>(<italic>k</italic>2<sup>2</sup><italic><sup>k</sup></italic>). Therefore, the total time for Step 2 is <italic>O</italic>(<italic>k</italic>2<sup>2</sup><italic><sup>k</sup></italic> &#x002B; <italic>k</italic> 2<italic><sup>k</sup></italic> (<italic>p</italic> &#x002B; <italic>s</italic>)). Since Step 2 is the dominant part of the algorithm, the running time of the algorithm is also <italic>O</italic>(<italic>k</italic>2<sup>2</sup><italic><sup>k</sup></italic> &#x002B; <italic>k</italic>2<italic><sup>k</sup>(p</italic> &#x002B; <italic>s</italic>)). The algorithm uses <italic>O</italic>(2<italic><sup>k</sup></italic>) space for the array &#x0392; and <italic>O</italic>(<italic>k</italic>2<italic><sup>k</sup></italic>) space for the ordered set collection <italic>P</italic>(<italic>R&#x2019;</italic>). Further, the representative set of each source and permissible mutant is at most <italic>k</italic>. So, the space for all the representative sets is <italic>O(k(p</italic> &#x002B; <italic>s</italic>)). Since p and s are both at most 2<italic><sup>k</sup></italic>, the space requirement is dominated by that of the ordered collection &#x2119; (<italic>R&#x2019;</italic>). Therefore, the space used by the algorithm is <italic>O</italic>(<italic>k</italic>2<italic><sup>k</sup></italic>).</p>
</sec>
<sec id="s4h2"><title>Extension to obtain a synthesis with a minimum number of crosses</title>
<p>We can extend the dynamic programming algorithm so that whenever there is a permissible and verifiable synthesis, it finds one that uses the smallest number of crosses. To achieve this extension we use an enhanced version of array B. In this version, each element &#x0392;[<italic>&#x03B3;</italic>] is a record with three fields which we denote by flag, min-crosses and partition. The flag field indicates whether <italic>&#x03B3;</italic> can be synthesized in a permissible and verifiable manner. When &#x0392;[<italic>&#x03B3;</italic>] .flag is T<sc>RUE,</sc> the min-crosses field stores the minimum number of cross operations needed to obtain a permissible and verifiable synthesis of <italic>&#x03B3;</italic> and the partition field stores one partition of <italic>&#x03B3;</italic> into two subsets <italic>&#x03B3;</italic><sub>1</sub> and &#x03B3; <sub>2</sub> such that &#x0392;[<italic>&#x03B3;</italic><sub>1</sub>] &#x003D; &#x0392;[<italic>&#x03B3;</italic><sc><sub>2</sub></sc> &#x003D; T<sc>RUE</sc> and the value &#x0392;[<italic>&#x03B3;</italic><sub>1</sub>].min-crosses &#x002B; &#x0392;[<italic>&#x03B3;</italic><sub>2</sub>.min-crosses is the smallest among all the partitions of <italic>&#x03B3;</italic>. Since the dynamic programming algorithm considers all partitions of any set <italic>&#x03B3;</italic>, the values of the fields of each record &#x0392;[<italic>&#x03B3;</italic>] can be suitably updated. At the end, if &#x0392;[<italic>R</italic>&#x2019;] .flag is T<sc>RUE,</sc> then the value &#x0392;[<italic>R</italic>&#x2019;] .min-crosses gives the minimum number of cross operations needed to obtain a synthesis of <italic>&#x03BC;&#x2019;</italic>. It is not difficult to see that the running time of and the space used by used by this version remain <italic>O</italic>(<italic>k</italic>2<sup>2</sup><italic><sup>k</sup></italic> &#x002B; <italic>k</italic>2<italic><sup>k</sup></italic>(<italic>p</italic> &#x002B; <italic>s</italic>)) and O(<italic>k</italic>2<italic><sup>k</sup></italic>) respectively.</p>
</sec>
<sec id="s4h3"><title>Extension to multiple mutants</title>
<p>There are two ways to extend the algorithm to synthesize multiple mutants. One way is to run the algorithm separately for each mutant. If t is the number of target mutants and k is the maximum size of the representative set of a target mutant, the running time of this approach is <italic>O</italic>(<italic>t[k</italic>2<sup>2</sup><italic>k</italic> &#x002B; <italic>k</italic>2<italic><sup>k</sup></italic>(<italic>p</italic> &#x002B; <italic>s</italic>)]) and the space used is <italic>O</italic>(<italic>k</italic>2<italic><sup>k</sup></italic>). A second approach is useful when there is significant overlap among the representative sets of the target mutants. Let <italic>R&#x2019;</italic> denote the union of all the representative sets of the t target mutants, and let &#x007C; <italic>R&#x2019;</italic>&#x007C; &#x003D; i. Then, we can run the algorithm once with the target mutant being the one whose representative set is <italic>R<sub>t</sub><sup>&#x2019;</sup></italic>. From the solution array constructed by the algorithm, we can determine theanswerfor each of the target mutants. The running time of this approach is <italic>O(&#x2113;</italic> 2<sup>2</sup><italic>&#x2113;</italic> &#x002B; <italic>&#x2113;</italic> 2<italic><sup>&#x2113;</sup></italic> (<italic>p</italic> &#x002B; <italic>s</italic>)) and the space used is O(i2<sup>i</sup>).</p>
</sec>
</sec>
</sec>
</sec>
<sec id="s5"><label>5</label><title>Experimental Results</title>
<p>As we noted in the introduction, there are no published databases that contain several mutants with three or more mutations that have been made experimentally. Therefore, we had to create novel datasets to test and evaluate our algorithms. We generate two complementary types of datasets: simulated and synthetic. Our evaluations on simulated datasets seek to replicate realistic scenarios faced by experimentalists who make new mutants from existing strains in order to validate computational predictions [<xref ref-type="bibr" rid="c7">7</xref>, <xref ref-type="bibr" rid="c1">1</xref>, <xref ref-type="bibr" rid="c15">15</xref>] (<xref rid="s5a" ref-type="sec">Section 5.1</xref>). To this end, we simulate mathematical models of the cell cycle in budding yeast in order to generate biologically interesting and meaningful target and permissible mutants. Synthetic datasets allow us to assess the variation in the performance of Algorithms 2 and 3 for the VS-FL and VPS problems as we vary the value of the corresponding fixed parameter (<xref rid="s5b" ref-type="sec">Section 5.2</xref>).</p>
<p>To generate the results for VS-FL, we used a 0-1 integer linear program (ILP) to solve the DCS instances (see <xref rid="s4e" ref-type="sec">Section 4.3</xref>). The ILP was easier to implement than the algorithm in [<xref ref-type="bibr" rid="c13">13</xref>]. We used the CPLEX software to solve the ILP. We noted that writing and reading files to interface between our software and CPLEX consumed a significant fraction of the running time. Therefore, we mention this cost separately when we report the running times of our algorithms. For the VPS problem, we implemented a recursive algorithm with caching, as an alternative to the DP. We used a computer with a 3.4GHz Intel i7 CPU and 16GB RAM running the 16.04 Ubuntu Linux operating system.</p>
<sec id="s5a"><label>5.1</label><title>Evaluation on Cell Cycle Model Simulations</title>
<sec id="s5a1"><title>Simulations to Compute Target and Permissible Mutants</title>
<p>We selected a dynamic model of the budding yeast cell cycle [<xref ref-type="bibr" rid="c15">15</xref>] since we use its predictions in an ongoing collaboration on making and characterizing novel cell cycle mutants [<xref ref-type="bibr" rid="c15">15</xref>, <xref ref-type="bibr" rid="c1">1</xref>, <xref ref-type="bibr" rid="c23">23</xref>]. This model accurately simulates the phenotypic properties of more than 250 cell cycle mutants in budding yeast that have been published in the literature. Starting from 35 single-gene mutations, we simulated this model for mutations in all combinations of up-to-six genes. For each mutant, we recorded whether the simulation predicted the phenotype as &#x201C;viable&#x201D; or &#x201C;inviable.&#x201D;</p>
<p>Given two mutants <italic>a</italic> and <italic>b</italic> with respective representative sets <italic>R<sub>a</sub></italic> and <italic>R<sub>b</sub></italic>, we defined <italic>b</italic> to be a <italic>parent</italic> of <italic>a</italic> if &#x007C; <italic>R<sub>a</sub> &#x2014; R<sub>b</sub></italic>&#x007C; &#x003D; 1, i.e., a carries one more single gene mutation than <italic>b</italic>. We say that <italic>b</italic> is an <italic>ancestor</italic> of <italic>a</italic> if &#x007C;<italic>R<sub>a</sub></italic> &#x2014; <italic>R<sub>b</sub></italic>&#x007C; &#x007C; &#x2265; 1. We further define two specific classes of mutants, namely <bold>rescued</bold> and <bold>synthetic lethal.</bold> We define a mutant <italic>a</italic> to be <italic>rescued</italic> if <italic>a</italic> is predicted to be viable but had a parent b that is either experimentally known or predicted by the model to be inviable. We note that a rescued mutant may be <italic>redundant</italic>. For example,<italic>&#x005E;>&#x039C;5&#x0394;</italic> rescues the inviable mutants <italic>bck2&#x0394;cln3&#x0394;</italic> and <italic>bck2&#x0394;cln3&#x0394;pds1&#x0394;</italic>. Since <italic>pds1&#x0394;</italic> is itself a viable strain, the loss of Pds1 is irrelevant to the rescue phenotype. So, we consider only non-redundant rescued mutants, i.e., <italic>bck2&#x0394;cln3&#x0394;whi5&#x0394;</italic> but not <italic>bck2&#x0394;cln3&#x0394;pds1&#x0394;whi5&#x0394;</italic>. We define a mutant <italic>a</italic> to be <italic>synthetic lethal</italic> (abbreviated as SL) if <italic>a</italic> is inviable and all of a&#x2019;s parents are viable.</p>
<p>Only 8&#x0025; of the 1.6M mutants we simulated were viable (<xref rid="tbl1" ref-type="table">Table 1</xref>) The percentage of viable combinations decreased with an increase in the number of genes mutated, which supports our consideration of permissible mutants in the VPS problem. There were 77,243 rescued mutants of which 2,041 (2.6&#x0025;) were non-redundant. Out of 1.48M inviable mutants, only 246 (0.016&#x0025;) were SL. We specified inputs to our algorithms as follows:</p>
<table-wrap id="tbl1" orientation="portrait" position="float"><label>Table 1:</label>
<caption><p>Statistics on simulations. We ignored combinations that contained redundant pairs of mutations, e.g., <italic>cdh</italic>1 &#x0394; and CDH1 .constitutive. We abbreviate &#x201C;number of mutations&#x201D; as &#x201C;#Ms,&#x201D; &#x201C;non-redundant&#x201D; as &#x201C;non-red,&#x201D; and synthetic lethal mutants as &#x201C;SL.&#x201D;</p></caption>
<graphic xlink:href="359281_tbl1.tif"/>
</table-wrap>
</sec>
<sec id="s5a2"><title>Target mutants</title>
<p>Two sets: all four-, five-, and six-gene (i) non-redundant rescued mutants and (ii) SL mutants.</p>
</sec>
<sec id="s5a3"><title>Source mutants</title>
<p>49 mutants available to our experimental collaborators [<xref ref-type="bibr" rid="c1">1</xref>] (Neil Adames and Jean Pec-coud, personal communication), including 35 single, 11 double, and three triple mutants (<xref rid="tbl3" ref-type="table">Table 3</xref> in Section A.1 in the Appendix).</p>
</sec>
<sec id="s5a4"><title>Permissible mutants</title>
<p>All viable mutants in our simulations.</p>
</sec>
<sec id="s5a5"><title>Results for VS-FL</title>
<p>We used Algorithm 2 for VS-FL to compute the optimal synthesis for each target mutant. The total running time for these computations was 22.37 seconds (0.011 second per mutant), with an additional 91.92 seconds (0.045 second per mutant) incurred for file input and output related to the ILPs for the DCS problem. <xref rid="fig3" ref-type="fig">Figure 3(a)</xref> summarizes these results for rescued mutants and for SL mutants. The majority of target mutants required one fewer cross than the number of mutated genes (e.g., four crosses for a five-gene target mutant). The VS-FL algorithm capitalized on double mutants in the source set to compute syntheses with three crosses for 217 five-gene rescued mutants and syntheses with two crosses for 68 four-gene rescued mutants. For 26 five-gene mutants, the algorithm could compute syntheses with just two crosses, thus taking advantage of triple gene mutants in <italic>S</italic>. We observed similar trends for SLs.</p>
<fig id="fig3" position="float" orientation="portrait" fig-type="figure"><label>Figure 3:</label>
<caption><p>Distribution of the number of crosses in optimal syntheses for rescued mutants and for SL mutants (<italic>x</italic>-axis: number of crosses, y-axis: number of mutants with an optimal synthesis of that size, legend: the number of mutations in each target mutant). (a) Results for Algorithm 2 for VS-FL. (b) Results for Algorithm 3 for VPS. <italic>x</italic>-axis label of &#x201C;No:&#x201D; mutants without a verifiable, permissible syntheses.</p></caption>
<graphic xlink:href="359281_fig3.tif"/>
</fig>
</sec>
<sec id="s5a6"><title>Results for VPS</title>
<p>We used Algorithm 3 to compute an optimal synthesis for each target mutant in the presence of permissible mutants. The total running time for these computations was 18.5 seconds (average of 0.01 second per mutant). <xref rid="fig3" ref-type="fig">Figure 3(b)</xref> shows the results. We found that 1,992 of the 2,041 (97.6&#x0025;) of the rescued mutants and all SL mutants had a verifiable, permissible synthesis. Of the 49 target mutants that did not have such a synthesis, there were 18 four-gene, 26 five-gene, and 5 six-gene mutants. <xref rid="fig4" ref-type="fig">Figure 4</xref> shows such a mutant. In the caption of the figure, we explain why this mutant does not have a verifiable, permissible synthesis.</p>
<fig id="fig4" position="float" orientation="portrait" fig-type="figure"><label>Figure 4:</label>
<caption><p>Example of a target rescued mutant for which there is no verifiable permissible synthesis. Each rectangular node is a mutant. A permissible mutant is in green (the simulations predict it to be viable). A non-permissible mutant is in red (the simulations predict it to be inviable). Further, source mutants are highlighted in blue, and the target mutant is highlighted in yellow.The label on a node lists the genes deleted in that mutant. Each blue circle represents a verifiable cross. Each such node has two incoming edges and one outgoing edge. This network contains all crosses involving the displayed mutants; it is identical to the genetic cross graph used by our ILP-based algorithm [<xref ref-type="bibr" rid="c25">25</xref>]. The node at the top of the network is the target rescued mutant. It does not have a permissible synthesis since (i) all its parents (triple mutants) are inviable and (ii) only one mutant is viable in every pair of double mutants that could be crossed in a verifiable synthesis of the target mutant. An alternative way of stating the second reason is that every pair of viable double mutants has one common gene, which means that crossing these double mutants is not a verifiable synthesis.</p></caption>
<graphic xlink:href="359281_fig4.tif"/>
</fig>
<p>For each mutant with a verifiable, permissible synthesis, we compared the syntheses computed by the VS-FL and the VPS algorithms to determine if the restrictions imposed by permissible mutants increased the number of crosses in the synthesis. The size of the synthesis did not increase for most target mutants. However, four rescued mutants did have a larger synthesis for the VPS problem than for the VS-FL problem.</p>
<p><xref ref-type="fig" rid="fig5">Figure 5(a)</xref> shows a synthesis with two crosses that is not permissible and <xref rid="fig5" ref-type="fig">Figure 5(b)</xref> shows a verifiable, permissible synthesis of the same mutant with three crosses.</p>
<fig id="fig5" position="float" orientation="portrait" fig-type="figure"><label>Figure 5:</label>
<caption><p>(a) Example of a verifiable but non-permissible synthesis with two crosses computed by Algorithm 2 for VS-FL. Node colors are as in <xref rid="fig4" ref-type="fig">Figure 4</xref>. (b) Example of a verifiable, permissible synthesis with three crosses computed by Algorithm 3 for VPS. Note that even though the triple mutant <italic>cln3Abck2Awhi5A</italic> is a source, Algorithm 3 does not use it in the synthesis since both <italic>cln3Abck2Awhi5Acdh1A</italic> and <italic>cln3Abck2Awhi5Aclb5A</italic> (not shown) are not permissible mutants (they are inviable).</p></caption>
<graphic xlink:href="359281_fig5.tif"/>
</fig>
<p>These results show that permissible mutants can affect the synthesis size, even if only for a small number of target mutants. More importantly, the requirement of permissibility can preclude the existence of a synthesis for several target mutants. Our algorithms can handle the additional restrictions imposed by permissibility.</p>
</sec>
</sec>
<sec id="s5b"><label>5.2</label><title>Evaluation on Synthetic Datasets</title>
<sec id="s5b1"><title>Generating Synthetic Data</title>
<p>Recall that Algorithm 2 for the VS-FL problem is FPT in <italic>q</italic>, the number of source mutants with three or more mutations, while Algorithm 3 for the VPS problem is FPT in <italic>k,</italic> the number of mutations in the target mutant. We created synthetic datasets that varied both parameters so that we could the same inputs to both algorithms. We created representative sets for all mutants from a universe <italic>U</italic> of 35 genes; we used this number to match the cell cycle model.</p>
</sec>
<sec id="s5b2"><title>Target mutants</title>
<p>We generated a random target mutant whose representative set contained <italic>k</italic> &#x003D; 6, 8, 10, or 12 genes from <italic>U</italic>. We used these values of <italic>k</italic> to test our algorithms on larger target mutants than we used in <xref rid="s5a" ref-type="sec">Section 5.1</xref>, where every mutant contained at most six mutations. For each of these four values, we report results averaged over 100 target mutants. Let <italic>U</italic>&#x2019; C <italic>U</italic> be the union of the representative sets of these 100 target mutants.</p>
</sec>
<sec id="s5b3"><title>Source mutants</title>
<p>We started with <italic>S</italic> containing all singleton and doubleton subsets of <italic>U</italic>&#x2019;. This choice ensured that each target mutant had a synthesis with at most <italic>k/2</italic> - 1 crosses, thereby making the results depend only on the triple mutants added. Next, we varied <italic>q</italic> from 0 to 300 in steps of 100 and added <italic>q</italic> triple mutants for S. In selecting the representative sets of these mutants, we sampled subsets of <italic>U</italic>&#x2019; uniformly at random. An experimentalist seeking to make a <italic>k</italic> -gene target mutant is likely to first make one or more triple mutants that are ancestors of the target mutant. We developed this strategy of selecting triple mutants to mimic the experimentalist. We stress that we use <italic>U</italic>&#x2019; only to select source mutants. We still apply our algorithms to each target mutant independently.</p>
</sec>
<sec id="s5b4"><title>Permissible mutants</title>
<p>For each triple mutant <italic>&#x03BC;</italic> we added to S, we considered every descendant of <italic>&#x03BC;</italic> to be permissible, as long as the representative set of that descendant was a subset of <italic>U</italic>&#x2019;.</p>
</sec>
<sec id="s5b5"><title>Results for VS-FL</title>
<p><xref rid="fig6" ref-type="fig">Figure 6(a)</xref> plots how the average number of crosses needed to make a target mutant changes with q. When <italic>q</italic> &#x003D; 0, the algorithm for VS-FL runs Algorithm 1 for VS-2, and computes syntheses that only involve double mutants. As we increase <italic>q,</italic> the average number of crosses decreases as the synthesis can now take advantage of triple gene mutants. However, as the number of triple gene mutants in the source set increases, the time taken to run the algorithm for VS-FL increases considerably, especially for targets with 12 mutations (<xref rid="fig6" ref-type="fig">Figure 6(b)</xref>), as we may expect from the exponential dependence on <italic>q</italic> of the worst-case running time of Algorithm 2. For target mutants with 12 mutations, there is a considerable variation in the running times, especially for <italic>q</italic> &#x003D; 300. Instead of plotting this error bar in <xref rid="fig6" ref-type="fig">Figure 6(b)</xref>, we display the distribution of running times in <xref rid="fig6" ref-type="fig">Figure 6(c)</xref>. While the algorithm ran in less than one second for over 75&#x0025; of the target mutants, it took around two seconds for four mutants and over three seconds for two other mutants. <xref rid="tbl2" ref-type="table">Table 2</xref> summarizes the time taken to read and write the ILPs for the DCS problem.</p>
<fig id="fig6" position="float" orientation="portrait" fig-type="figure"><label>Figure 6:</label>
<caption><p>VS-FL results for synthetic data. Error bars indicate one standard deviation. The legend in (b) shows <italic>k</italic>, the size of the representative set of the target mutant. (a) The average number of crosses in an optimal synthesis as we change <italic>q,</italic> the number of triples in <italic>S</italic>. (b) Average time in seconds as we vary <italic>q</italic>. (c) Distribution of running time for 100 target mutants, <italic>k</italic> &#x003D; 12, <italic>q</italic> &#x003D; 300.</p></caption>
<graphic xlink:href="359281_fig6.tif"/>
</fig>
<table-wrap id="tbl2" orientation="portrait" position="float"><label>Table 2:</label>
<caption><p>Average time taken for reading and writing the ILP for DCS problem for synthetic datasets.</p></caption>
<graphic xlink:href="359281_tbl2.tif"/>
</table-wrap>
</sec>
<sec id="s5b6"><title>Results for VPS</title>
<p>As we increase <italic>q,</italic> the number of triples in <italic>S,</italic> we also increase the size of the permissible set. Therefore, the number of crosses in an optimal synthesis decreases with an increase in <italic>q</italic> (<xref rid="fig7" ref-type="fig">Figure 7(a)</xref>). The average time taken by the VPS algorithm is negligible for <italic>k</italic> &#x003D; 6,8,10 (<xref rid="fig7" ref-type="fig">Figure 7(b)</xref>), in contrast with the result for VS-FL (<xref rid="fig6" ref-type="fig">Figure 6(b)</xref>). For <italic>k</italic> &#x003D; 12, the average time taken by the algorithm for VPS increases considerably compared to smaller values of <italic>k</italic> (<xref rid="fig7" ref-type="fig">Figure 7(b)</xref>), since the algorithm is FPT with respect to this parameter; we observe (but do no show here) a similar trend for <italic>k</italic> &#x003D; 14. Moreover, the running time also increases with <italic>q:</italic> the more permissible mutants there are, the longer Algorithm 3 takes to find an optimal synthesis. Nevertheless, all running times are at most 20 seconds. Comparing <xref rid="fig7" ref-type="fig">Figure 7(b)</xref> and <xref rid="fig6" ref-type="fig">Figure 6(b)</xref> for <italic>k</italic> &#x003D; 12 and <italic>q</italic> &#x003D; 300, the VPS algorithm is about 18 times slower than the VS-FL algorithm.</p>
<fig id="fig7" position="float" orientation="portrait" fig-type="figure"><label>Figure 7:</label>
<caption><p>VPS results for synthetic data, averaged over 100 target mutants. Error bars indicate one standard deviation. The x-axis corresponds to <italic>k</italic>, the size of the representative set of the target mutant. The legend in (a) shows <italic>q</italic>, the number of triples in <italic>S</italic>. (a) Average number of crosses in an optimal synthesis as we vary <italic>k</italic>. (b) Average time taken in seconds.</p></caption>
<graphic xlink:href="359281_fig7.tif"/>
</fig>
</sec>
<sec id="s5b7"><title>Comparing VPS to CrossPlan</title>
<p>Here, we compare the VPS algorithm to our ILP-based approach, which we call CrossPlan [<xref ref-type="bibr" rid="c25">25</xref>]. We run both algorithms to compute an optimal verifiable synthesis for each target mutant with <italic>k</italic> &#x003D; 12. For a specific target mutant <italic>&#x03BC;</italic>, in addition to the inputs to VPS, CrossPlan takes two additional inputs: (a) l, an upper bound on the number of crosses needed and (b) a genetic cross graph G&#x005E;). We set <italic>l &#x003D; k/2 &#x2014;</italic> 1, since <italic>S</italic> contains all double mutants. The graph (G&#x005E;) contains one <italic>mutant node</italic> for each permissible mutant whose representative set is a subset of <italic>&#x03BC;&#x2019;</italic> s set. For every pair of permissible mutants with disjoint representative sets, (G&#x005E;) contains a <italic>cross node</italic> that represents the corresponding genetic cross. In addition, (G&#x005E;) contains two incoming edges and one outgoing edge for each cross. See <xref rid="fig4" ref-type="fig">Figure 4</xref> for an example. We compute this graph independently for each target mutant. On average, a graph contains 4,095 &#x003D; 2<sup>12</sup> &#x2212; 1 mutant nodes and 66,000 cross nodes.</p>
<p>Both algorithms report optimal synthesis of the same size or that no verifiable, permissible synthesis exists. However, the VPS algorithm is over 28 times faster (24.83 minutes vs 700.77 minutes) in computing optimal syntheses. It was 10 times faster than CrossPlan (9 minutes vs. 90.08 minutes) for the question of determining if a verifiable, permissible synthesis exists. The CrossPlan ILP contained 300K variables and 600K constraints, on average. In fact, due to the size of the ILP, we set a time limit of six minutes on the Gurobi solver for each target mutant since in our experience the solver computes a heuristic solution quickly but can spend hours in proving its optimality. These results show the benefit of the strategy we have adopted in this paper of formulating synthesis problems that do not need the explicit construction of the genetic cross graph.</p>
</sec>
</sec>
</sec>
<sec id="s6"><label>6</label><title>Conclusions</title>
<p>We introduced a fundamental problem in computational biology: how to use genetic crosses to efficiently synthesize a target mutant from source mutants. We formalized this question in several ways that incorporated key experimental considerations of verifiability and permissibility. We showed that checking the existence of a synthesis is <bold>NP</bold> -complete. We presented one polynomial time and two FPT algorithms for these problems. On simulated and synthetic data, these algorithms ran efficiently and provided useful results.</p>
<p>There are several interesting directions for future research. Developing FPT algorithms that compute an optimal synthesis for multiple target mutants is an important open problem. These methods will complement the ILP-based solution we have proposed [<xref ref-type="bibr" rid="c25">25</xref>].</p>
<p>It may also be useful to study the scenario when permissible intermediate mutants are specified implicitly rather than explicitly. A simple example of an implicit specification is to allow every intermediate mutant to be permissible, which is identical to the VS problem. Another example is the following: an intermediate mutant is permissible if and only if it has no gene from the set {g<sub>1</sub>, g<sub>2</sub>, g<sub>3</sub>}; this set could correspond to genes whose products form an essential protein complex. Such a description can specify an exponentially large set of permissible intermediate mutants. However, given a target mutant <italic>&#x03BC;</italic>, we can efficiently determine whether or not it is permissible under the given specification. Our algorithm for VPS in <xref rid="s4g" ref-type="sec">Section 4.5</xref> can be readily modified to work for such implicit specifications of permissible intermediate mutants.</p>
<p>Our current model for creating new mutants includes only the genetic cross. It is important to extend this model to include other experimental techniques, especially genome editing methods, while considering the relative costs of each approach. We are also interested in studying and incorporating more complex constraints imposed by genetic crosses in model organisms.</p>
</sec>
</body>
<back>
<fn-group>
<fn id="n1"><label>1</label><p>This notation represent the deletion of the Whi5 gene.</p></fn></fn-group>
<ack><title>Acknowledgments</title>
<p>National Science Foundation grants CCF-1617678, ACI-1443054, and IIS-1633028 supported this work. We also thank the reviewers for their feedback.</p>
</ack>
<ref-list><title>References</title>
<ref id="c1"><label>1.</label><mixed-citation publication-type="other"><string-name><given-names>N. R.</given-names> <surname>Adames</surname></string-name>, <string-name><given-names>P. L.</given-names> <surname>Schuck</surname></string-name>, <string-name><given-names>K. C.</given-names> <surname>Chen</surname></string-name>, <string-name><given-names>T. M.</given-names> <surname>Murali</surname></string-name>, <string-name><given-names>J. J.</given-names> <surname>Tyson</surname></string-name>, and <string-name><given-names>J.</given-names> <surname>Peccoud</surname></string-name>. <article-title>Experimental testing of a new integrated model of the budding yeast Start transition</article-title>.</mixed-citation></ref>
<ref id="c2"><label>2.</label><mixed-citation publication-type="journal"><string-name><given-names>Joshua F</given-names> <surname>Apgar</surname></string-name>, <string-name><given-names>Jared E</given-names> <surname>Toettcher</surname></string-name>, <string-name><surname>Drew</surname> <given-names>Endy</given-names></string-name>, <string-name><given-names>Forest M</given-names> <surname>White</surname></string-name>, and <string-name><given-names>Bruce</given-names> <surname>Tidor</surname></string-name>. <article-title>Stimulus design for model selection and validation in cell signaling</article-title>. <source>PLoS Computational Biology</source>, <volume>4</volume>:<fpage>e30</fpage>, Feb <year>2008</year>.</mixed-citation></ref>
<ref id="c3"><label>3.</label><mixed-citation publication-type="journal"><string-name><surname>Nir</surname> <given-names>Atias</given-names></string-name>, <string-name><surname>Michal</surname> <given-names>Gershenzon</given-names></string-name>, <string-name><surname>Katia</surname> <given-names>Labazin</given-names></string-name>, and <string-name><surname>Roded</surname> <given-names>Sharan.</given-names></string-name> <article-title>Experimental design schemes for learning boolean network models</article-title>. <source>Bioinformatics (Oxford, England)</source>, <volume>30</volume>:<fpage>i445</fpage>&#x2013;<lpage>i452</lpage>, Sep <year>2014</year>.</mixed-citation></ref>
<ref id="c4"><label>4.</label><mixed-citation publication-type="journal"><string-name><surname>Samuel</surname> <given-names>Bandara</given-names></string-name>, <string-name><given-names>Johannes P</given-names> <surname>Schloder</surname></string-name>, <string-name><surname>Roland</surname> <given-names>Eils</given-names></string-name>, <string-name><given-names>Hans Georg</given-names> <surname>Bock</surname></string-name>, and <string-name><surname>Tobias</surname> <given-names>Meyer.</given-names></string-name> <article-title>Optimal experimental design for parameter estimation of a cell signaling model</article-title>. <source>PLoS Computational Biology</source>, <volume>5</volume>:<fpage>e1000558</fpage>, Nov <year>2009</year>.</mixed-citation></ref>
<ref id="c5"><label>5.</label><mixed-citation publication-type="journal"><string-name><given-names>Christian L</given-names> <surname>Barrett</surname></string-name> and <string-name><given-names>Bernhard O</given-names> <surname>Palsson</surname></string-name>. <article-title>Iterative reconstruction of transcriptional regulatory networks: an algorithmic approach</article-title>. <source>PLoS Computational Biology</source>, <volume>2</volume>:<fpage>e52</fpage>, May <year>2006</year>.</mixed-citation></ref>
<ref id="c6"><label>6.</label><mixed-citation publication-type="journal"><string-name><given-names>M.</given-names> <surname>Costanzo</surname></string-name>, <string-name><given-names>B.</given-names> <surname>VanderSluis</surname></string-name>, <string-name><given-names>E. N.</given-names> <surname>Koch</surname></string-name>, <string-name><given-names>A.</given-names> <surname>Baryshnikova</surname></string-name>, <string-name><given-names>C.</given-names> <surname>Pons</surname></string-name>, <string-name><given-names>G.</given-names> <surname>Tan</surname></string-name>, <string-name><given-names>W.</given-names> <surname>Wang</surname></string-name>, <string-name><given-names>M.</given-names> <surname>Usaj</surname></string-name>, <string-name><given-names>J.</given-names> <surname>Hanchard</surname></string-name>, <string-name><given-names>S. D.</given-names> <surname>Lee</surname></string-name>, <string-name><given-names>V.</given-names> <surname>Pelechano</surname></string-name>, <string-name><given-names>E. B.</given-names> <surname>Styles</surname></string-name>, <string-name><given-names>M.</given-names> <surname>Billmann</surname></string-name>, <string-name><given-names>J.</given-names> <surname>van Leeuwen</surname></string-name>, <string-name><given-names>N.</given-names> <surname>van Dyk</surname></string-name>, <string-name><given-names>Z. Y.</given-names> <surname>Lin</surname></string-name>, <string-name><given-names>E.</given-names> <surname>Kuzmin</surname></string-name>, <string-name><given-names>J.</given-names> <surname>Nelson</surname></string-name>, <string-name><given-names>J. S.</given-names> <surname>Piotrowski</surname></string-name>, <string-name><given-names>T.</given-names> <surname>Srikumar</surname></string-name>, <string-name><given-names>S.</given-names> <surname>Bahr</surname></string-name>, <string-name><given-names>Y.</given-names> <surname>Chen</surname></string-name>, <string-name><given-names>R.</given-names> <surname>Deshpande</surname></string-name>, <string-name><given-names>C. F.</given-names> <surname>Kurat</surname></string-name>, <string-name><given-names>S. C.</given-names> <surname>Li</surname></string-name>, <string-name><given-names>Z.</given-names> <surname>Li</surname></string-name>, <string-name><given-names>M. M.</given-names> <surname>Usaj</surname></string-name>, <string-name><given-names>H.</given-names> <surname>Okada</surname></string-name>, <string-name><given-names>N.</given-names> <surname>Pascoe</surname></string-name>, <string-name><given-names>B. J.</given-names> <surname>San Luis</surname></string-name>, <string-name><given-names>S.</given-names> <surname>Sharifpoor</surname></string-name>, <string-name><given-names>E.</given-names> <surname>Shuteriqi</surname></string-name>, <string-name><given-names>S. W.</given-names> <surname>Simpkins</surname></string-name>, <string-name><given-names>J.</given-names> <surname>Snider</surname></string-name>, <string-name><given-names>H. G.</given-names> <surname>Suresh</surname></string-name>, <string-name><given-names>Y.</given-names> <surname>Tan</surname></string-name>, <string-name><given-names>H.</given-names> <surname>Zhu</surname></string-name>, <string-name><given-names>N.</given-names> <surname>Malod-Dognin</surname></string-name>, <string-name><given-names>V.</given-names> <surname>Janjic</surname></string-name>, <string-name><given-names>N.</given-names> <surname>Przulj</surname></string-name>, <string-name><given-names>O. G.</given-names> <surname>Troyanskaya</surname></string-name>, <string-name><given-names>I.</given-names> <surname>Stagljar</surname></string-name>, <string-name><given-names>T.</given-names> <surname>Xia</surname></string-name>, <string-name><given-names>Y.</given-names> <surname>Ohya</surname></string-name>, <string-name><given-names>A. C.</given-names> <surname>Gingras</surname></string-name>, <string-name><given-names>B.</given-names> <surname>Raught</surname></string-name>, <string-name><given-names>M.</given-names> <surname>Boutros</surname></string-name>, <string-name><given-names>L. M.</given-names> <surname>Steinmetz</surname></string-name>, <string-name><given-names>C. L.</given-names> <surname>Moore</surname></string-name>, <string-name><given-names>A. P.</given-names> <surname>Rosebrock</surname></string-name>, <string-name><given-names>A. A.</given-names> <surname>Caudy</surname></string-name>, <string-name><given-names>C. L.</given-names> <surname>Myers</surname></string-name>, <string-name><given-names>B.</given-names> <surname>Andrews</surname></string-name>, and <string-name><given-names>C.</given-names> <surname>Boone</surname></string-name>. <article-title>A global genetic interaction network maps a wiring diagram of cellular function</article-title>. <source>Science</source>, <volume>353</volume>(<issue>6306</issue>), Sep <year>2016</year>.</mixed-citation></ref>
<ref id="c7"><label>7.</label><mixed-citation publication-type="journal"><string-name><given-names>Frederick R</given-names> <surname>Cross</surname></string-name>, <string-name><surname>Vincent</surname> <given-names>Archambault</given-names></string-name>, <string-name><surname>Mary</surname> <given-names>Miller</given-names></string-name>, and <string-name><surname>Martha</surname> <given-names>Klovstad.</given-names></string-name> <article-title>Testing a mathematical model of the yeast cell cycle</article-title>. <source>Molecular biology of the cell</source>, <volume>13</volume>(<issue>1</issue>):<fpage>52</fpage>&#x2013;<lpage>70</lpage>, <year>2002</year>.</mixed-citation></ref>
<ref id="c8"><label>8.</label><mixed-citation publication-type="journal"><string-name><given-names>D.</given-names> <surname>Deutscher</surname></string-name>, <string-name><given-names>I.</given-names> <surname>Meilijson</surname></string-name>, <string-name><given-names>S.</given-names> <surname>Schuster</surname></string-name>, and <string-name><given-names>E.</given-names> <surname>Ruppin</surname></string-name>. <article-title>Can single knockouts accurately single out gene functions?</article-title> <source>BMC Systems Biology</source>, <volume>2</volume>:<fpage>50</fpage>, Jun <year>2008</year>.</mixed-citation></ref>
<ref id="c9"><label>9.</label><mixed-citation publication-type="journal"><string-name><given-names>H. N.</given-names> <surname>Gabow</surname></string-name>. <article-title>An efficient reduction technique for degree-constrained subgraph and bidirected network flow problems</article-title>. <source>InProceedings of the 15th Annual ACM Symposium on Theory of Computing, 25-27 April, 1983, Boston, Massachusetts, USA, pages</source> <fpage>448</fpage>&#x2013;<lpage>456</lpage>, <year>1983</year>.</mixed-citation></ref>
<ref id="c10"><label>10.</label><mixed-citation publication-type="book"><string-name><given-names>M. R.</given-names> <surname>Garey</surname></string-name> and <string-name><given-names>D. S.</given-names> <surname>Johnson</surname></string-name>. <source>Computers and Intractability: A Guide to the Theory of NP-completeness</source>. <string-name><given-names>W. H.</given-names> <surname>Freeman</surname></string-name> &#x0026; <publisher-name>Co., San Francisco, CA</publisher-name>, <year>1979</year>.</mixed-citation></ref>
<ref id="c11"><label>11.</label><mixed-citation publication-type="journal"><string-name><given-names>Heather A</given-names> <surname>Harrington</surname></string-name>, <string-name><given-names>Kenneth L</given-names> <surname>Ho</surname></string-name>, <string-name><surname>Thomas</surname> <given-names>Thorne</given-names></string-name>, and <string-name><given-names>Michael P H</given-names> <surname>Stumpf.</surname></string-name> <article-title>Parameter-free model discrimination criterion based on steady-state coplanarity</article-title>. <source>Proceedings of the National Academy of Sciences of the United States of America</source>, <volume>109</volume>:<fpage>15746</fpage>-1<lpage>5751</lpage>, Sep <year>2012</year>.</mixed-citation></ref>
<ref id="c12"><label>12.</label><mixed-citation publication-type="journal"><string-name><given-names>T E</given-names> <surname>Ideker</surname></string-name>, <string-name><given-names>V</given-names> <surname>Thorsson</surname></string-name>, and <string-name><given-names>R M</given-names> <surname>Karp.</surname></string-name> <article-title>Discovery of regulatory interactions through perturbation: inference and experimental design</article-title>. <source>Pacific Symposium on Biocomputing, pages</source> <fpage>305</fpage>&#x2013;<lpage>316</lpage>, <year>2000</year>.</mixed-citation></ref>
<ref id="c13"><label>13.</label><mixed-citation publication-type="journal"><string-name><given-names>P.</given-names> <surname>Klein</surname></string-name>. <article-title>Lecture notes on combinatorial optimization</article-title>. <source>Technical Report, Dept. of Computer Science, Brown University, Providence, RI</source>, <year>1990</year>.</mixed-citation></ref>
<ref id="c14"><label>14.</label><mixed-citation publication-type="journal"><string-name><given-names>D. E.</given-names> <surname>Knuth</surname></string-name>.<article-title>The Art of Computer Programming</article-title>, Volume <volume>3</volume>: <source>Sorting and Searching. Addison Wesley, Inc., Reading, MA</source>, <year>1974</year>.</mixed-citation></ref>
<ref id="c15"><label>15.</label><mixed-citation publication-type="journal"><string-name><surname>Pavel</surname> <given-names>Kraikivski</given-names></string-name>, <string-name><given-names>Katherine C.</given-names> <surname>Chen</surname></string-name>, <string-name><surname>Teeraphan</surname> <given-names>Laomettachit</given-names></string-name>, <string-name><given-names>T. M.</given-names> <surname>Murali</surname></string-name>, and <string-name><given-names>John J.</given-names> <surname>Tyson.</surname></string-name> <article-title>From START to FINISH: Computational analysis of cell cycle control in budding yeast</article-title>. <source>NPJ Systems Biology and Applications</source>, <volume>1</volume>:<fpage>15016</fpage>,<year>2015</year>.</mixed-citation></ref>
<ref id="c16"><label>16.</label><mixed-citation publication-type="journal"><string-name><surname>Andreas</surname> <given-names>Kremling</given-names></string-name>, <string-name><surname>Sophia</surname> <given-names>Fischer</given-names></string-name>, <string-name><surname>Kapil</surname> <given-names>Gadkar</given-names></string-name>, <string-name><given-names>Francis J</given-names> <surname>Doyle</surname></string-name>, <string-name><surname>Thomas</surname> <given-names>Sauter</given-names></string-name>, <string-name><surname>Eric</surname> <given-names>Bullinger</given-names></string-name>, <string-name><surname>Frank</surname> <given-names>Allgower</given-names></string-name>, and <string-name><given-names>Ernst D</given-names> <surname>Gilles.</surname></string-name> <article-title>A benchmark for methods in reverse engineering and model discrimination: problem formulation and solutions</article-title>. <source>Genome Research</source>, <volume>14</volume>:<fpage>1773</fpage>&#x2013;<lpage>1785</lpage>, Sep <year>2004</year>.</mixed-citation></ref>
<ref id="c17"><label>17.</label><mixed-citation publication-type="journal"><string-name><surname>Clemens</surname> <given-names>Kreutz</given-names></string-name> and <string-name><surname>Jens</surname> <given-names>Timmer.</given-names></string-name> <article-title>Systems biology: experimental design</article-title>. <source>The FEBS journal</source>, <volume>276</volume>:<fpage>923</fpage>&#x2013;<lpage>942</lpage>, Feb <year>2009</year>.</mixed-citation></ref>
<ref id="c18"><label>18.</label><mixed-citation publication-type="journal"><string-name><surname>Bence</surname> <given-names>Melykuti</given-names></string-name>, <string-name><surname>Elias</surname> <given-names>August</given-names></string-name>, <string-name><surname>Antonis</surname> <given-names>Papachristodoulou</given-names></string-name>, and <string-name><surname>Hana</surname> <given-names>El-Samad.</given-names></string-name> <article-title>Discriminating between rival biochemical network models: three approaches to optimal experiment design</article-title>. <source>BMC Systems Biology</source>, <volume>4</volume>:<fpage>38</fpage>, Apr <year>2010</year>.</mixed-citation></ref>
<ref id="c19"><label>19.</label><mixed-citation publication-type="journal"><string-name><given-names>R.</given-names> <surname>Niedermeier</surname></string-name>.<article-title>Invitation to Fixed Parameter Algorithms</article-title>. <source>Oxford University Press, New York, NY</source>, <year>2006</year>.</mixed-citation></ref>
<ref id="c20"><label>20.</label><mixed-citation publication-type="journal"><string-name><given-names>David A.</given-names> <surname>Orlando</surname></string-name>, <string-name><given-names>Charles Y.</given-names> <surname>Lin</surname></string-name>, <string-name><surname>Allister</surname> <given-names>Bernard</given-names></string-name>, <string-name><given-names>Jean Y.</given-names> <surname>Wang</surname></string-name>, Joshua <string-name><given-names>E. S.</given-names> <surname>Socolar</surname></string-name>, <string-name><given-names>Edwin S.</given-names> <surname>Iversen</surname></string-name>, <string-name><given-names>Alexander J.</given-names> <surname>Hartemink</surname></string-name>, and <string-name><given-names>Steven B.</given-names> <surname>Haase.</surname></string-name> <article-title>Global control of cell-cycle transcription by coupled CDK and network oscillators</article-title>. <source>Nature</source>, <volume>453</volume>(<issue>7197</issue>):<fpage>944</fpage>&#x2013;<lpage>947</lpage>, May <year>2008</year>.</mixed-citation></ref>
<ref id="c21"><label>21.</label><mixed-citation publication-type="journal"><string-name><given-names>B.</given-names> <surname>Papp</surname></string-name>, <string-name><given-names>C.</given-names> <surname>Pal</surname></string-name>, and <string-name><given-names>L. D.</given-names> <surname>Hurst</surname></string-name>. <article-title>Metabolic network analysis of the causes and evolution of enzyme dispensability in yeast</article-title>. <source>Nature</source>, <volume>429</volume>(<issue>6992</issue>):<fpage>661</fpage>&#x2013;<lpage>664</lpage>, Jun <year>2004</year>.</mixed-citation></ref>
<ref id="c22"><label>22.</label><mixed-citation publication-type="journal"><string-name><surname>Edouard</surname> <given-names>Pauwels</given-names></string-name>, <string-name><surname>Christian</surname> <given-names>Lajaunie</given-names></string-name>, and <string-name><surname>Jean-Philippe</surname> <given-names>Vert.</given-names></string-name> <article-title>A bayesian active learning strategy for sequential experimental design in systems biology</article-title>. <source>BMC Systems Biology</source>, <volume>8</volume>:<fpage>102</fpage>, Sep <year>2014</year>.</mixed-citation></ref>
<ref id="c23"><label>23.</label><mixed-citation publication-type="journal"><string-name><given-names>C. L.</given-names> <surname>Poirel</surname></string-name>, <string-name><given-names>R. R.</given-names> <surname>Rodrigues</surname></string-name>, <string-name><given-names>K. C.</given-names> <surname>Chen</surname></string-name>, <string-name><given-names>J. J.</given-names> <surname>Tyson</surname></string-name>, and <string-name><given-names>T. M.</given-names> <surname>Murali</surname></string-name>. <article-title>Top-down network analysis to drive bottom-up modeling of physiological processes</article-title>. <source>Journal of Computational Biology</source>, <volume>20</volume>(<issue>5</issue>):<fpage>409</fpage>&#x2013;<lpage>418</lpage>, May <year>2013</year>.</mixed-citation></ref>
<ref id="c24"><label>24.</label><mixed-citation publication-type="journal"><string-name><given-names>F.</given-names> <surname>Port</surname></string-name>, <string-name><given-names>H. M.</given-names> <surname>Chen</surname></string-name>, <string-name><given-names>T.</given-names> <surname>Lee</surname></string-name>, and <string-name><given-names>S. L.</given-names> <surname>Bullock</surname></string-name>. <article-title>Optimized CRISPR/Cas tools for efficient germline and somatic genome engineering in Drosophila</article-title>. <source>Proc. Natl. Acad. Sci. U.S.A.</source>, <volume>111</volume>(<issue>29</issue>):<fpage>e2967</fpage>&#x2013;<lpage>2976</lpage>, Jul <year>2014</year>.</mixed-citation></ref>
<ref id="c25"><label>25.</label><mixed-citation publication-type="journal"><string-name><surname>Aditya</surname> <given-names>Pratapa</given-names></string-name>, <string-name><surname>Neil</surname> <given-names>Adames</given-names></string-name>, <string-name><surname>Pavel</surname> <given-names>Kraikivski</given-names></string-name>, <string-name><surname>Nicholas</surname> <given-names>Franzese</given-names></string-name>, <string-name><given-names>John J.</given-names> <surname>Tyson</surname></string-name>, <string-name><surname>Jean</surname> <given-names>Peccoud</given-names></string-name>, and <string-name><given-names>T. M.</given-names> <surname>Murali</surname></string-name>. <article-title>Crossplan: Systematic planning of genetic crosses to validate mathematical models</article-title>. <source>Bioinformatics, page In press</source>, <year>2018</year>.</mixed-citation></ref>
<ref id="c26"><label>26.</label><mixed-citation publication-type="journal"><string-name><given-names>Sahand Jamal</given-names> <surname>Rahi</surname></string-name>, <string-name><surname>Kresti</surname> <given-names>Pecani</given-names></string-name>, <string-name><surname>Andrej</surname> <given-names>Ondracka</given-names></string-name>, <string-name><surname>Catherine</surname> <given-names>Oikonomou</given-names></string-name>, and <string-name><given-names>Frederick R</given-names> <surname>Cross.</surname></string-name> <article-title>The cdk-apc/c oscillator predominantly entrains periodic cell-cycle transcription</article-title>. <source>Cell</source>, <volume>165</volume>(<issue>2</issue>):<fpage>475</fpage>&#x2013;<lpage>487</lpage>,<year>2016</year>.</mixed-citation></ref>
<ref id="c27"><label>27.</label><mixed-citation publication-type="journal"><string-name><given-names>D.</given-names> <surname>Segre</surname></string-name>, <string-name><given-names>A.</given-names> <surname>Deluna</surname></string-name>, <string-name><given-names>G. M.</given-names> <surname>Church</surname></string-name>, and <string-name><given-names>R.</given-names> <surname>Kishony</surname></string-name>. <article-title>Modular epistasis in yeast metabolism</article-title>. <source>Nature Genetics</source>, <volume>37</volume>(<issue>1</issue>):<fpage>77</fpage>&#x2013;<lpage>83</lpage>, Jan <year>2005</year>.</mixed-citation></ref>
<ref id="c28"><label>28.</label><mixed-citation publication-type="journal"><string-name><given-names>Steven Nathaniel</given-names> <surname>Steinway</surname></string-name>, <string-name><surname>Jorge Gomez</surname> <given-names>Tejeda Zanudo</given-names></string-name>, <string-name><given-names>Paul J</given-names> <surname>Michel</surname></string-name>, <string-name><given-names>David J</given-names> <surname>Feith</surname></string-name>, <string-name><given-names>Thomas P</given-names> <surname>Loughran</surname></string-name>, and <string-name><surname>Reka</surname> <given-names>Albert.</given-names></string-name> <article-title>Combinatorial interventions inhibit tgf [beta]-driven epithelial-to-mesenchymal transition and support hybrid cellular phenotypes</article-title>. <source>NPJ Systems Biology and Applications</source>, <volume>1</volume>:<fpage>15014</fpage>, <year>2015</year>.</mixed-citation></ref>
<ref id="c29"><label>29.</label><mixed-citation publication-type="journal"><string-name><surname>Ewa</surname> <given-names>Szczurek</given-names></string-name>, <string-name><surname>Irit</surname> <given-names>Gat-Viks</given-names></string-name>, <string-name><surname>Jerzy</surname> <given-names>Tiuryn</given-names></string-name>, and <string-name><surname>Martin</surname> <given-names>Vingron.</given-names></string-name> <article-title>Elucidating regulatory mechanisms downstream of a signaling pathway using informative experiments</article-title>. <source>Molecular Systems Biology</source>, <volume>5</volume>:<fpage>287</fpage>, <year>2009</year>.</mixed-citation></ref>
<ref id="c30"><label>30.</label><mixed-citation publication-type="journal"><string-name><surname>Chen</surname> <given-names>H.</given-names></string-name> <string-name><surname>Yeang</surname>, <given-names>H.</given-names></string-name> <string-name><surname>Craig</surname> <given-names>Mak</given-names></string-name>, <string-name><surname>Scott</surname> <given-names>McCuine</given-names></string-name>, <string-name><surname>Christopher</surname> <given-names>Workman</given-names></string-name>, <string-name><surname>Tommi</surname> <given-names>Jaakkola</given-names></string-name>, and <string-name><surname>Trey</surname> <given-names>Ideker.</given-names></string-name> <article-title>Validation and refinement of gene-regulatory pathways on a network of physical interactions</article-title>. <source>Genome Biology</source>, <volume>6</volume>(<issue>7</issue>):<fpage>R62</fpage>&#x002B;, <year>2005</year>.</mixed-citation></ref>
<ref id="c31"><label>31.</label><mixed-citation publication-type="journal"><string-name><given-names>B.</given-names> <surname>Zetsche</surname></string-name>, <string-name><given-names>M.</given-names> <surname>Heidenreich</surname></string-name>, <string-name><given-names>P.</given-names> <surname>Mohanraju</surname></string-name>, <string-name><given-names>I.</given-names> <surname>Fedorova</surname></string-name>, <string-name><given-names>J.</given-names> <surname>Kneppers</surname></string-name>, <string-name><given-names>E. M.</given-names> <surname>DeGennaro</surname></string-name>, <string-name><given-names>N.</given-names> <surname>Winblad</surname></string-name>, <string-name><given-names>S. R.</given-names> <surname>Choudhury</surname></string-name>, <string-name><given-names>O. O.</given-names> <surname>Abudayyeh</surname></string-name>, <string-name><given-names>J. S.</given-names> <surname>Gootenberg</surname></string-name>, <string-name><given-names>W. Y.</given-names> <surname>Wu</surname></string-name>, <string-name><given-names>D. A.</given-names> <surname>Scott</surname></string-name>, <string-name><given-names>K.</given-names> <surname>Severinov</surname></string-name>, <string-name><given-names>J.</given-names> <surname>van der Oost</surname></string-name>, and <string-name><given-names>F.</given-names> <surname>Zhang</surname></string-name>. <article-title>Multiplex gene editing by CRISPR-Cpf1 using a single crRNA array</article-title>. <source>Nat. Biotechnol.</source>, <volume>35</volume>(<issue>1</issue>):<fpage>31</fpage>&#x2013;<lpage>34</lpage>, Jan <year>2017</year>.</mixed-citation></ref>
</ref-list>
<sec id="s7"><title>A Appendix</title>
<sec id="s7a"><title>A.1 List of Source Mutants</title>
<p><xref rid="tbl3" ref-type="table">Table 3</xref> shows the 49 source mutants we use in the evaluation using simulations of the cell cycle model (<xref rid="s5a" ref-type="sec">Section 5.1</xref>).</p>
<table-wrap id="tbl3" orientation="portrait" position="float"><label>Table 3:</label>
<caption><p>The 49 source mutants used in <xref rid="s5a" ref-type="sec">Sec. 5.1</xref>. CDH1 .constitutive is a mutant that expresses CDH1 constitutively. CLB1 <italic>clblA</italic> refers to a strain with <italic>clb2</italic> deletion with wildtype CLB1 (CLB1 and CLB2 are paralogs that are redundant in function). <italic>apc<sup>ts</sup></italic> refers to a non-functional Anaphase-promoting Complex, which is achieved by using a temperature sensitive strain. TAB6-1 refers to <italic>telophase arrest bypass</italic> mutants representing altered Cdc14:Net1 stoichiometries at mitotic exit.</p></caption>
<graphic xlink:href="359281_tbl3.tif"/>
</table-wrap>
</sec>
</sec>
</back>
</article>