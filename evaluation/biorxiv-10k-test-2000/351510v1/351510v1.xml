<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.2d1 20170631//EN" "JATS-archivearticle1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" article-type="article" dtd-version="1.2d1" specific-use="production" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">BIORXIV</journal-id>
<journal-title-group>
<journal-title>bioRxiv</journal-title>
<abbrev-journal-title abbrev-type="publisher">bioRxiv</abbrev-journal-title>
</journal-title-group>
<publisher>
<publisher-name>Cold Spring Harbor Laboratory</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1101/351510</article-id>
<article-version>1.1</article-version>
<article-categories>
<subj-group subj-group-type="author-type">
<subject>Regular Article</subject>
</subj-group>
<subj-group subj-group-type="heading">
<subject>New Results</subject>
</subj-group>
<subj-group subj-group-type="hwp-journal-coll">
<subject>Biophysics</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>OpenPathSampling: A Python framework for path sampling simulations. II. Building and customizing path ensembles and sample schemes</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<name><surname>Swenson</surname><given-names>David W.H.</given-names></name>
<xref ref-type="aff" rid="a1">1</xref>
<xref ref-type="aff" rid="a2">2</xref>
<xref ref-type="author-notes" rid="n1">&#x002A;</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Prinz</surname><given-names>Jan-Hendrik</given-names></name>
<xref ref-type="aff" rid="a2">2</xref>
<xref ref-type="aff" rid="a3">3</xref>
<xref ref-type="author-notes" rid="n2">&#x2020;</xref>
</contrib>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">http://orcid.org/0000-0003-4898-9420</contrib-id>
<name><surname>Noe</surname><given-names>Frank</given-names></name>
<xref ref-type="aff" rid="a3">3</xref>
<xref ref-type="author-notes" rid="n2">&#x2021;</xref>
</contrib>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">http://orcid.org/0000-0003-0542-119X</contrib-id>
<name><surname>Chodera</surname><given-names>John D.</given-names></name>
<xref ref-type="aff" rid="a2">2</xref>
<xref ref-type="author-notes" rid="n2">&#x00A7;</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Bolhuis</surname><given-names>Peter G.</given-names></name>
<xref ref-type="aff" rid="a1">1</xref>
<xref ref-type="author-notes" rid="n2">&#x00B6;</xref>
</contrib>
<aff id="a1"><label>1</label><institution>van&#x2019;t Hoff Institute for Molecular Sciences, University of Amsterdam</institution>, PO Box 94157, 1090 GD Amsterdam, <country>The Netherlands</country></aff>
<aff id="a2"><label>2</label><institution>Computational and Systems Biology Program, Sloan Kettering Institute, Memorial Sloan Kettering Cancer Center</institution>, New York, NY 10065, <country>USA</country></aff>
<aff id="a3"><label>3</label><institution>Department of Mathematics and Computer Science, Arnimallee 6, Freie Universit&#x00E4;t Berlin</institution>, 14195 Berlin, <country>Germany</country></aff>
</contrib-group>
<author-notes>
<fn id="n1" fn-type="equal"><label>&#x002A;</label><p>Equal contributor; <email>dwhs@hyperblazer.net</email></p></fn>
<fn id="n2" fn-type="equal"><label>&#x2020;</label><p>Equal contributor; <email>jan.prinz@choderalab.org</email></p></fn>
<fn id="n3" fn-type="other"><label>&#x2021;</label><p><email>frank.noe@fu-berlin.de</email></p></fn>
<fn id="n4" fn-type="other"><label>&#x00A7;</label><p><email>john.chodera@choderalab.org</email></p></fn>
<fn id="n5" fn-type="other"><label>&#x00B6;</label><p><email>p.g.bolhuis@uva.nl</email></p></fn>
</author-notes>
<pub-date pub-type="epub"><year>2018</year></pub-date>
<elocation-id>351510</elocation-id>
<history>
<date date-type="received">
<day>20</day>
<month>6</month>
<year>2018</year>
</date>
<date date-type="rev-recd">
<day>20</day>
<month>6</month>
<year>2018</year>
</date>
<date date-type="accepted">
<day>20</day>
<month>6</month>
<year>2018</year>
</date>
</history>
<permissions>
<copyright-statement>&#x00A9; 2018, Posted by Cold Spring Harbor Laboratory</copyright-statement>
<copyright-year>2018</copyright-year>
<license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by/4.0/"><license-p>This pre-print is available under a Creative Commons License (Attribution 4.0 International), CC BY 4.0, as described at <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link></license-p></license>
</permissions>
<self-uri xlink:href="351510.pdf" content-type="pdf" xlink:role="full-text"/>
<abstract>
<p>The OpenPathSampling (OPS) package provides an easy-to-use framework to apply transition path sampling methodologies to complex molecular systems with a minimum of effort. Yet, the extensibility of OPS allows for the exploration of new path sampling algorithms by building on a variety of basic operations. In a companion paper [<xref ref-type="bibr" rid="c24">Swenson et al 2018</xref>] we introduced the basic concepts and the structure of the OPS package, and how it can be employed to perform standard transition path sampling and (replica exchange) transition interface sampling. In this paper, we elaborate on two theoretical developments that went into the design of OPS. The first development relates to the construction of path ensembles, the <italic>what</italic> is being sampled. We introduce a novel set-based notation forthepath ensemble, which provides an alternative paradigm for constructing path ensembles, and allows building arbitrarily complex path ensembles from fundamental ones. The second fundamental development is the structure for the customisation of Monte Carlo procedures; <italic>how</italic> path ensembles are being sampled. We describe in detail the OPS objects that implement this approach to customization, the MoveScheme and the PathMover, and provide tools to create and manipulate these objects. We illustrate both the path ensemble building and sampling scheme customization with several examples. OPS thus facilitates both standard path sampling application in complex systems as well as the development of new path sampling methodology, beyond the default.</p>
</abstract>
<kwd-group kwd-group-type="author">
<title>Keywords</title>
<kwd>transition path sampling</kwd>
<kwd>transition interface sampling</kwd>
<kwd>molecular dynamics simulation</kwd>
<kwd>rare events</kwd>
</kwd-group>
<counts>
<page-count count="22"/>
</counts>
</article-meta>
</front>
<body>
<sec id="s1">
<label>I.</label>
<title>INTRODUCTION</title>
<p>Many dynamical processes, including nucleated phase transitions, chemical reactions, and complex conformational changes in biomolecular systems, such as proteins and nucleic acids, occuron longtimescales [<xref ref-type="bibr" rid="c1">1</xref>&#x2013;<xref ref-type="bibr" rid="c4">4</xref>], primarily due to large kinetic barriers between metastable states [<xref ref-type="bibr" rid="c5">5</xref>&#x2013;<xref ref-type="bibr" rid="c7">7</xref>]. Straightforward molecular dynamics simulations are then highly inefficient due to the long waiting times within metastable basins, while the rare events of interest occur over a short time [<xref ref-type="bibr" rid="c8">8</xref>]. Methods such as umbrella sampling [<xref ref-type="bibr" rid="c9">9</xref>], blue moon sampling [<xref ref-type="bibr" rid="c10">10</xref>], local elevation sampling [<xref ref-type="bibr" rid="c11">11</xref>], conformational flooding [<xref ref-type="bibr" rid="c12">12</xref>], hyperdynamics [<xref ref-type="bibr" rid="c13">13</xref>], metadynamics [<xref ref-type="bibr" rid="c14">14</xref>], adaptive biasing force methods [<xref ref-type="bibr" rid="c15">15</xref>], replica exchange [<xref ref-type="bibr" rid="c16">16</xref>], simulated tempering [<xref ref-type="bibr" rid="c17">17</xref>], integrated sampling [<xref ref-type="bibr" rid="c18">18</xref>], orthogonal space sampling [<xref ref-type="bibr" rid="c19">19</xref>], and numerous others enhance the occurrence of the rare event by bi-asingthe potential energy surface orthe density of sampled conformations. To be effective, bias potentials require (a set of) collective variables that approximate the reaction coordinate. However, a poor choice will lead to poor sampling of reactive pathways and hence poor estimates of the dynamical bottlenecks and the related barrier heights and rates.</p>
<p>The transition pathsampling(TPS) methodology [<xref ref-type="bibr" rid="c20">20</xref>&#x2013;<xref ref-type="bibr" rid="c23">23</xref>]) can enhance the sampling of complex dynamical transitions in complex (bio)molecular systems, avoiding the exponentially long timescales that the system spends in metastable states, and, most importantly, bypassing the need fora reaction coordinate. Notwithstanding the efficiency of path sampling, the complexity of implementation and lack of standard tools have hampered widespread application.</p>
<p>The OpenPathSampling (OPS) framework aims at providing a toolbox to make complex transition path sampling simulation easy accessible for users. In Paper I, we introduced the basic concepts and structure of the OPS framework, discussed its ingredients and gave a tutorial on how to conduct some standard simulations using the OPS framework [<xref ref-type="bibr" rid="c24">24</xref>]. The current work builds heavily on this companion paperand we referthe readerto Ref. [<xref ref-type="bibr" rid="c24">24</xref>] forfull details. The OPS framework facilitates implementation of the three stages in any path sampling study: initialization, sampling, and analysis. In the initialization step the user defines the (network of) transitions that needs to be sampled. This requires definition of stable states and path and/or interface ensembles to be used in (replica exchange) transition interface sampling (TIS) schemes. These definitions are based on phase space volumes defined as a function of a priori chosen collective variables. Since path sampling is basically a Monte Carlo (MC) approach, the user also has to decide on the specific details of how each type of move is implemented, which OPS facilitates with the <monospace>MoveStrategy</monospace> objects, and the user has to create the overall (and sometimes complex) decision treeforthe MC procedure, which OPS implements in a <monospace>MoveScheme</monospace>. The transition network and the <monospace>MoveScheme</monospace>, together with the Molecular Dynamics Engine, a Storage file, and a initial path sample set, enterare used by the <monospace>PathSimulator</monospace>, which performs the sampling. Analysis of the sampled paths is subsequently performed using information obtained from the Storage object. OPS provides tools for the initialization step and for the analysis. For more details we referto Paper I [<xref ref-type="bibr" rid="c24">24</xref>] and to the online documentation at <monospace><ext-link ext-link-type="uri" xlink:href="http://openpathsampling.org">http://openpathsampling.org</ext-link></monospace>.</p>
<p>This paper is mainly aimed at method developers and researchers interested in devising their own path sampling methods using the OPS framework. This requires an extensive treatment of the more fundamental ideas that went into the design of OPS. The paperfocuses on two of those fundamental aspects. One is the construction of path ensembles, which can be viewed as <italic>what</italic> is being sampled. The other is the customisation of the Monte Carlo procedures, which relates to <italic>how</italic> the path ensembles are being sampled. This paper provides novel conceptional frameworks for dealing with these two aspects.</p>
<p>In the first part, we focus on the path ensembles. While the definition of path ensembles in the original TPS and TIS papers is perfectly usable for many applications, these definitions can be come quite cumbersome when multiple states or multiple collective variables come in to play. This also holds for the more complex path moves, such as the <italic>minus interface move</italic> [<xref ref-type="bibr" rid="c25">25</xref>, <xref ref-type="bibr" rid="c26">26</xref>] used in replica exchange TIS (RETIS), which exchanges a trajectory in the first interface ensemble with a trajectory exploring the stable state (the minus interface ensemble) in order to decorrelate the (usually short) pathways in the first interface, and to provide a direct estimate for the flux out of the stable state [<xref ref-type="bibr" rid="c25">25</xref>&#x2013;<xref ref-type="bibr" rid="c27">27</xref>]. Here, we present a framework allowing one to build arbitrarily complex path ensembles from fundamental path ensembles. To facilitate this, we first introduce a novel set-based notation for the path ensembles. For completeness, we also provide connections to the original TPS and TIS notation. This novel notation provides an alternative paradigm for constructing path ensembles with several major advantages: (1) It allows one to easily create complex ensembles as combinations of simplerensembles, e.g., usingset logic. (2) It creates a systematic connection betweentheensemble indicatorfunction and the stopping criteria used when generating a trajectory for the ensemble, e.g., with a shooting move. Previously, the stopping criteria were identified separately for every ensemble/path generating move. (3) It facilitates analysis, as many analysis procedures can be framed as searching for subtrajectories that satisfy some ensemble indicator function. Examples of this are provided in <xref ref-type="sec" rid="s4">Sec. IV</xref>. Of particular importance herein is the sequential path ensemble, which is directly related to the way that OPS implements path sampling and testing. We explain in detail how different ensembles are being built in terms of these sequential path ensembles. We end the first part with a set of general guidelines and simple rules on how arbitrary path ensembles could be built in OPS.</p>
<p>In the second part of the paper, we describe the framework that creates the Monte Carlo process used by OPS. This framework is designed to be extremely flexible, which enables one to customize the Monte Carlo move scheme and to build non-standard path sampling schemes with little effort. This ability to customize the move scheme is one of the major advantages of the OPS framework. It allows experiences users to design a sampling method tailored to a specific system. Here the two central concepts are (1) the move scheme, which encodes the entire Monte Carlo procedure as a decision tree, and (2) the path movers, which perform the moves. We describe both concepts in detail, as well as the tools in OPS that facilitate customization of the move scheme.</p>
<p>The paper is organized as follows. In <xref ref-type="sec" rid="s2a">Sec. II A</xref> we briefly review the original standard notation for TPS path ensembles. Subsequently, we introduce the novel path ensemble set notation, including the sequential ensemble. We then describe in <xref ref-type="sec" rid="s2e">Sec. II E</xref> how OPS implements these ensembles, and give some guidelines and rules on how new ensembles could be built. In <xref ref-type="sec" rid="s3">Sec. III</xref> we discuss customizing the Monte Carlo moves in detail. We give illustrations of these concepts in <xref ref-type="sec" rid="s4">Sec. IV</xref>, where we discuss the application of generating and splitting trajectories, as well as customizing the move schemes for alternative replica exchange simulations. Finally, we end with conclusions and an outlook.</p>
</sec>
<sec id="s2">
<label>II.</label>
<title>BUILDING BLOCKS FOR PATH ENSEMBLES AND VOLUMES</title>
<sec id="s2a">
<label>A.</label>
<title>Standard TPS and TIS notation</title>
<p>In this section, we briefly recapitulate the standard notation for the path ensemble and distribution functions used in TPS and TIS before introducing the novel set based notation that is more commensurate with the way OPS implements path sampling. This section is not meant as an introduction to path sampling, but rather to describe the connection between the novel set-based notation and the standard notation found in the literature. For a review of path sampling methodology we refer the reader to Refs. [<xref ref-type="bibr" rid="c20">20</xref>&#x2013;<xref ref-type="bibr" rid="c23">23</xref>, <xref ref-type="bibr" rid="c28">28</xref>]. In the next sections we follow the notation that was introduced in Refs. [<xref ref-type="bibr" rid="c26">26</xref>] and [<xref ref-type="bibr" rid="c28">28</xref>].</p>
<sec id="s2a1">
<label>1.</label>
<title>The TPS path ensemble</title>
<p>A path is a discretized, time-ordered sequence of states in phase space x &#x2261; &#x007B;<italic>x</italic><sub>0</sub>, <italic>x</italic><sub>1</sub>; <italic>x</italic><sub>2</sub>,&#x2026;, <italic>x</italic><sub>L</sub>&#x007D;, in which consecutive states, or frames, are separated by a small time increment &#x0394;<italic>&#x03C4;</italic>. Each frame <italic>x</italic> &#x003D; &#x007B;<italic>r, p</italic>&#x007D; consists of the positions and momenta of all particles in the entire system. The path-length <italic>L</italic> can be chosen fixed or variable, depending on the type of path ensemble. The path probability for a trajectory of duration <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline1.gif"/></alternatives></inline-formula> is
<disp-formula id="eqn1">
<alternatives><graphic xlink:href="351510_eqn1.gif"/></alternatives>
</disp-formula>
where <italic>p</italic>(<italic>x</italic><sub><italic>i</italic></sub> &#x2192; <italic>x</italic><sub><italic>i</italic>&#x002B;1</sub>) denotes the Markovian transition probability to go from <italic>x</italic><sub><italic>i</italic></sub> to <italic>x</italic><sub><italic>i</italic>&#x002B;1</sub> in one time step, which depends on the underlying dynamics [<xref ref-type="bibr" rid="c22">22</xref>]. Further, <italic>&#x03C1;</italic>(<italic>x</italic><sub>0</sub>) is the distribution of initial conditions, in many cases the equilibrium distribution. TPS constrains pathways between two stable states A and B. Such states are defined using an collective variable or order parameter <italic>&#x03BB;</italic>, for example <fn id="fn1"><label><sup>1</sup></label><p>Note that the term &#x2018;order parameter&#x2019; and &#x2018;collective variable&#x2019; are used interchangeably in this work. As explained in Paper 1 [<xref ref-type="bibr" rid="c24">24</xref>], the term collective variable refers to any function of the system&#x2019;s coordinates.</p></fn>
<disp-formula id="eqn2">
<alternatives><graphic xlink:href="351510_eqn2.gif"/></alternatives>
</disp-formula>
and likewise for B. Here, <italic>&#x03BB;</italic>(<italic>x</italic>) returns the order parameter &#x03BB; forframe <italic>x</italic>, and <italic>&#x03BB;</italic><sub><italic>A</italic></sub> defines the boundary of state A.</p>
<p>The standard TPS path ensemble distribution with a fixed length <italic>L</italic> constrains the path to begin in <italic>A</italic>, and end in <italic>B</italic>
<disp-formula id="eqn3">
<alternatives><graphic xlink:href="351510_eqn3.gif"/></alternatives>
</disp-formula>
where 1<sub><italic>A</italic></sub>(<italic>x</italic><sub>0</sub>) and 1<sub><italic>B</italic></sub>(<italic>x</italic><sub><italic>L</italic></sub>) are indicator functions that are, respectively, unity if the trajectory starts with <italic>x</italic><sub>0</sub> &#x2208; <italic>A</italic> and ends with <italic>x</italic><sub><italic>L</italic></sub> &#x2208; <italic>B</italic> and zero otherwise. The formal definition of 1<sub><italic>A</italic></sub>(<italic>x</italic><sub>0</sub>) is
<disp-formula id="eqn4">
<alternatives><graphic xlink:href="351510_eqn4.gif"/></alternatives>
</disp-formula>
and 1<sub><italic>B</italic></sub>(<italic>x</italic><sub><italic>L</italic></sub>) is defined likewise. The normalization factor <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline2.gif"/></alternatives></inline-formula> is akin to a partition function, where the integral over <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline3.gif"/></alternatives></inline-formula> takes into account paths of length L starting at all possible initial conditions <italic>x</italic><sub>0</sub>.</p>
<p>For variable path length TPS a similar path ensemble distribution can be written
<disp-formula id="eqn5">
<alternatives><graphic xlink:href="351510_eqn5.gif"/></alternatives>
</disp-formula>
where the indicator function <italic>h</italic>[x] nowselects the paths that immediately leave <italic>A</italic>, and just enter <italic>B</italic>
<disp-formula id="eqn6">
<alternatives><graphic xlink:href="351510_eqn6.gif"/></alternatives>
</disp-formula></p>
<p>Note that this path ensemble indicator function already shows some complexity. The normalization factor is now <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline4.gif"/></alternatives></inline-formula> where the integral over <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline5.gif"/></alternatives></inline-formula> takes now into account paths of all length starting at all possible initial conditions <italic>x</italic><sub>0</sub>.</p>
</sec>
<sec id="s2a2">
<label>2.</label>
<title>The TIS path ensemble</title>
<p>Transition Interface sampling (TIS) defines a series of successive non-intersecting interfaces <italic>&#x03BB;</italic><sub>0</sub>, <italic>&#x03BB;</italic><sub>1</sub>,&#x2026;, <italic>&#x03BB;</italic><sub><italic>n</italic></sub>, based on an order parameter <italic>&#x03BB;</italic>, and samples the TIS path ensemble for each interface. Paths in the interface ensemble <italic>i</italic> start in A (at <italic>&#x03BB;</italic><sub>0</sub>), cross the interface <italic>&#x03BB;</italic><sub><italic>i</italic></sub> at least once, and finally either return to A, or end in B. Defining adjacent phase space regions separated by interface <italic>&#x03BB;</italic><sub><italic>i</italic></sub> as <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline6.gif"/></alternatives></inline-formula>,the path probability for an interface ensemble <italic>i</italic> is given by
<disp-formula id="eqn7">
<alternatives><graphic xlink:href="351510_eqn7.gif"/></alternatives>
</disp-formula>
where the subscripts <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline7.gif"/></alternatives></inline-formula> denote the phase phase regions connected by the paths, and the TIS indicator function
<disp-formula id="eqn8">
<alternatives><graphic xlink:href="351510_eqn8.gif"/></alternatives>
</disp-formula>
where the first and second line ensures that only the initial and end pointsare in Aand B, respectively, whereasthethird line requires that the path cross the interface. The normalization factor <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline8.gif"/></alternatives></inline-formula> is defined by
<disp-formula id="eqn9">
<alternatives><graphic xlink:href="351510_eqn9.gif"/></alternatives>
</disp-formula>
where the path integral runs again overall possible paths of all lengths. The ensembles for the reverse reaction <italic>B</italic> &#x2192; <italic>A</italic> are defined in an analogous fashion [<xref ref-type="bibr" rid="c26">26</xref>, <xref ref-type="bibr" rid="c28">28</xref>].</p>
<p>The path ensemble indicator functions become rather complex even for the basic TPS and TIS ensembles. Moreover, the indicatorfunction as described above are not directly implementable in a path sampling code such as OPS, as they only apply to entire paths. During a shooting move, which is at the heart of TPS and TIS, OPS has to monitor a newly generated path and apply a stopping criterion. Such a criterion requires a notation that is better suited to the way that OPS implements both the monitorfunction and the path ensembles themselves.</p>
</sec>
</sec>
<sec id="s2b">
<label>B.</label>
<title>Volumes as sets</title>
<p>As the novel notation is based on set logic, it is only natural to also treat the stable states as sets. In OPS, stable states, and in fact any region in phase space, are described as &#x201C;volumes&#x201D;. Additionally, TIS interfaces are treated as volumes. This has several advantages, among which is the fact that it is then easy to combine volumes using set logic.</p>
<p>Volumes are defined by collective variable functions. As mentioned above, a state consists of the (infinite) set of all configurations that obey the state definition. For instance, using one order parameter <italic>&#x03BB;</italic>(<italic>x</italic>) state A can be defined as
<disp-formula id="eqn10">
<alternatives><graphic xlink:href="351510_eqn10.gif"/></alternatives>
</disp-formula></p>
<p>More general definitions are possible, e.g. by using an arbitrary number of order parameters. TIS interface volumes for an interface <italic>i</italic> connected to state <italic>A</italic> can be defined as
<disp-formula id="eqn11">
<alternatives><graphic xlink:href="351510_eqn11.gif"/></alternatives>
</disp-formula>
which is the part of phase space complementary to <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline9.gif"/></alternatives></inline-formula> defined in the previous section. Crossing an interface now amounts to leaving <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline10.gif"/></alternatives></inline-formula>, putting it conceptually on thesame level as leaving A or entering B.</p>
<p>Volumes (e.g., states) can be combined usingset logic. For two states A and B
<disp-formula id="eqn12">
<alternatives><graphic xlink:href="351510_eqn12.gif"/></alternatives>
</disp-formula>
denotes the union of sets, while
<disp-formula id="eqn13">
<alternatives><graphic xlink:href="351510_eqn13.gif"/></alternatives>
</disp-formula>
denotes the intersection. In this way volumes obeying an arbitrary number of conditions can be constructed.</p>
<p>In OPS this set logic is implemented by several functions. We can take unions and intersections of volumes, and negations of volumes using the objects <monospace>UnionVolume</monospace>, <monospace>InteractionVolume</monospace> and <monospace>NegatedVolume</monospace>. From these operations any logical operation can be constructed. Take as an example the <monospace>SymmetricDifference</monospace>, which fortwo volumes A and B would amount to all points that are either in A or in but not in both. This is logically equivalent to
<disp-formula id="eqn14">
<alternatives><graphic xlink:href="351510_eqn14.gif"/></alternatives>
</disp-formula>
where the overbar denotes the complement or negation of the volume. Other logical operations can be constructed at will.</p>
</sec>
<sec id="s2c">
<label>C.</label>
<title>Path ensembles as sets</title>
<sec id="s2c1">
<label>1.</label>
<title>Unifying two basic tasks in OPS</title>
<p>As discussed in <xref ref-type="sec" rid="s2a">Sec. II A</xref>, path ensembles are the set of all trajectories that satisfy the ensemble indicator function <italic>h</italic><sub><italic>E</italic></sub> [x] of the ensemble <italic>E</italic>, weighted by the natural path probability <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline11.gif"/></alternatives></inline-formula>. In OPS, the ensemble indicatorfunction is part of the Ensemble object. Paths are sampled with the correct relative weights by using Monte Carlo moves that preserve the distribution. Trajectories with non-zero weight form a set of paths that satisfy the constraints imposed by the ensemble indicatorfunction. Indeed, these constraints define the ensemble indicatorfunction. Forinstance, a TPS ensemble requires the constraints that the first snapshot be in the initial state, that the last snapshot be in the final state, and that no other frames of the trajectory visit a stable state. An important task in OPS is to test whether a trajectory fits a certain ensemble. The Ensemble object takes a trajectory as input and returns whetheror not it belongs to that ensemble. Take, forinstance, the simple ensemble for which all frames should be in a certain state <italic>A</italic>. The predefined ensemble class <monospace>AllInXEnsemble(state)</monospace> tests exactly that, returning True only if all frames are in the given state. One of the most productive ways to define useful path ensembles in OPS is the <monospace>SequentialEnsemble</monospace> object. <monospace>SequentialEnsemble</monospace> comprise a list of path ensembles that the trajectory needs to fulfill in the correct order. This is crucial when performing path sampling, identifying whether a path fulfills the right conditions for a move, e.g. an exchange move. Moreover, they can be useful foranalysis of pathways.</p>
<p>When performing path sampling, and in particularduring a shooting move, another important task in OPS is to monitor whether a trajectory is finished, i.e., fulfils the conditions forstopping. Atfirstsight, one mightthinkthatsuch a test is simply applying the same <monospace>Ensemble</monospace> object as above. However, this is not the case, since there are obviously many paths that do not obey the desired path ensemble, but still are clearly to be rejected. For instance a path that leaves <italic>A</italic> and returns to <italic>A</italic>, without having visited <italic>B</italic>, is clearly to be rejected. Hence, a halting criterion is needed, or rather, a continuing criterion that tells OPS to keep integrating the molecular dynamics trajectory, until it is clear that the trajectory can no longer ever satisfy the path ensemble. The can_append method provides the test for whether the path can be extended or not. Moreover, the can_append method is the building blockfrom which the <monospace>SequentialEnsemble</monospace> is constructed.</p>
<p>In the following sections, we present a general set-based approach, which connects the ensemble to its halting criteria, and which allows one to build arbitrarily complex ensembles from simple building blocks. As we build up to more complicated ensembles, we will, at each stage, first describe the set-based approach, introducing a new notation for describing path ensembles. Then we will show how that new notation maps directly onto objects in OPS.</p>
</sec>
<sec id="s2c2">
<label>2.</label>
<title>The basic building blocks</title>
<p>As above we denote a (sub)trajectory as a discretized time-ordered sequence of phase space points x &#x2261; &#x007B;<italic>x</italic><sub><italic>b</italic></sub>, <italic>x</italic><sub><italic>b</italic>&#x002B;1</sub>&#x002C;,&#x2026;, <italic>x</italic><sub><italic>e</italic></sub>&#x007D; where <italic>b</italic> and <italic>e</italic> denote the beginning and end of the (sub)trajectory, respectively. For <italic>e</italic> &#x003C; <italic>b</italic> we define the trajectory of zero length x &#x003D; &#x007B;&#x007D;. Note that a time-reversed path also has positive time-order &#x007B;<italic>y</italic><sub>0</sub>, <italic>y</italic><sub>1</sub>;&#x2026;, <italic>y</italic><sub><italic>L</italic></sub>&#x007D;, and can be constructed from the trajectory &#x007B;<italic>x</italic><sub>0</sub>, <italic>x</italic><sub>1</sub>&#x002C;,&#x2026;, <italic>x</italic><sub><italic>L</italic></sub>&#x007D; by setting <italic>y</italic><sub><italic>i</italic></sub> &#x003D; <italic>x</italic><sub><italic>L</italic>&#x2212;<italic>i</italic></sub>.</p>
<p>A path ensemble is an (infinite) set of trajectories obeying a certain criterion, encoded by indicator functions. A basic example is the ensemble of trajectories for which all frames are within volume A. In OPS, indicator functions determine whether a trajectory belongs a particular ensemble. For instance, the (formal) function In<sub><italic>A</italic></sub>(x) returns unity only when the entire trajectory belongs to volume <italic>A</italic>,
<disp-formula id="eqn15">
<alternatives><graphic xlink:href="351510_eqn15.gif"/></alternatives>
</disp-formula>
and zero otherwise. Likewise the indicatorfortheset of trajectories entirely outside of <italic>A</italic> requires an indicatorfunction Out<sub><italic>A</italic></sub>(x) that determines that no element belongs to <italic>A</italic>
<disp-formula id="eqn16">
<alternatives><graphic xlink:href="351510_eqn16.gif"/></alternatives>
</disp-formula></p>
<p>As can be seen directly from these definitions,
<disp-formula id="eqn17">
<alternatives><graphic xlink:href="351510_eqn17.gif"/></alternatives>
</disp-formula></p>
<p>Just as volumes can can be seen as sets allowing set-based logic, path ensembles can becombined orintersected using set logic. An ensemble can be combined, e.g. using a union (indicated by &#x222A;) or an intersection (indicated by &#x2229;). A union of ensembles means that the trajectory has to belong any one of the ensembles; an intersection means that the trajectory has to belong to all ensembles. Combination ol these logical operations are likewise defined.</p>
<p>Suppose that we are interested in the ensemble Out<sub><italic>S</italic></sub>. with <italic>S</italic> &#x003D; <italic>A</italic> &#x222A; <italic>B</italic> the union of states <italic>A</italic> and <italic>B</italic>. The ensemble logic gives
<disp-formula id="eqn18">
<alternatives><graphic xlink:href="351510_eqn18.gif"/></alternatives>
</disp-formula></p>
<p>Note that here, the notation In<sub><italic>A</italic></sub> and Out<sub><italic>A</italic></sub> refers to the ensemble, i.e., the entire set of trajectories, whereas when we talk about the associated indicator function we use In<sub><italic>A</italic></sub>(x) and Out<sub><italic>A</italic></sub>(x).</p>
<p>To construct all possible logical statements, we need the complement or (negation) of ensembles. We can take complements of ensembles, e.g.,
<disp-formula id="eqn19">
<alternatives><graphic xlink:href="351510_eqn19.gif"/></alternatives>
</disp-formula>
where the overbar indicates the complement of the set. The <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline12.gif"/></alternatives></inline-formula> refers to the complement of the union of the se of trajectories entirely inside <italic>A</italic> and the set of trajectories en tirely inside <italic>B</italic>. Indeed, a trajectory that is not entirely inside <italic>A</italic> or entirely inside <italic>B</italic>, has to be partly outside <italic>A</italic> and parth outside <italic>B</italic>.</p>
<p>The complement of the Out<sub><italic>A</italic></sub> ensemble is the PartIn<sub><italic>A</italic></sub> en semble, defined by the indicatorfunction:
<disp-formula id="eqn20">
<alternatives><graphic xlink:href="351510_eqn20.gif"/></alternatives>
</disp-formula></p>
<p>Likewise, the complement of the In<sub><italic>A</italic></sub> ensemble, called PartOut<sub><italic>A</italic></sub>, is defined by the indicator function where part of the trajectory is outside <italic>A</italic>.
<disp-formula id="eqn21">
<alternatives><graphic xlink:href="351510_eqn21.gif"/></alternatives>
</disp-formula></p>
<p>From these definitions it is clearthat
<disp-formula id="eqn22">
<alternatives><graphic xlink:href="351510_eqn22.gif"/></alternatives>
</disp-formula>
<disp-formula id="eqn23">
<alternatives><graphic xlink:href="351510_eqn23.gif"/></alternatives>
</disp-formula></p>
<p>In addition, analogously to <xref ref-type="disp-formula" rid="eqn17">Eq. (17)</xref>, we have
<disp-formula id="eqn24">
<alternatives><graphic xlink:href="351510_eqn24.gif"/></alternatives>
</disp-formula></p>
<p>One might expect that In<sub><italic>S</italic></sub> would obey logic analogous to Out<sub>S</sub>. However, it turns out
<disp-formula id="eqn25">
<alternatives><graphic xlink:href="351510_eqn25.gif"/></alternatives>
</disp-formula>
because this would state that either all frames are in <italic>A</italic> or all frames are in <italic>B</italic>. Instead, it is possible that some frames are in <italic>A</italic> and some frames are in <italic>B</italic>, but no frames are outside of <italic>S</italic>. Thus the connection is
<disp-formula id="eqn26">
<alternatives><graphic xlink:href="351510_eqn26.gif"/></alternatives>
</disp-formula></p>
<p>In OPS the four basic functions In<sub><italic>X</italic></sub>, Out<sub><italic>X</italic></sub>, PartIn<sub><italic>x</italic></sub>, PartOut<sub><italic>X</italic></sub> (illustrated in <xref rid="fig1" ref-type="fig">Fig. 1</xref>) have their own predefined objects <monospace>AllInXEnsemble</monospace>, <monospace>AllOutXEnsemble</monospace>, <monospace>PartInXEnsemble</monospace>, <monospace>PartOutXEnsemble</monospace>, which act as building blocks from which ensembles can be constructed. Indeed, as the names suggest, these ensembles only return True if, respectively all frames are in X, all frames are out of X, at least one frame is in X, at least one frame is out of X (see <xref ref-type="table" rid="tbl1">Table I</xref>).</p>
<fig id="fig1" position="float" orientation="portrait" fig-type="figure">
<label>FIG. 1.</label>
<caption><p><bold>&#x201C;Building block&#x201D; ensembles in OPS</bold>, with example trajectories. Sequences of logical combinations of these ensembles are used to create path ensembles used in OPS. Note that several example trajectories could satisfy the PartIn<sub><italic>X</italic></sub> and PartOut<sub><italic>X</italic></sub> ensembles. Either of the trajectories shown for one would satisfy the other. In addition, the trajectory for the In<sub><italic>X</italic></sub> would also satisfy PartIn<sub><italic>X</italic></sub>, and the trajectory for Out<sub><italic>X</italic></sub> would also satisfy PartOut<sub><italic>X</italic></sub>.</p></caption>
<graphic xlink:href="351510_fig1.tif"/>
</fig>
<table-wrap id="tbl1" orientation="portrait" position="float">
<label>TABLE I.</label>
<caption>
<title>Basic building block ensembles.</title>
<p>For each ensemble, the table gives themathematical notation used in <xref ref-type="sec" rid="s2">Sec. II</xref>, the associated OPS class name, a description of the constraint it represents, and the logical complement ensemble.</p></caption>
<graphic xlink:href="351510_tbl1.tif"/>
</table-wrap>
<p>While <monospace>PartInXEnsemble</monospace> and <monospace>PartOutXEnsemble</monospace> at first sight seem to be identical ensembles, they are in fact different since <monospace>PartInXEnsemble</monospace> also yields True for a trajectory that is all in X, whereas <monospace>PartOutXEnsemble</monospace> does not. Also, contrary to what one might naively think, the complement of <monospace>AllInXEnsemble</monospace> is not the <monospace>AllOutXEnsemble</monospace>. As discussed above, the complement of the In<sub>X</sub> implementation <monospace>AllInXEnsemble</monospace> is the PartOut<sub>X</sub> implementation <monospace>PartOutXEnsemble</monospace>. Indeed, <monospace>PartOutXEnsemble</monospace> gives True always if one frame is out of X., and only returns False if all frames are in X, the very definition of <monospace>AllInXEnsemble</monospace>. In <xref ref-type="table" rid="tbl1">Table I</xref> the complements of the basic building blockensem-bles are given.</p>
</sec>
<sec id="s2c3">
<label>3.</label>
<title>The length ensemble</title>
<p>The length ensemble consists of all paths of a specific length <italic>n</italic>. Formally, it can be defined by the indicator function
<disp-formula id="eqn27">
<alternatives><graphic xlink:href="351510_eqn27.gif"/></alternatives>
</disp-formula>
where the <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline13.gif"/></alternatives></inline-formula> symbol can take any positive integer number <italic>n</italic> &#x003E; 0. An additional definition is needed forthe zero length <italic>n</italic> &#x003D; 0 ensemble
<disp-formula id="eqn28">
<alternatives><graphic xlink:href="351510_eqn28.gif"/></alternatives>
</disp-formula>
which is the case for <italic>e</italic> &#x003C; <italic>b</italic>. The indicator function <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline14.gif"/></alternatives></inline-formula> thus returns unity only if the trajectory consists of <italic>n</italic> frames. To test whether a trajectory is entirely in state <italic>A</italic> with a length <italic>n</italic> &#x003D; 7 thus becomes
<disp-formula id="eqn29">
<alternatives><graphic xlink:href="351510_eqn29.gif"/></alternatives>
</disp-formula></p>
<p>OPS implements this ensemble with the <monospace>LengthEnsemble(n)</monospace> which, as one might expect, requires the (sub) trajectory to be of a specified length <italic>n</italic>.</p>
</sec>
</sec>
<sec id="s2d">
<label>D.</label>
<title>The can-append criterion</title>
<p>In practice, path sampling uses methods like the shooting move to generate new trajectories by running dynamics. The shooting move must have some criterion to determine when to stop the trajectories it generates. In early versions of path sampling, this was based only on trajectory length, but more advanced variants gain efficiency by stopping the simulation based on information from the coordinates/momenta of snapshots in the trajectory; forexample, stopping upon entering a stable state. As such, each path ensemble must be associated with a halting criterion.</p>
<p>In the formalism presented here, the halting condition (or more correctly, the not-yet-halt condition) is called the can-append criterion. The can-append criterion is associated with and determined by a specific ensemble <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline15.gif"/></alternatives></inline-formula> and denoted <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline16.gif"/></alternatives></inline-formula>. It takes a trajectory x as input and answers the question, &#x201C;Is the trajectory x a subtrajectory of any trajectory <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline17.gif"/></alternatives></inline-formula>&#x201D; More formally, it is defined as an indicator function on the set of all trajectories for which an additional slice in the forward time direction would not fail the specified criterion for ensemble <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline18.gif"/></alternatives></inline-formula>. For each ensemble object in OPS, there is a method called can_append that returns True for trajectories that satisfy the can-append criterion, and False fortrajectoriesthatdo not. Forthe negative time direction, there is an analogous criterion <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline19.gif"/></alternatives></inline-formula> and a can_prepend method, which tests the addition of an extra frame at the beginning of the trajectory. The discussion that follows refers to the forward-time can_append method, but also applies to the backward-time can_prepend.</p>
<p>The indicator function for these ensembles act on a (sub)trajectory x. Perhaps the simplest example is the can-append criterion fora length ensemble:
<disp-formula id="eqn30">
<alternatives><graphic xlink:href="351510_eqn30.gif"/></alternatives>
</disp-formula></p>
<p>As long as the length of the trajectory is less that <italic>n</italic>, the can-append criterion is satisfied, and <monospace>LengthEnsemble.can_append</monospace> returns True.</p>
<p>Another example is the In<sub><italic>A</italic></sub> ensemble. The indicator function for <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline20.gif"/></alternatives></inline-formula> is given by
<disp-formula id="eqn31">
<alternatives><graphic xlink:href="351510_eqn31.gif"/></alternatives>
</disp-formula>
because adding an additional frame that is not in <italic>A</italic> will immediately fail the ensemble. The additional logical or with the zero-length trajectory signifies that for an empty trajectory CanApp should return True, as adding a frame to an empty trajectory is always possible. An analogous formula can be written for <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline21.gif"/></alternatives></inline-formula>.</p>
<p>In contrast, for the ensembles <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline22.gif"/></alternatives></inline-formula> and <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline23.gif"/></alternatives></inline-formula>, the indicator functions always return True since there is no reason to stop if the additional frame is not in (or out) the state. If a frame of the trajectory is already outside the volume, there is still no reason to stop the trajectory: all extensions will then lead to trajectories that still satisfy the ensemble.</p>
<p>More complex can-append criteria can be constructed using set logic involving intersections and unions [<xref ref-type="bibr" rid="c29">29</xref>], or using sequential ensembles, as described below. One important, but somewhat subtle, point is that the logical negation of the result of can_append for an ensemble <italic>E</italic> is not necessarily equal to the result of can_append forthe complement of ensemble <italic>E</italic>. For example, the can_append method for <monospace>AllInXEnsemble</monospace> returns True if and only if all frames of the input trajectory are in the volume associated with the ensemble. However, as discussed above, the complement of an <monospace>AllInXEnsemble</monospace> is a <monospace>PartOutXEnsemble</monospace>, for which the can_append method always returns True. Taking the complement applies to the ensemble; determining the result of the can_append for the complement depends on the complement ensemble, not on the result of can_append in the original ensemble.</p>
<p>OPS also implements two other related methods for each ensemble: <monospace>strict_can_append</monospace> and <monospace>strict_can_prepend</monospace>. Whereas the normal can_append (respectively can_prepend) returns True for <italic>any</italic> subtrajectory of a trajectory in the ensemble, the <monospace>strict</monospace> variant only returns True is the input trajectory is the beginning (respectively end) of a trajectory in the ensemble. This is useful when looking for a trajectory that satisfies the ensemble, such as when identifying a subtrajectories of a long trajectory that satisfy the ensemble. For the basic ensembles above, there is no distinction between these (in fact, there is also no distinction between can_append and can_prepend, since any trajectory that satisfies one must satisfy the other). However, for sequential ensembles, described in <xref ref-type="sec" rid="s2e">Sec. II E</xref>, there are significant differences, both for can_append vs can_prepend and for their <monospace>strict</monospace> and normal variants.</p>
<p>We stress that the basic formalism introduced here, connecting each path ensemble to a can-append criterion, is general and applicable beyond the ensembles implemented by OPS. For example, one could imagine an ensemble of all trajectories with an even number of frames, for which the corresponding can_append method would always returns True. OPS does not try to implement all possible ensembles; while the ensemble of all even-length trajectories could be implemented, it it not part of OPS due to its limited practical scientific use.</p>
<p>Note that the can-append criterion, as used by the shooting move (and similartrajectory generation approaches), results in what are called <italic>candidate trajectories</italic>. A candidate trajectory comes from the first trajectory that fails the can-append criterion. For some can-append criteria, such of that of the In<sub><italic>X</italic></sub> ensemble, the can-append test &#x2018;overshoots&#x2019;, and only fails after the input trajectory could not possibly be in the desired ensemble. For others, such as that of the <monospace>LengthEnsemble</monospace>, can-append failure can be predicted before overshooting. To maximize efficiency, OPS trims the overshot frame to make candidate trajectories for ensembles where necessary, while not overshooting if not necessary.</p>
</sec>
<sec id="s2e">
<label>E.</label>
<title>The sequential ensemble</title>
<sec id="s2e1">
<label>1.</label>
<title>Definition of the sequential ensemble</title>
<p>One of the most productive ways to define useful ensembles in OPS is the <monospace>SequentialEnsemble</monospace>, which comprises a list of path ensembles that the trajectory must fulfill in the correct order. To understand this, consider a simple situation with a single state. Suppose we are interested in a path ensemble defined by a trajectory that begins in the state, then exits the state, then again returns to the state X. This ensemble can be summarized by the sequence [In<sub><italic>X</italic></sub>, Out<sub><italic>X</italic></sub>, In<sub><italic>X</italic></sub>]. Trajectories in this sequential ensemble can be split into subtrajectories that fulfill these three subensembles in the correct order.</p>
<p>Conceptually, a sequential ensemble consists of an ordered list of subensembles and an assignment algorithm to assign frames of a candidate trajectory to those subensembles. A trajectory satisfies the sequential ensemble if the assignment algorithm decomposes the trajectory into subtrajectories that satisfy each subensemble in the correct order. The can-append criterion forthe sequential ensemble can be defined based on the can-append criterion of the subensembles (and the assignment algorithm). While no unique choice for assignment algorithm exists, here we describe the approach used in OpenPathSampling.</p>
<p>A sequential ensemble is defined as an ordered set of (e.g., three) ensembles <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline24.gif"/></alternatives></inline-formula> for which the in-dicatorfunction is
<disp-formula id="eqn32">
<alternatives><graphic xlink:href="351510_eqn32.gif"/></alternatives>
</disp-formula>
with frame indices <italic>e</italic><sub>1</sub> and <italic>e</italic><sub>2</sub> given by the assignment algorithm. Forthe assignment algorithm used in OPS, they are, respectively,
<disp-formula id="eqn33">
<alternatives><graphic xlink:href="351510_eqn33.gif"/></alternatives>
</disp-formula>
and
<disp-formula id="eqn34">
<alternatives><graphic xlink:href="351510_eqn34.gif"/></alternatives>
</disp-formula>
where the first equation <xref ref-type="disp-formula" rid="eqn33">Eq. 33</xref> selects the maximum index <italic>e</italic><sub>1</sub> which still could fulfill the <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline25.gif"/></alternatives></inline-formula> condition, and the second <xref ref-type="disp-formula" rid="eqn34">Eq. 34</xref> likewise for <italic>e</italic><sub>2</sub>. Note that here we make use of the fact that CanAppend returns True for an empty zero length trajectory to ensure that the index <italic>e</italic><sub><italic>i</italic></sub> always has a value. Naturally, the number of ensembles in the sequential ensemble can be arbitrary large:
<disp-formula id="eqn35">
<alternatives><graphic xlink:href="351510_eqn35.gif"/></alternatives>
</disp-formula>
with <italic>b</italic><sub><italic>i</italic></sub> &#x003D; <italic>e</italic><sub><italic>i</italic>&#x2212;1</sub> &#x002B; 1, <italic>e</italic><sub>0</sub> &#x003D; &#x2212;1, and
<disp-formula id="eqn36">
<alternatives><graphic xlink:href="351510_eqn36.gif"/></alternatives>
</disp-formula></p>
<p>Note that if the first condition in <xref ref-type="disp-formula" rid="eqn32">Eq. 32</xref> or <xref ref-type="disp-formula" rid="eqn35">Eq. 35</xref> fails, all next conditions are not computed. The sequential ensemble thus is the set of trajectories that sequentially fulfill a set of ensembles.</p>
<p>The can-append criterion for the sequential ensemble is to use the frame assignment algorithm (the can-append of the subensembles) to assign all frames of the input trajectory to a subsequence of the subensembles. If all frames can be assigned to a subensemble, and if either (1) the subtra-iectory assigned to the last subensemble satisfies the can-append criterion for that subensemble, or (2) there are more subensembles later in the sequence, then the sequential ensemble&#x2019;s can-append criterion is satisfied.</p>
<p>As an example of a sequential ensemble, considerthe situation with just two states <italic>A</italic> and <italic>B</italic> defined, and its union <italic>S</italic> &#x003D; <italic>A</italic> &#x222A; <italic>B</italic>. The TPS ensemble connecting <italic>A</italic> and <italic>B</italic> can then be written as the sequential ensemble
<disp-formula id="eqn37">
<alternatives><graphic xlink:href="351510_eqn37.gif"/></alternatives>
</disp-formula></p>
<p>The indicatorfunction forthis ensemble SeqEnsTPS(x) returns True only if the first frame is in <italic>A</italic>, the last frame is in <italic>B</italic>, and no snapshot is in <italic>A</italic> nor <italic>B</italic> during the rest of the trajectory. Note that this function is identical to the <italic>h</italic>[x] in <xref ref-type="disp-formula" rid="eqn5">Eq. 5</xref>. A very similar expression is used forthe fixed length TPS:
<disp-formula id="eqn38">
<alternatives><graphic xlink:href="351510_eqn38.gif"/></alternatives>
</disp-formula>
where the criterion is that the first and last slice are in A, and B, respectively, and the <italic>L</italic> &#x2212; 1 slices are allowed to go anywhere.</p>
<p>The sequential ensemble forthe TIS ensemble is defined as
<disp-formula id="eqn39">
<alternatives><graphic xlink:href="351510_eqn39.gif"/></alternatives>
</disp-formula></p>
<p>The corresponding indicator function SeqEnsTIS(x) returns 1 only if the first slice is in <italic>A</italic>, the last one ends in <italic>A</italic> or <italic>B</italic>, and no slice not in <italic>A</italic> nor <italic>B</italic> during the rest of the trajectory, but there is at least one slice that is not in the interface <italic>i</italic> volume. Note that this indicator function is identical to <italic>h</italic>&#x0303;<sub><italic>i</italic></sub>[x] in <xref ref-type="disp-formula" rid="eqn7">Eq. 7</xref>.</p>
<p>As a final example, the minus interface ensemble [<xref ref-type="bibr" rid="c25">25</xref>, <xref ref-type="bibr" rid="c31">31</xref>] is
<disp-formula id="eqn40">
<alternatives><graphic xlink:href="351510_eqn40.gif"/></alternatives>
</disp-formula></p>
<p>The indicator function for this ensemble SeqEnsMin<sub><italic>A</italic></sub>(x) returns unity if the first and last slice is in <italic>A</italic> and the trajectory leaves <italic>A</italic> at least once. Note that this definition allows multiple (<italic>n</italic>) entries into <italic>A</italic>. Here, we assumed that the boundary of A and the first interface are identical. Below, we discuss the OPS implementation of the minus ensemble for the more general case.</p>
</sec>
<sec id="s2e2">
<label>2.</label>
<title>Use of Sequential Ensembles for Path Sampling in OPS</title>
<p>The sequential ensemble is implemented in OPS by the <monospace>SequentialEnsemble</monospace> object. The test for whether a given trajectory satisfies the <monospace>SequentialEnsemble</monospace> uses the <monospace>strict_can_append</monospace> method of the underlying subensembles. It starts by making a candidate subtrajectory for the first subensemble, using that subensemble&#x2019;s <monospace>strict_can_append</monospace> method until it returns <monospace>False</monospace>. The &#x201C;<monospace>strict</monospace>&#x201D; version is used because the subtrajectory that is assigned to the subensemble must satisfy the subensemble. Ifthe resulting subtrajectory satisfies the first subensemble, then the process in continued with the next subensemble. This continues until no more frames can be assigned, either because all have been assigned or because there are no more subensembles. If all frames are assigned and all subensembles have been assigned a subtrajectory, then the given trajectory is in the <monospace>SequentialEnsemble</monospace>.</p>
<p>For most TPS/TIS purposes, one would like to stop integrating trajectories as soon as they enter the state. This is done by combining a volume ensemble, such as <monospace>AlllnXEnsemble(state)</monospace>, with a <monospace>LengthEnsemble(l)</monospace>, requiring an ensemble of length 1. This results in exactly one frame in the desired state. Hence, the <monospace>SeqEnsTPS</monospace> ensemble, <xref ref-type="disp-formula" rid="eqn37">Eq. 37</xref>, for which the initial and the final trajectory frame are in the initial and final states, respectively, but all other frames (at least one) are outside both states, is given by
<fig id="ufig1" position="float" orientation="portrait" fig-type="figure">
<graphic xlink:href="351510_ufig1.tif"/>
</fig>
where we have made use of the set logic of the ensembles (see <xref ref-type="disp-formula" rid="eqn29">Eq. 29</xref>). The path should start with one frame in the initial state, then an arbitrary number outside either state, followed by precisely one frame inside the final state.</p>
<p>The slightly more complex sequential TIS ensemble SeqEnsTIS, <xref ref-type="disp-formula" rid="eqn39">Eq. 39</xref>, can be defined as
<fig id="ufig2" position="float" orientation="portrait" fig-type="figure">
<graphic xlink:href="351510_ufig2.tif"/>
</fig>
where <italic>A</italic>, <italic>B</italic>, and <italic>I</italic> are the volume-based definitions of state <italic>A</italic>, <italic>B</italic> and interface <italic>I</italic> respectively. Note thatwe have used set logic to define the union of <italic>A</italic> and <italic>B</italic> as a final state. Moreover, we require the middle part of the path to be outside of this union. Finally, the TIS ensemble requires at least a part of the entire trajectory to be outside the interface volume.</p>
<p><xref rid="fig2" ref-type="fig">Fig. 2</xref> provides an example, based on the TIS ensemble, of how frame assignment works fora sequential ensemble. Forsimplicity we leftoutthe interface crossing requirement. Two trajectories are shown, both of which fulfill the ensemble conditions. Each trajectory starts in <italic>A</italic>, which assigns the first frame in the (blue) <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline26.gif"/></alternatives></inline-formula> subensemble. Then there are a number of frames which are outside of the union of <italic>A</italic> and <italic>B</italic>, and which are assigned to the (black) Out<sub><italic>A</italic>&#x222A;<italic>B</italic></sub> subensemble. The first frame that does not satisfy that criterion is also the last frame of each trajectory. Forthe top trajectory, the last frame is in <italic>B</italic>. Forthe bottom trajectory, the last from is in <italic>A</italic>. In both cases, the last frame satisfies the subensemble In<sub><italic>A</italic>&#x222A;<italic>B</italic></sub>.</p>
<fig id="fig2" position="float" orientation="portrait" fig-type="figure">
<label>FIG. 2.</label>
<caption>
<title>Frame assignment in an ensemble based on the TIS ensemble, for two trajectories.</title>
<p>The points, which indicate individual frames in the trajectories, are colored to match the subensembles of the sequential ensemble, as given below the illustration. This ensemble differs from a real TIS ensemble because there is no interface.</p></caption>
<graphic xlink:href="351510_fig2.tif"/>
</fig>
<p>In some cases, there is a need for an &#x201C;optional&#x201D; step in the sequence, which uses the so-called OptionalEnsemble. This means that a subtrajectory of a path can be in that ensemble, but does not have to be. In OPS this is implemented by forming the union of the ensemble <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline27.gif"/></alternatives></inline-formula> with a zero-length ensemble:
<disp-formula id="eqn41">
<alternatives><graphic xlink:href="351510_eqn41.gif"/></alternatives>
</disp-formula></p>
<p>If no sub-trajectory fits the <monospace>OptionalEnsemble</monospace> a zero-length trajectory still allows the Sequential Ensemble to continue, thus effectively skipping the <monospace>OptionalEnsemble</monospace>.</p>
<fig id="ufig3" position="float" orientation="portrait" fig-type="figure">
<graphic xlink:href="351510_ufig3.tif"/>
</fig>
<p>One example where we need to use the <monospace>OptionalEnsemble</monospace> class is when there is an interstitial space between the edge of the state and the innermost interface [<xref ref-type="bibr" rid="c30">30</xref>]. In simple cases, the innermost TIS interface <italic>&#x03BB;</italic><sub>1</sub> is usually set to be exactly the boundary of the state <italic>&#x03BB;</italic><sub>0</sub>, but this is not required. A trajectory therefore can leave a state, visit the interstitial space and then cross the first interface, or it can skip this interstitial space in one frame and go directly from the state to the cross the interface. Both situations should be dealt with. The above TIS ensemble definition as already given works in this case. However, the minus interface ensemble needs special care. This ensemble is one of the more complicated ensembles in the TIS framework. As explained in Paper I [<xref ref-type="bibr" rid="c24">24</xref>], the minus interface ensemble is used (as part of the minus move) in RETIS to perform dynamics within the stable state, and return a new trajectory to one of the innermost TIS ensembles. This can be used to calculate the flux, to connect different interface sets in MISTIS, or to enhance decorrelation of trajectories [<xref ref-type="bibr" rid="c25">25</xref>,<xref ref-type="bibr" rid="c31">31</xref>]. The code forthe minus ensemble in <xref ref-type="disp-formula" rid="eqn40">Eq. 40</xref> with <italic>n</italic> &#x003D; 1 entries into <italic>A</italic> is given in Listing 1. Note the use of the <monospace>OptionalEnsemble</monospace> for the interstitial regions. This listing will also be discussed in more detail in following subsections.</p>
</sec>
<sec id="s2e3">
<label>3.</label>
<title>The reverse check and can-prepend for sequential ensembles</title>
<p>Up to this point, we have focused on sequential ensembles where the volumes associated with successive ensembles cannot overlap. That is, there can be no ambiguity as to which sub-ensemble a given frame of a trajectory is assigned to, regardless of the assignment algorithm used for the sequential ensemble. However, it is possible to define sequential ensembles where such overlaps are allowed, but these will become much more complicated and more subtle. In particular, special attention need to be paid to whether one can sample the same ensemble using the can_append and can_prepend methods.</p>
<p>OPS implements two main assignment rules. The normal OPS assignment algorithm is based on dynamics propagating forward in time (using <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline28.gif"/></alternatives></inline-formula>) and, for clarity, can be called &#x201C;forward assignment.&#x201D; In the code, the forward assignment can be tested using <monospace>ensemble(trajectory)</monospace>. The alternative approach is based on dynamics propagating backward in time (using <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline29.gif"/></alternatives></inline-formula>), and will be called &#x201C;reverse assignment&#x201D;. The code to use it in OPS is <monospace>ensemble.check_ reverse(trajectory)</monospace>.</p>
<p>The reverse assignment algorithm is used to simplify the <monospace>can_prepend</monospace> <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline30.gif"/></alternatives></inline-formula> approach as implemented in OPS. The <monospace>can_prepend</monospace> algorithm for the OPS <monospace>SequentialEnsemble</monospace> is implemented analogously to the can_append algorithm. Both are &#x201C;greedy&#x201D; algorithms, in the sense that they try to assign the largest subtrajectory possible to the current subensemble. Since the forward assignment is greedy starting with the first subensemble of the sequential ensemble, and the reverse assignment is greedy starting with the last subensemble, the two algorithms might not yield equivalent results. Any ensemble that will be sampled with both forward and backward dynamics (as is done in the standard shooting moves in path sampling) must result in identical ensembles for both the forward assignment and the reverse assignment. Note that there are many cases in which the reverse assignment will not matter. For instance, generating initial trajectories (illustrated in <xref ref-type="sec" rid="s4a">Sec. IVA</xref>) or analyzing existing trajectories (see <xref ref-type="sec" rid="s4b">Sec. IV B</xref>) only require forward assignment. Moreover, many rare events methods (e.g. forward flux sampling [&#x003F;]) involve propagating forward in time only.</p>
<p>Since the forward and reverse assignment algorithms are not equivalent, certain sequential ensembles could accept a trajectory when checked with the forward propagation, but not when checked with backward propagation (or vice-versa). For example, imagine volumes <italic>A</italic>, <italic>I</italic><sub>1</sub>, <italic>I</italic><sub>2</sub> as illustrated in <xref rid="fig3" ref-type="fig">Fig. 3</xref>, where <italic>I</italic><sub>1</sub> &#x2282; <italic>I</italic><sub>2</sub>, and <italic>A</italic> &#x2229; <italic>I</italic><sub>2</sub> &#x003D; &#x2205;. Consider the ensemble <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline31.gif"/></alternatives></inline-formula>. As shown in the top panel of <xref rid="fig3" ref-type="fig">Fig. 3</xref>, forthe illustrated trajectory, the forward assignment starts by assigning the first frame to the first ensemble ln<sub><italic>A</italic></sub> (shaded blue in the figure). Then the frame assignment algorithm will look for a subtrajectory that satisfies the <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline32.gif"/></alternatives></inline-formula> ensemble. In the example trajectory shown, it finds a two-frame subtrajectory that satisfies the <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline33.gif"/></alternatives></inline-formula> ensemble. The next frame is the first one that can be assigned to the <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline34.gif"/></alternatives></inline-formula> ensemble. Since frames that are in the volume <italic>I</italic><sub>1</sub> are also in the volume <italic>I</italic><sub>2</sub>, the trajectory continues to assign frames to <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline35.gif"/></alternatives></inline-formula> until it exits that volume and enters <italic>A</italic>. The last frame, in <italic>A</italic>, is assigned to the final <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline36.gif"/></alternatives></inline-formula> ensemble, shaded purple in the figure. Frames have been assigned to all ensembles, in the correct order, and no frames are unassigned. Therefore, this trajectory satisfies the ensemble.</p>
<fig id="fig3" position="float" orientation="portrait" fig-type="figure">
<label>FIG. 3.</label>
<caption>
<title>Applying different assignment approaches to a given trajectory.</title>
<p>Points represent frames in the trajectory and are colored to show assignment, as with <xref ref-type="fig" rid="fig2">Fig. 2</xref>. The forward assignment algorithm (top) assigns frames in forward time order of the trajectory, with the forward order of the subensembles of the sequential ensemble. The reverse assignment algorithm (middle) assigns frames in the reverse order of the subensembles in the sequential ensemble, in reverse time order of the trajectory. Finally, the forward assignment of the reversed trajectory (bottom) is shown to illustrate that this is distinct from the reverse assignment. Note that a trajectory may be accepted by one assignment algorithm and rejected by the other (as shown here by the red X for an unassigned frame in the reverse assignment).</p></caption>
<graphic xlink:href="351510_fig3.tif"/>
</fig>
<p>Next considerthe reverse assignment algorithm, as illustrated in the middle panel of <xref rid="fig3" ref-type="fig">Fig. 3</xref>. Assignment starts at the last frame of the trajectory, and at the final subensemble in the sequential ensemble. This frame is assigned to the final subensemble <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline37.gif"/></alternatives></inline-formula> (shaded purple), as would also happen in case of forward assignment. Stepping backward along the trajectory, the assignment algorithm is looking for frames in the volume <italic>I</italic><sub>2</sub>, following the penultimate subensemble. Since <italic>I</italic><sub>1</sub> &#x2282; <italic>I</italic><sub>2</sub>, it finds such frames, and it continues to find frames in <italic>I</italic><sub>2</sub> until the last frame to be assigned (the first frame of the trajectory), which is in <italic>A</italic>. Reaching that frame, the algorithm first checks whether it can be assigned to the <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline38.gif"/></alternatives></inline-formula> ensemble, as with the frame before. As this is not the case, the algorithm checks whether the frame can be assigned to the <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline39.gif"/></alternatives></inline-formula> ensemble, the next subensemble in the reverse order. Since this is also not the case, the reverse check algorithm deems this trajectory to fail the sequential ensemble, as it does not contain subtrajectories assigned to all the correct ensembles in the correct order. In the figure, we signify this with the red x.</p>
<p>Note that the reverse assignment is not the same as using theforward assignmentalgorithm to assign framesfrom the time-reversed trajectory, as is shown in the bottom panel in <xref rid="fig3" ref-type="fig">Fig. 3</xref>. For this trajectory, the process of first reversing the trajectory and then assigning in the forward order leads to an assignment analogous to the forward assignment of the non-reversed trajectory. The trial trajectory will be accepted in this case.</p>
<p>The requirement for a trajectory to be sampled correctly with both forward and backward dynamics is that the forward and reverse assignment algorithms accept the same trajectories. For some sequential ensembles, such as the TPS and TIS ensembles, this means that the frame assignment is identical in both directions. However, this does not need to be the case, as can be seen from the minus ensemble implemented in Listing 1 and the trajectory assignments illustrated in <xref rid="fig4" ref-type="fig">Fig. 4</xref>.</p>
<fig id="fig4" position="float" orientation="portrait" fig-type="figure">
<label>FIG. 4.</label>
<caption>
<title>Frame assignment for an example trajectory in the minus ensemble.</title>
<p>Points represent frames in the trajectory and are colored to show assignment, as with <xref ref-type="fig" rid="fig2">Fig. 2</xref>. The solid line represents the boundary of the state volume <italic>A</italic> and the dashed line represents the boundary of the interface volume <italic>I</italic>, with everything below the lines in the respective volume. The forward assignment algorithm (top) and reverse assignment algorithm (bottom) give the same result (the trajectory satisfies the ensemble), although the specific assignment of frames differs.</p></caption>
<graphic xlink:href="351510_fig4.tif"/>
</fig>
<p>The minus ensemble includes trajectories that start with one frame in the state, go on to cross the interface, then return to the state, then cross the interface again, and finally end with one frame in the state. When the interface and state are not equivalent, there is an interstitial volume between them. This means that there could be recrossings of the interface or of the state boundary, as illustrated by the trajectory in <xref rid="fig4" ref-type="fig">Fig. 4</xref>, which also shows how this is handled by the careful implementation of the minus ensemble in Listing 1.</p>
<p>Recrossings are handled by using the fact that the criterion for failing a subensemble is to enter the next volume X. The not-yet-halt criterion for the subensemble is then the requirement to be in the complement volume <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline40.gif"/></alternatives></inline-formula>, thus <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline41.gif"/></alternatives></inline-formula>. For instance, the green Out<sub><italic>A</italic></sub> subensemble handles the condition that the trajectory should reen-terstate A, while allowing many crossings of the I interface. Likewise, the red <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline42.gif"/></alternatives></inline-formula> subensemble handles the second first exit of I, allowing many recrossings of the A boundary.</p>
<p>Note that some successive subensembles involve volumes that have overlap. For example, consider part of the minus ensemble Out<sub><italic>A</italic></sub> &#x2192; In<sub>I</sub> &#x2192; Out<sub><italic>A</italic></sub>. Because the associated volumes are not disjoint (i.e., <italic>I</italic> &#x2229; <italic>A&#x0304;</italic> &#x2260; &#x2205;), frames in that intersection can be assigned to either ensemble, and will be assigned differently for the forward and reverse assignment algorithms. Additionally, the assignment of the optional ensembles depends on the assignment algorithm, again because of this volume overlap. The difference in the two assignment algorithms is shown for an example trajectory in <xref rid="fig4" ref-type="fig">Fig. 4</xref>.</p>
<p>Unlike the example in <xref rid="fig3" ref-type="fig">Fig. 3</xref>, any trajectory that satisfies the forward assignment for the minus ensemble will also satisfy the reverse assignment. Specific frames may be assigned to different subensembles, but the overall trajectory will either satisfy both assignment criteria orfail both.</p>
<p>In addition, because the minus move is one of the most computationally expensive moves in path sampling, we want to design the ensemble so that candidate trajectories are almost certain to be accepted. Without that requirement, the optional ensembles could be removed from the sequence and the Out<sub><italic>A</italic></sub> ensembles in the sequence would become Out<sub><italic>A</italic></sub> &#x2229; PartOut<sub><italic>I</italic></sub>. Here still, the forward and reverse frame assignments would differ. However, this would have the disadvantage that candidate trajectories could return to <italic>A</italic> immediately afterthe first frame in the interstitial, without crossingthe interface. Such trajectories would be expensive to generateand would not beaccepted. Thesamplingwould be correct, but inefficient.</p>
<p>Because of the possible difference between frame assignment in theforward and reverse directions, it is importantto know that the code defaults to forward propagation to check whether a trajectory is in an ensemble. We emphasize that an ensemble which does not give the same results in both directions can still be suitable for situations where only forward dynamics will be used (e.g.,generatingan initial trajectory), but will not suitable for approaches such as the shooting move in path sampling, which involves both forward and backward dynamics.</p>
</sec></sec>
<sec id="s2f">
<label>F.</label>
<title>Performance considerations</title>
<p>The previous sections provide a mathematically complete description of a new, set-based approach to describing path ensembles and their halting criteria in a consistent and unified manner. However, this approach, naively implemented, is not always computationally efficient. The functions described (such as the can-append criterion) take an entire trajectory as input, and therefore must iterate over all previously visited frames after each new frame is added. This leads to algorithms that scale as &#x1D4AA;(<italic>L</italic><sup>2</sup>) instead of &#x1D4AA;(<italic>L</italic>) in <italic>L</italic>, the number of frames. In OPS, this scaling problem is managed by using caches for the sequential ensemble, combined with a Boolean parameter trusted that can be passed to the can_append and <monospace>can_prepend</monospace> functions (as well as their <monospace>strict</monospace> variants). The <monospace>trusted</monospace> parameter for can_append indicates that, as of the previous frame, the trajectory satisfied the can_append criterion (and similarly for <monospace>can_prepend</monospace> and the <monospace>strict</monospace> variants). Additionally, the ensemble indicator function, given by <monospace>ensemble(trajectory)</monospace>, takes an optional Boolean parameter called candidate. If <monospace>candidate&#x003D;True</monospace>, then the code assumes that the trajectory was generated by the <monospace>can_append</monospace> or <monospace>can_prepend</monospace> method, and therefore only certain parts of the trajectory need to be tested.</p>
<p>For example, consider a flexible-length TPS ensemble as in <xref ref-type="disp-formula" rid="eqn37">Eq. 37</xref> and a trajectory (<italic>x</italic><sub>0</sub>,&#x2026;, <italic>x</italic><sub><italic>i</italic></sub>). If (<italic>x</italic><sub>0</sub>,&#x2026;, <italic>x</italic><sub><italic>i</italic>&#x2212;1</sub>) satisfied the can-append criteria, then we know that the last trajectory with frames assigned was Out<sub><italic>S</italic></sub>, and we should first check whether <italic>x</italic><sub><italic>i</italic></sub> &#x2209; <italic>S</italic>, which would allow us to assign it to that subensemble as well. The trusted parameter tells us that we can trust that the previous frame passed can-append, enabling a faster path for checking the can-append criterion. In addition, the <monospace>SequentialEnsemble</monospace> keeps a cache of the frame assignment, so the algorithm knows immediately to which ensemble the frame should be assigned (with safety checks that this frame is still part of the same trajectory.)</p>
<p>As an example of the use of the candidate parameter, again consider the flexible-length TPS ensemble, with some trajectory (<italic>x</italic><sub>0</sub>,&#x2026;,<italic>x</italic><sub><italic>L</italic></sub>). If that trajectory was generated using the <monospace>can_append</monospace> or <monospace>can_prepend</monospace> rules, no frames except the first and last can be in any state. In this case, we can check whether the trajectory satisfies the ensemble just by checking if the first and last frames are in the appropriate states. The methods built into OPS for arbitrary ensembles are general, but might not be the most efficient. Customized ensembles can make use of the trusted and candidate parameters to provide faster calculations for trajectories known to be generated by dynamics, while still benefitting from the general approaches for trajectories of unknown origin.</p>
</sec>
<sec id="s2g">
<label>G.</label>
<title>Guidelines for designing custom ensembles</title>
<p>The above sections introduced the set-based notation for path ensembles, illustrated the connection between this notation and the innerworkings of OPS, and showed howOPS uses this conceptual framework to implement ensembles used in path sampling simulations. In <xref ref-type="sec" rid="s4">Sec. IV</xref>, we will provide several more examples of useful path ensembles. However, defining new ensembles might not seem completely straightforward. To help bridge the gap between understanding the ensembles we present, and creating new ensembles, in this section we provide some general guidelines and tricks that could be seen as rules of thumb for ensemble building.</p>
<sec id="s2g1">
<label>&#x2022;</label>
<title>Use anchors</title>
<p>In many path ensembles, trajectories start and end with a frame in a specific volume (or union of volumes). It can be useful to think of these as anchors to start designing the ensemble. Typically, the building block is a single frame in some volume <italic>A</italic>, i.e., the ensemble <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline43.gif"/></alternatives></inline-formula>.</p>
</sec>
<sec id="s2g2">
<label>&#x2022;</label>
<title>Use complement ensembles and volumes</title>
<p>If we want a trajectory to end with the first frame in some volume <italic>A</italic>, we might think of this as a PartIn<sub><italic>A</italic></sub> ensemble. But, as discussed in <xref ref-type="sec" rid="s2d">Sec. II D</xref>, the PartIn<sub><italic>A</italic></sub> ensemble never halts. However, the first trajectory that will satisfy it can come from the first trajectory that does not satisfy its complementary ensemble, Out<sub><italic>A</italic></sub>. This can, of course, also be written as In<sub><italic>A&#x0304;</italic></sub>. In some cases, the complement volume may be the one that is more naturally defined. For example, if part of a sequential ensemble is supposed to lead to a first frame in <italic>A</italic>, we can use the Out<sub><italic>A</italic></sub> ensemble, as is done in the minus ensemble, which also uses this to create a first frame outside of the interface <italic>I</italic> using In<sub><italic>I</italic></sub> (where it is more natural to refer to a frame outside the interface volume than a frame inside the complement of the interface volume). A more elaborate example using this reasoning is given in <xref ref-type="sec" rid="s4">Sec. IV</xref> for the ensemble used to get the initial trajectory that visits all states.</p>
</sec>
<sec id="s2g3">
<label>&#x2022;</label>
<title>Think in terms of halting criteria</title>
<p>First, it is important to make sure that every ensemble (and every subensemble of a sequential ensemble) will eventually halt. Second, the halting criteria can be useful when designing sequential ensembles. Because the sequential ensemble uses a greedy algorithm, it is important to think in terms of the stopping criteria of the previous ensemble and where that leaves you. The previous guideline explained how to get a crossing out of some volume (call it <italic>I</italic>), but typically we speak of crossing from starting in one volume (call it <italic>A</italic>) and then exiting the volume <italic>I</italic>. To know which volume the subensemble will start in, look at the previous subensemble and apply the rules in the guideline about complement ensembles and volumes.</p>
</sec>
<sec id="s2g4">
<label>&#x2022;</label>
<title>Prefer set logic on volumes, not ensembles</title>
<p>When creating ensembles, set logic on ensembles and on volumes might seem very similar. For instance, one might be tempted to code the ensemble Out<sub><italic>A</italic>&#x222A;<italic>B</italic></sub> as Out<sub><italic>A</italic></sub> &#x222A; Out<sub><italic>B</italic></sub> However, this is incorrect, as explained in <xref ref-type="sec" rid="s2c">Section II C</xref>. Also, the logical complement of ensembles in general is not what one naively would expect. The set logic for volumes is usually more familiar, and therefore, whenever possible, should be used.</p>
</sec>
<sec id="s2g5">
<label>&#x2022;</label>
<title>Beware of unions with PartIn or PartOut</title>
<p>This relates to both the suggestion of thinking in terms of halting criteria and preferring set logic on volumes. The danger here is that, while an ensemble such as In<sub><italic>I</italic></sub> &#x222A; PartOut<sub><italic>A</italic></sub> may seem reasonable, the stopping criterion of PartOut<sub><italic>A</italic></sub> is to never stop, and therefore a union with it leads to infinite trajectories.</p>
</sec>
<sec id="s2g6">
<label>&#x2022;</label>
<title>Check the reverse assignment</title>
<p>If using path sampling, or any other algorithm that requires generating dynamics in the backward time direction, check that the reverse assignment gives the same results as the forward assignment. The ideas behind this are described in <xref ref-type="sec" rid="s2e3">Sec. II E3</xref>. Developing a symmetric sequence for the sequential ensemble can help with the reverse assignment. Not all methods require that the reverse assignment be used; only those that involve propagating backward in time.</p>
</sec>
<sec id="s2g7">
<label>&#x2022;</label>
<title>Use optional ensembles for flexibility</title>
<p>The optional ensemble allows a particular subensemble of a sequential ensemble to be skipped. This is useful when the ensemble will be employed in many variants, and when it is uncertain whether the subensemble will always be satisfied (as with the minus ensemble). Including optional ensemble can also ensure that both the forward and reverse assignment work properly.</p>
</sec>
<sec id="s2g8">
<label>&#x2022;</label>
<title>Use unions of complex ensembles</title>
<p>Sometime a union of complex ensembles, such as sequential ensembles, is the best way to achieve a desired ensemble. For example, consider sampling <italic>A</italic> &#x2192; <italic>B</italic> transitions and <italic>B</italic> &#x2192; <italic>A</italic> transitions in one ensemble. A TPS ensemble from <italic>A</italic> &#x222A; <italic>B</italic> to <italic>A</italic> &#x222A; <italic>B</italic> will not work, since it willallow <italic>A</italic> &#x2192; <italic>A</italic> and <italic>B</italic> &#x2192; <italic>B</italic> transitions. Instead use a union of sequential ensembles, SeqEnsTPS<sub><italic>A</italic>&#x2192;<italic>B</italic></sub> &#x222A; SeqEnsTPS<sub><italic>B</italic>&#x2192;<italic>A</italic></sub>.</p>
<p>Finally, there is often more than one way to implement a given path ensemble. Theseguidelinesshould providetools both for the design of new ensembles, as well as to understand ensembles we have provided as examples in <xref ref-type="sec" rid="s4">Sec. IV</xref>.</p>
</sec>
</sec>
</sec>
<sec id="s3">
<label>III.</label>
<title>GENERAL FRAMEWORK FOR CUSTOM MONTE CARLO APPROACHES</title>
<p>Transition path sampling amounts to Monte Carlo of trajectory space. In standard TPS, the Monte Carlo procedure samples trajectories from a single path ensemble. In TIS, and particularly in RETIS, the Monte Carlo procedure simultaneously samples trajectories from an expanded ensemble, combining multiple interface ensembles. Standard TPS can be seen as a special case of this expanded ensemble, where only a single path ensemble is sampled. The expanded ensemble gives rise to the <monospace>SampleSet</monospace> object in OPS, as described in Paper I.</p>
<p>Monte Carlo moves in OPS, based on this expanded ensemble, are performed by the PathMover object. PathMovers can change trajectories within the ensemble being sampled (as with the shooting move), or they can alter the ensembles associated with trajectories without changing the trajectories (as with path replica exchange), or they can alter both the trajectory and its associated ensemble (as with the minus move).</p>
<p>The PathMovers are organized in an overall <italic>move decision tree.</italic> This tree includes, besides the movers that perform the Monte Carlo steps, several so-called <italic>structural movers</italic>, e.g., the <monospace>RandomChoiceMover</monospace> that randomly selects one of several <italic>submovers</italic> (these structural movers are described in <xref ref-type="sec" rid="s3">Sec. III A</xref>). In principle, a manually assembled move decision tree is all that is necessary for a path sampling simulation. However, for complicated move decision trees, this becomes tedious and difficult. The PathMovers, including the structural movers, constitute a low-level interface that is sufficient, but not particularly user-friendly. Therefore, we havedeveloped a higher-level layer, usingthe <monospace>MoveStrategy</monospace> and <monospace>MoveScheme</monospace> objects, which automates the repetitive lower-level operations, and enables the user to customize the move decision tree easily.</p>
<p>The <monospace>MoveScheme</monospace> is an overall container that builds the move decision tree, while each <monospace>MoveStrategy</monospace> deals with a part of that tree: providing, for example, details on how the shooting move will be performed, or which pairs of ensembles are involved in replica exchange. A path sampling simulation will have one <monospace>MoveScheme</monospace>, and that <monospace>MoveScheme</monospace> will include multiple <monospace>MoveStrategy</monospace> objects.</p>
<p>The following subsections describe how the structural path movers allow combining existing movers into a more complicated move, and how to use the <monospace>MoveStrategy</monospace> and <monospace>MoveScheme</monospace>. Subclassing existing objects can create more complicated path movers; details are available in the online documentation for OpenPathSampling at <monospace><ext-link ext-link-type="uri" xlink:href="http://openpathsampling.org">http://openpathsampling.org</ext-link></monospace>.</p>
<sec id="s3a">
<label>A.</label>
<title>Structural Movers</title>
<p><monospace>PathMover</monospace> objects such as the <monospace>OneWayShootingMover</monospace> and <monospace>ReplicaExchangeMover</monospace> generate newtrial paths. However, they need to be organized into the overall move decision tree. This organization is done by other subclasses of PathMover, which we call <italic>structural movers.</italic> Important structural movers include:
<list list-type="bullet">
<list-item><p>A <monospace><bold>RandomChoiceMover</bold></monospace>, one of the main structural elements in most move decision trees, randomly selects one of its submovers. For example, a first <monospace>RandomChoiceMover</monospace> selects the type of move (shooting, replica exchange, etc.), followed by a second <monospace>RandomChoiceMover</monospace> that selects a mover for the specific ensemble(s) involved in the move. The <monospace>RandomChoiceMover</monospace> is also an important element in many PathMovers. For example, the <monospace>OneWayShootingMover</monospace> consists of a <monospace>RandomChoiceMover</monospace> that selects between a <monospace>ForwardShootingMover</monospace> and a <monospace>BackwardShootingMover</monospace>. By default, the submovers within a <monospace>RandomChoiceMover</monospace> have identical probability of being selected; this can be changed with the weights parameter at initialization.</p></list-item>
<list-item><p>A <monospace><bold>SequentialMover</bold></monospace> employs several submovers in a specific order, where each submover is accepted independently. This mover is not a combined trial move, but a bundle of several moves together in a specific order.</p></list-item>
<list-item><p>The <monospace><bold>ConditionalSequentialMover</bold></monospace> is similar to a <monospace>SequentialMover</monospace>, but provides an early-rejection scheme, which is important for moves where a failure in an early step can guarantee that the whole move fails, especially if later steps are very expensive. Below we will discuss how this plays a role in the <monospace>MinusMover</monospace>.</p></list-item>
<list-item><p>An <monospace><bold>EnsembleFilterMover</bold></monospace> removes resulting Samples associated with intermediate ensembles from the results. In complicated movers, extra, internally-defined Ensemble objects can create intermediate steps in the mover, which would end up in the results. The <monospace>EnsembleFilterMover</monospace> filters those (often uninformative data) out of the results.</p></list-item>
</list>
</p>
<p>The move decision tree can take many forms. To obtain information about the path mover most likely of interest (e.g., <monospace>ReplicaExchangeMover</monospace> or <monospace>ForwardShootingMover</monospace>) regardless of the specific structure of the move decision tree, we implemented a property canonical in the MoveChange. As discussed in Paper I[<xref ref-type="bibr" rid="c24">24</xref>], a <monospace>PathMover</monospace> takes a <monospace>SampleSet</monospace> as input, and returns a MoveChange object. This MoveChange can contain other MoveChanges from submovers; in this way the whole path taken through the move decision tree is preserved. However, the nested structure of MoveChanges can make it cumbersome to access attributes from the MoveChange of the specific submover of interest (e.g., shooting point from the MoveChange associated with the shooting mover). Therefore, the MoveChange.canonical property directly accesses the first nested MoveChange associated with a mover that identifies itself as &#x201C;canonical&#x201D; Subclasses of <monospace>PathMover</monospace> can declare themselves canonical by setting the class attribute <monospace>_is_canonical</monospace> to True. Examples using the canonical property can be found in Paper I, <xref ref-type="sec" rid="s4a">Sec. VI.A</xref> 6.</p>
<p>The <monospace>MinusMover</monospace> provides a useful example of how several structural movers can be put together to generate a new Monte Carlo move. As described in paper I, the OPS <monospace>MinusMover</monospace> is, in a way, a combination of replica exchange and shooting moves. In MSTIS, each state typically has one MinusMover, which takes trajectories from two ensembles as input: the TIS innermost interface ensemble and the minus ensemble. In the discussion that follows, the state is denoted A and the innermost interface volume <italic>X</italic>. In many cases the state definition A will be identical to <italic>X</italic>, but this is not required.</p>
<p>Both the TIS ensemble and the minus interface ensemble are described in <xref ref-type="sec" rid="s2">Sec. II E</xref>. In the minus move, both use the same interface volume, <italic>X</italic>. In addition, there is an ensemble which is used internally in the minus move. This ensemble is nearly thesame as the TIS ensemble used as input, except that instead of allowing paths to end in either <italic>A</italic> or make a transition to another state <italic>B</italic>, all paths in this internal ensemble must start in <italic>A</italic>, cross the interface, and also end in <italic>A</italic>, i.e., this is the ensemble <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline44.gif"/></alternatives></inline-formula> <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline45.gif"/></alternatives></inline-formula>. In the context of the minus move, we refer to this as the &#x201C;segment ensemble" Trajectories in the minus interface ensemble begin and end with subtrajectories that also satisfy the segment ensemble and therefore satisfy the innermost interface ensemble.</p>
<p>The minus move consists of three steps: (1) randomly selecting one of the subtrajectories that satisfies the segment ensemble from the minus ensemble trajectory; (2) performing a replica exchange move between the selected segment and the path in the innermost interface; (3) extending that path in a random time direction until it satisfies the minus interface ensemble.</p>
<p>The first step is performed by a <monospace>RandomChoiceMover</monospace> that selects between eithera <monospace>FirstSubtrajectorySelectMover</monospace> or a <monospace>FinalSubtrajectorySelectMover</monospace>, where in both cases the subtrajectory satisfies the segment ensemble This step should always be accepted as the initial path satisfies the minus ensemble.</p>
<p>When there is only one innermost ensemble, the second step is just a replica exchange. This replica exchange can only fail if the innermost interface path happens to cross to anotherstable state. In the case of a multiple interface sets (as in MISTIS), however, there are multiple innermost interfaces [<xref ref-type="bibr" rid="c31">31</xref>]. The interface to exchange with is selected with a <monospace>RandomChoiceMover</monospace>that includes <monospace>ReplicaExchangeMovers</monospace> for each innermost interface. The segment might not overlap with the selected interface, and therefore this step very well mightfailforMISTIS.</p>
<p>In the final step, the trajectory that was initially in the innermost interface ensemble is extended until it satisfies the minus ensemble, using a <monospace>RandomChoiceMover</monospace> to choose either a <monospace>ForwardExtendMover</monospace> or a <monospace>BackwardExtendMover</monospace>.</p>
<p>No part of the move can be accepted unless all parts succeed. Therefore, we use a <monospace>ConditionalSequentialMover</monospace> for this. In addition, we used the intermediate &#x201C;segment&#x201D; ensemble. To remove this from the results, we wrap the mover in a <monospace>EnsembleFilterMover</monospace>.</p>
<p><xref rid="fig5" ref-type="fig">Fig. 5</xref> shows the internal structure of this mover. Normally, this structure is not shown in the move decision tree visualization because the <monospace>MinusMover</monospace> is marked as a canonical mover, and the visualizer does not show internal structure of canonical movers. This setting can be overridden by changing the <monospace>options.analysis</monospace> dictionary of the visualizer.</p>
<fig id="fig5" position="float" orientation="portrait" fig-type="figure">
<label>FIG. 5.</label>
<caption>
<title>Internal structure of a <monospace>MinusMover</monospace>.</title>
<p>At the left, the hierarchical structure of mover. Each layer (moving left) is encapsulated in the objects to the right. During a minus move, submovers are visited from top to bottom (but not all submovers are visited). The <monospace>MinusMover</monospace>, labelled &#x201C;<monospace>Minus</monospace>&#x201D;, is the outermost container. Inside it is the <monospace>EnsembleFilterMover</monospace> that filters out results in the internally-used segment ensemble. The primary sequence of the minus move is in the <monospace>ConditionalSequentialMover</monospace>, each of which involves a <monospace>RandomChoiceMover</monospace>, which select the specific movers to do at each stage. On the right are the three ensembles involved in the minus move, labelled with A, B, and C. Ensemble A is the innermost TIS ensemble, ensemble B is the minus ensemble, and ensemble C is the segment ensemble. The input and output ensembles for each mover are shown in blue and red (respectively). Movers like replica exchange have the same input and output ensembles (even if the replicas have changed), whereas movers like the subtrajectory selectors move a replica from one ensemble to another.</p></caption>
<graphic xlink:href="351510_fig5.tif"/>
</fig>
</sec>
<sec id="s3b">
<label>B.</label>
<title><monospace>MoveScheme</monospace> and <monospace>MoveStrategy</monospace> objects</title>
<p>The <monospace>MoveScheme</monospace> contains multiple <monospace>MoveStrategy</monospace> objects, used to automatically build the (often elaborate) move decision tree. It also is possible to build move decision trees manually. To make these manually-built trees compatible with other parts of OPS, the root mover needs to be wrapped in a in a <monospace>LockedMoveScheme</monospace>. However, many of the tools for <monospace>MoveSchemes</monospace> are not available for <monospace>LockedMoveSchemes</monospace>, and much of what is discussed in the remainder ofthis section is not applicable to <monospace>LockedMoveSchemes</monospace>.</p>
<p>In addition to containing the move decision tree, a <monospace>MoveScheme</monospace> organizes information about the sampling process, and provides access to tools for analyzing the sampling procedure after the simulation. In particular, the <monospace>MoveScheme</monospace> organizes the movers into labeled or named groups. For the default TIS scheme, the group names are &#x2018;<monospace>shooting</monospace>&#x2019; (shooting movers), &#x2018;<monospace>repex</monospace>&#x2019; (replica exchange), &#x2018;<monospace>pathreversal</monospace>&#x2019; (path reversal), and &#x2018;<monospace>minus</monospace>&#x2019; (minus move). These can be accessed with <monospace>scheme.movers[group_name]</monospace>. Each group consists of multiple <monospace>PathMovers</monospace>. Each <monospace>PathMover</monospace> in turn has specific input and output ensembles. Forshooting, a single ensemble is used for both input and output. For <monospace>EnsembleHopMovers</monospace> (the single-replica version of replica exchange, which moves a single replica from one ensemble to a different ensemble), the input mover is different from the output mover. <monospace>ReplicaExchangeMovers</monospace> have two input and two output ensembles (the same pair for both). We referto this set of input and output ensembles as the mover&#x2019;s <italic>ensemble signature</italic>.</p>
<p>To build the move decision tree, one must decide (1) which ensemble signatures will be part of each type of move (e.g., which ensembles to shoot from), (2) how the movers will be implemented (e.g., what kind of shooting move to use), and (3) how all movers are organized into the overall decision tree (e.g., select type of mover first, then specific ensembles to include). <monospace>MoveScheme</monospace> builds the move decision tree by applying multiple <monospace>MoveStrategy</monospace> objects. Each <monospace>MoveStrategy</monospace> is associated with a specific priority level. When building the move decision tree, the strategies are applied in order of priority level, and within a priority level, in order of addition to the <monospace>MoveScheme</monospace>. The default priority levels are in <monospace>openpathsampling.strategies.levels.LEVELNAME</monospace>, where <monospace>LEVELNAME</monospace> can be, in order of ascending priority, <monospace>SIGNATURE, MOVER, GROUP, or GLOBAL</monospace>. Internally, these priority levels are represented by integers between 0 and 100, but these specific levels are named for convenience. The recommended use for these levels is as follows:
<list list-type="bullet">
<list-item><p>Strategies at the <monospace>SIGNATURE</monospace> level modify the set of ensemble signatures to be used; for example, the default <monospace>NearestNeighborRepExStrategy</monospace> which executes replica swaps among neighboring interfaces, versus the <monospace>AllSetRepExStrategy</monospace>, which implements replica swaps among all interfaces within the same <monospace>Transition</monospace> (interface set).</p></list-item>
<list-item><p>Strategies at the <monospace>MOVER</monospace> level customize the behavior of the created path movers; for example, the <monospace>OneWayShootingStrategy</monospace> provides the ability to choose a shooting point selector for the shooting group.</p></list-item>
<list-item><p>Strategies at the <monospace>GROUP</monospace> level can take the already-built movers and rearrange them, or convert them to a different approach. For example, the single-replica EnsembleHop movers can be converted to normal replica exchange using the <monospace>ReplicaExchangeStrategy</monospace>, which is a GROUP-level strategy. In <xref ref-type="sec" rid="s4">Sec. IV</xref>, we show another GROUP-level strategy, which will take the already-created shooting and replica exchange movers, and reorganize them into a single sequential move.</p></list-item>
<list-item><p>Strategies at the <monospace>GLOBAL</monospace> level organize the overall move decision tree. The two <monospace>GLOBAL</monospace>-level strategies in OPS are the <monospace>OrganizeByMoveGroupStrategy</monospace>, which first selects a move type, and then selects which specific mover (which signature, i.e., which ensembles), and the <monospace>OrganizeByEnsembleStrategy</monospace>, which starts with the selection of the ensemble to move (as necessary with single-replica approaches) and then selects which type of move to do.</p></list-item>
</list>
</p>
<p>By using this priority-level system, the move decision tree can be built correctly, regardless of the order in which the specific move strategies are added to the scheme. Parts that must be built later <italic>are</italic> built later because of the priority levels. In addition, the details of what has already been built (e.g., specific choices of parameters for movers, such as the shooting pointselection in a shooting move) can be retained by later moves that reorganize the entire move decision tree.</p>
<p><monospace>MoveStrategy</monospace> objects deal with the details of the implementation, when building the move decision tree. For example, two-way shooting could be used instead of one-way shooting by starting with the default scheme applying a <monospace>TwoWayShootingStrategy</monospace> to the scheme:
<fig id="ufig4" position="float" orientation="portrait" fig-type="figure">
<graphic xlink:href="351510_ufig4.tif"/>
</fig>
where <monospace>engine</monospace> and <monospace>network</monospace> were already appropriately defined (see Paper I for details[<xref ref-type="bibr" rid="c24">24</xref>]). This implements a two-way shooting move decision tree where the shooting point is not modified, and the decorrelation depends on the stochastic dynamics. Alternatively, for NVT dynamics, one could choose the momenta randomly from a Maxwell-Boltzmann distribution, as is, for instance, done in the aimless shooting [<xref ref-type="bibr" rid="c32">32</xref>] approach. The scheme then becomes
<fig id="ufig5" position="float" orientation="portrait" fig-type="figure">
<graphic xlink:href="351510_ufig5.tif"/>
</fig>
where <monospace>temperature</monospace>, <monospace>engine</monospace>, and <monospace>network</monospace> were already appropriately defined. This implements a two-sway shooting move decision tree where the shooting point obtains random velocities taken from a Maxwell-Boltzmann distribution at the desired temperature. If the engine supports constraints, the <monospace>RandomVelocities</monospace> modifier will project that distribution into the space of constraints.</p>
<p>As another example, a modified shooting point selector could be used, instead of the default (uniform selector). For instance, the <monospace>GaussianBiasSelector</monospace> selects the shooting point according to a Gaussian probability in a specified collective variable [<xref ref-type="bibr" rid="c33">33</xref>]. After setting up the <monospace>scheme</monospace> as above, and creating a collective variable cv, the following code will implement this selector:
<fig id="ufig6" position="float" orientation="portrait" fig-type="figure">
<graphic xlink:href="351510_ufig6.tif"/>
</fig>
where the Gaussian bias is defined by exp(&#x2212;<italic>&#x03B1;</italic>(cv(<italic>x</italic>) &#x2212; <italic>l</italic><sub>0</sub>)<sup>2</sup>), with <italic>x</italic> a snapshot, and <italic>l</italic><sub>0</sub> and <italic>&#x03B1;</italic>, respectively, control the position and width of the Gaussian.</p>
<p>Athird example of a <monospace>MoveStrategy</monospace> is to add a specific ensemble pair to the list of possible replica exchange moves. To do this, one would first select the ensembles (call them <monospace>ens1</monospace> and <monospace>ens2</monospace>). Then, after creating the <monospace>scheme</monospace> as before, the new replica exchange pairs can be added with:
<fig id="ufig7" position="float" orientation="portrait" fig-type="figure">
<graphic xlink:href="351510_ufig7.tif"/>
</fig>
</p>
<p>Note that this last example was a signature-level strategy, whereas the other examples were mover-level. The priority-level system used in OPS means that the user does not have to considerthe order in which the strategies are built when appending them to a custom move scheme. For example, the signature-level strategy that changes the ensembles used in replica exchange can be appended afterthe mover-level strategy that provides details of how to perform the shooting move, even though the order they are used in the opposite orderwhen buildingthe move decision tree.</p>
</sec>
</sec>
<sec id="s4">
<label>IV.</label>
<title>ILLUSTRATIVE EXAMPLES</title>
<sec id="s4a">
<label>A.</label>
<title>Creating new ensembles</title>
<p>One of the significant features of <monospace>OpenPathSampling</monospace> is the ability to generate valid paths for arbitrary path ensembles. This capability facilitates the development of new methodologies, which often require the creation of new path ensembles. In addition, this feature has practical advantages for users as well. In the Appendix of Paper I, we briefly mentioned one such practical use[<xref ref-type="bibr" rid="c24">24</xref>]. To obtain the initial conditionsfora path samplingsimulation, we can use a high temperature trajectory. For multiple state TIS simulations, we also need initial trajectories that satisfy all the ensembles in the MSTIS network: there must be trajectories that begin in each state, and which exit each interface volume. For most MSTIS simulation setups, a path that undergoes a transition to another state, crosses all the interfaces associated with the starting state. Therefore, we can use such a transition path as an initial path for all interfaces. And since we can reverse paths, a long trajectory that visits all states will contain, for each of the defined MSTIS ensemble in the network, a (possibly reversed) subtrajectory that satisfies that ensemble.</p>
<p>Thus, our high temperature target trajectory is one that has visited all states. To define an ensemble that will generate such a trajectory, we use complement ensembles and think in terms of halting criteria, as suggested in the guidelines in <xref ref-type="sec" rid="s2">Sec. II G</xref>. We need a condition that remains true until the trajectory has visited all states &#x2014; in other words, the opposite of the condition that the trajectory has visited all states. This means that we should continue as long as the trajectory has not visited at least one state. We can express this idea as a path ensemble
<disp-formula id="eqn42"><alternatives><graphic xlink:href="351510_eqn42.gif"/></alternatives></disp-formula>
which is only true if none of the <italic>M</italic> Out conditions are fulfilled. The continuation condition is nowthe negation of this ensemble
<disp-formula id="eqn43"><alternatives><graphic xlink:href="351510_eqn43.gif"/></alternatives></disp-formula>
</p>
<p>This condition translates in OPS to the python code
<fig id="ufig8" position="float" orientation="portrait" fig-type="figure">
<graphic xlink:href="351510_ufig8.tif"/>
</fig>
where <monospace>states</monospace> is a list of the state volumes. We can then create the goal trajectory using the <monospace>engine.generate</monospace> method by
<fig id="ufig9" position="float" orientation="portrait" fig-type="figure">
<graphic xlink:href="351510_ufig9.tif"/>
</fig>
</p>
<p>The resulting <monospace>trajectory</monospace> will have visited every state, and the last frame will be in the last state visited. Since it visits every state, then it has, for every state, a subtrajectory that starts in that state and ends in another (in some cases requiring time reversal). This means that subtrajectories of this long trajectory can be found to satisfy all the ensembles in the MSTIS network. Note that we use the ensemble itself asa condition, notitsCanAppfunction. Inthiscase, because these are In/Out<sub><italic>A</italic></sub>-type ensembles, the CanApp is equivalent to the ensemble check (this is not necessarily the case for other ensembles). Conceptually, we are after the first trajectory that does not satisfy the ensemble, so we use the ensemble check itself.</p>
<p>We can also define another (arbitrary) ensemble to obtain a first trajectory suitable for the TIS bootstrapping procedure. This procedure takes a trajectory satisfying the innermost interface ensemble of a TIS transition, and performs shooting moves until the resulting paths satisfy the ensemble(s) forthe subsequent interface(s). To get that initial trajectory, we want to start from any arbitrary frame, then have at least one frame in state <italic>A</italic>, then have at least one frame that crosses the interface, and end with exactly one frame in either state <italic>A</italic> or state <italic>B</italic> (where state <italic>B</italic> can be generalized to the union of multiple other states). The sequential ensemble to do this is
<disp-formula id="ueqn1"><alternatives><graphic xlink:href="351510_ueqn1.gif"/></alternatives></disp-formula>
</p>
<p>Following <xref ref-type="sec" rid="s2">Sec. II G</xref>, this ensemble uses an anchorthat combines the optional ensemble outside of <italic>A</italic> with a required ensemble inside <italic>A</italic>. As also suggested in the guidelines, the <monospace>OptionalEnsembles</monospace> in this ensemble are designed to ensure that any possible trajectory that satisfies the overall goal will still be accepted. This ensemble translates into OPS code as
<fig id="ufig10" position="float" orientation="portrait" fig-type="figure">
<graphic xlink:href="351510_ufig10.tif"/>
</fig>
</p>
<p>A similar ensemble is part of the <monospace>FullBootstrapping</monospace> calculation, which fills TIS ensembles starting from a single snapshot.</p>
</sec>
<sec id="s4b">
<label>B.</label>
<title>Using <monospace>Ensemble.split</monospace> for trajectory analysis</title>
<p>The <monospace>Ensemble</monospace> object in <monospace>OpenPathSampling</monospace> provides a convenient way of analyzing trajectories in terms of subtrajectories. The <monospace>ensemble.split(trajectory, overlap)</monospace> method takesa long <monospace>trajectory</monospace> and returnsa list of subtrajectories that satisfy the <monospace>ensemble</monospace>. Successive subtrajectories will have at most <monospace>overlap</monospace> frames in common (with a default of 1 shared frame). For example, we can check whether any trajectories in a fixed-length TPS simulation included recrossings. Given state volumes A and B, we first create the <italic>B</italic> &#x2192; <italic>A</italic> transition ensemble:
<disp-formula id="ueqn2"><alternatives><graphic xlink:href="351510_ueqn2.gif"/></alternatives></disp-formula>
which in OPS code translates to
<fig id="ufig11" position="float" orientation="portrait" fig-type="figure">
<graphic xlink:href="351510_ufig11.tif"/>
</fig>
</p>
<p>Making frames outside of both A and B optional captures trajectories where the transition occurs without any intermediate frames (this is unlikely in our examples, but could be common in long paths with (too) infrequent saving of frames). We can apply <monospace>B_to_A.split(trajectory)</monospace> to every trajectory accepted bythefixed-lengthTPSensemble. Ifthe resulting list is not empty, a recrossing in the <italic>B</italic> &#x2192; <italic>A</italic> direction took place. Since the first frame of every accepted trajectory has to be in <italic>A</italic> and the last frame of every trajectory is necessarily in <italic>B</italic>, the existence of a <italic>B</italic> &#x2192; <italic>A</italic> transition guarantees a recrossing. Forthe fixed path length alanine dipeptide example from Paper I[<xref ref-type="bibr" rid="c24">24</xref>], <xref ref-type="sec" rid="s4">Sec. VI A</xref>, we find 109 accepted trials with recrossings, including 5 with 2 recrossing events. For accepted paths with a single recrossing, there are two <italic>&#x03B1;</italic> &#x2192; <italic>&#x03B2;</italic> transitions in the path &#x2013; one before recrossing, and one after. With two recrossings, there would be three transitions. An example of an accepted recrossing trajectory is shown in <xref rid="fig6" ref-type="fig">Fig. 6</xref>.</p>
<fig id="fig6" position="float" orientation="portrait" fig-type="figure">
<label>FIG. 6.</label>
<caption><p><bold>Accepted TPS trajectory with recrossing</bold> taken from the fixed-length TPS simulation of alanine dipeptide in Paper 1[<xref ref-type="bibr" rid="c24">24</xref>]. The angle <italic>&#x03C8;</italic> is plotted as a function of time. Frames in <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline46.gif"/></alternatives></inline-formula> are marked in red; frames in <italic>&#x03B1;</italic><sub><italic>R</italic></sub> are marked in blue.</p></caption>
<graphic xlink:href="351510_fig6.tif"/>
</fig>
<p>This approach also allows distinguishing between multiple channels fora given reaction. For instance, we can compare the behavior of fixed path length TPS and flexible path length TPS for alanine dipeptide. By taking <monospace>ensemble</monospace> as the flexible path length TPS ensemble, application of the split function identifies subtrajectories of the fixed path length TPS that match the flexible path length ensemble.</p>
<p><xref rid="fig7" ref-type="fig">Fig. 7a</xref> shows path-length histograms forthe transitions in the flexible path length TPS ensemble and in the fixed path length ensemble (selected using the <monospace>split</monospace> function), from our TPS simulations of alanine dipeptide reported in Paper I. These histograms differ because the fixed length ensemble in fact sampled two different transition mechanisms. To show this, we can define custom path ensembles that distinguish between the two mechanisms. First, we define additional volumes, based on the <italic>&#x03C8;</italic> collective variable: an A volume for 100 &#x003C; <italic>&#x03C8;</italic> &#x003C; 200 (where the <monospace>CVPeriodicRangeVolume</monospace> automatically wraps into the correct bounds), and a B volume for &#x2212;100 &#x003C; <italic>&#x03C8;</italic> &#x003C; 200. These two volumes are based on the original states, but have no restrictions in <italic>&#x03D5;</italic>. Two additional volumes account forthe &#x201C;noman&#x2019;s land&#x201D; region outside the states: <monospace>nml_increasing</monospace> for &#x2212;160 &#x003C; <italic>&#x03C8;</italic> &#x003C; &#x2212;100, and <monospace>nml_decreasing</monospace> for 0 &#x003C; <italic>&#x03C8;</italic> &#x003C; 100. Next, we identify a transition as&#x201C;increasing&#x201D; ifthe trajectory crosses the <monospace>nml_increasing</monospace> volume (i.e., the value of 0 increases while going from one state to the next), and &#x201C;decreasing&#x201D; if it crosses the <monospace>nml_decreasing</monospace> volume. The sequential ensemble forthe increasing transitions can be defined by
<disp-formula id="eqn44"><alternatives><graphic xlink:href="351510_eqn44.gif"/></alternatives></disp-formula>
which is in OPS code
<fig id="ufig12" position="float" orientation="portrait" fig-type="figure">
<graphic xlink:href="351510_ufig12.tif"/>
</fig>
<fig id="fig7" position="float" orientation="portrait" fig-type="figure">
<label>FIG. 7.</label>
<caption>
<title>Transition path length distributions.</title>
<p>Top: Without distinguishing between increasing and decreasing transition types from the fixed length TPS. Bottom: Distinguishing the increasing and decreasing transitions. The difference in the path length distributions can be attributed to the fixed-length simulation sampling both increasing and decreasing transitions.</p></caption>
<graphic xlink:href="351510_fig7.tif"/>
</fig>
</p>
<p>The ensemble for decreasing transitions is defined similarly, but using nml_decreasing in place of <monospace>nml_increasing</monospace>. Trajectories that satisfy the original TPS ensemble will have subtrajectories that satisfy one of these ensembles. By using the <monospace>ensemble.split()</monospace> method, we can identify which mechanism each trajectory represents.</p>
<p><xref rid="fig8" ref-type="fig">Fig 8</xref> shows several trajectories (blue and purple) connecting the original two stable states (dark red). The states are defined in terms of periodic variables, and can wrap around the periodic boundary. The &#x201C;extended&#x201D; versions of the states that were defined above are shown in light red, and the two different &#x201C;no man&#x2019;s land&#x201D; volumes are labelled nml_decreasing and nmljncreasing. Several hypothetical trajectories are shown, all of which would count as a decreasing transition. Trajectory (a) would be easy to analyze by a volume-based approach (and is also a realistic trajectory for this system). Trajectories (b) and (c) would count as decreasing transitions, but an analysis based only on volumes (without consideration of ordering) might miss them. Trajectory (d) includes both an increasing and a decreasing transition (and would be extraordinarily unlikely in this system).</p>
<fig id="fig8" position="float" orientation="portrait" fig-type="figure">
<label>FIG. 8.</label>
<caption><p>Volumes and example trajectories for the different ways a &#x201C;decreasing&#x201D; transition can occur. The shaded areas represent the extended state definitions used in the analysis of the transitions, while the darker shaded areas are the actual states of the system, (a) A typical decreasing path, (b) and (c) Paths which visit the &#x201C;increasing&#x201D; no man&#x2019;s land, but only transition across the decreasing, (d) Path with both increasing and decreasing transitions.</p></caption>
<graphic xlink:href="351510_fig8.tif"/>
</fig>
<p>The fixed length alanine dipeptide example shows 3570 trajectories in the decreasing channel and 6670 trajectories in the increasing channel (weighted by the Monte Carlo weights from the TPS simulation). All transition trajectories satisfy exactly one of the two channels, although some TPS trajectories, due to recrossings, have more than one transition trajectory. The flexible length example has all its trajectories in the decreasing channel. The existence of recrossings in the fixed length TPS ensemble demonstrates that these transitions in alanine dipeptide are not <italic>that</italic> rare, so it is not surprising that we would also observe switching between the two mechanisms. The bottom panel of <xref rid="fig7" ref-type="fig">Fig. 7</xref> shows the path length histograms when the increasing and decreasing transitions are distinguished. The decreasing subtrajectories from the fixed-length sampling and the trajectories from the flexible-length sampling (which are all decreasing) show much closer agreement, and the increasing transition shows a very different distribution.</p>
<p>We can also replace othercommon analyses with versions based on <monospace>Ensemble.split</monospace>. For example, consider the lifetime in a given state, which is defined by the time from when a trajectory first enters the state (having previously been in another state) until it enters another state. We refer to the desired state as <italic>A</italic> and the combination of all other states as <italic>B</italic>.</p>
<p>To think of this in terms of path ensembles, we describe it in two stages. First, we need to find the path ensemble which goes from another state, enters the desired state, and then enters another state. We denote this the &#x201C;BAB&#x201D; ensemble. The trajectories which are relevant to the lifetime calculation are subtrajectories of trajectories in the BAB ensemble. These go from the first entrance in A to the first entrance in We&#x2019;ll call this the &#x201C;AB&#x201D; ensemble. We obtain trajectories in the AB ensemble by first getting all the segments that satisfy the BAB ensemble, and then selecting the relevant subtrajectories. Defining the BAB ensemble as
<disp-formula id="ueqn3"><alternatives><graphic xlink:href="351510_ueqn3.gif"/></alternatives></disp-formula>
the corresponding OPS code is given by:
<fig id="ufig13" position="float" orientation="portrait" fig-type="figure">
<graphic xlink:href="351510_ufig13.tif"/>
</fig>
</p>
<p>The AB ensemble is defined as
<disp-formula id="ueqn4"><alternatives><graphic xlink:href="351510_ueqn4.gif"/></alternatives></disp-formula>
with the OPS code given by:
<fig id="ufig14" position="float" orientation="portrait" fig-type="figure">
<graphic xlink:href="351510_ufig14.tif"/>
</fig>
</p>
<p>Both ensembles make use of the guideline on thinking about the halting criteria (from <xref ref-type="sec" rid="s2">Sec. II G</xref>) by using Out<sub><italic>B</italic></sub> as part of the middle subensemble. This guarantees that the middle subensemble stops, and the first frame afterward must be the first frame in state <italic>B</italic> (thus satisfying the final subsensemble). Additionally both of these ensembles use anchors requiring one frame in a state. Formally, the intersection with <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline47.gif"/></alternatives></inline-formula> is not necessary, as we might as well have selected the last subtrajectory of frames in <italic>B</italic>/the first subtrajectory of frames in <italic>A</italic>, instead of the lastframe in <italic>B</italic>/first frame in <italic>A</italic>.</p>
<p>To use these, we just run:
<fig id="ufig15" position="float" orientation="portrait" fig-type="figure">
<graphic xlink:href="351510_ufig15.tif"/>
</fig>
</p>
<p>In <xref rid="fig9" ref-type="fig">Fig. 9</xref>, we visualize the trajectory segments associated with each of these ensembles for a sample trajectory from a toy model.</p>
<fig id="fig9" position="float" orientation="portrait" fig-type="figure">
<label>FIG. 9.</label>
<caption>
<title>Trajectory segments for lifetimes.</title>
<p>A trajectory for a toy model is shown with a light grey line. The red area represents state <italic>B</italic>, and the blue area represents state <italic>A</italic>. The segment that satisfies the BAB ensemble is shown in dark grey line, and the segment that satisfies the AB ensemble is shown in blue (and overlaps the BAB segment).</p></caption>
<graphic xlink:href="351510_fig9.tif"/>
</fig>
<p>In the above example, the average time of the resulting trajectories gives the average lifetime in a state. In a two-state system, the reciprocal of the average lifetime is the rate. This could be modified to get the transition rate constants for a multiple state system by replacing the <monospace>AllInXEnsemble</monospace>(B) in the BAB sequential ensemble with an ensemble that would allow any state other than A, while the last one allows a specific state B. This would give the lifetime associated with the rate of <italic>A</italic> &#x2192; <italic>B</italic>.</p>
<p>A similar procedure can be used to obtain the flux from a state through a given interface in TIS. In that case, we do two lifetime analyses: the lifetime outside the interface (where <italic>A</italic> everything outside the interface, and <italic>B</italic> is the state) and the lifetime inside the state (where <italic>A</italic> is the state, and <italic>B</italic> is everything outside the interface). The reciprocal of the sum of the average lifetimes from these gives us the flux [<xref ref-type="bibr" rid="c25">25</xref>].</p>
<p>Sincethis example involves two loops overthe snapshots, it may not be as fast as code custom-designed to this purpose. (Although, in fact, the caching of OPS collective variables renders the vast majority of the total computational effort done in the first pass.) However, our primary intent here is to highlight how simple it is to prototype a trajectory analysis based on using the <monospace>Ensemble.split</monospace> method. It may be possible to write faster code, but it is hard to write code faster.</p>
<p>The specific implementations of flux and lifetime discussed here are included in the <monospace>SingleTrajectoryAnalysis</monospace> object.</p>
</sec>
<sec id="s4c">
<label>C.</label>
<title>Custom PathMovers</title>
<p>OpenPathSampling also facilitates the creation of custom move schemes. In this section, we present an example of how that can be done, and compare the sampling behavior of this custom move scheme to the default move scheme.</p>
<p>The default RETIS move scheme selects a type of move at random (shooting, replica exchange, etc.) and then attempts one move of that type (shooting in a single ensemble, replica exchange fora specific pair, etc.). But perhaps a move which does all the replica exchanges in sequential order, then does shooting moves on all the ensembles, and then does the replica exchange in the reverse order, would be more efficient. This move will satisfy detailed balance &#x2014; the question is whether it is more efficient.</p>
<p>Forthe most part, this simulation is set up as in the examples in Paper I[<xref ref-type="bibr" rid="c24">24</xref>]. The specific potential energy surface is given by
<disp-formula id="eqn45"><alternatives><graphic xlink:href="351510_eqn45.gif"/></alternatives></disp-formula>
</p>
<p>States are defined such that state <italic>A</italic> is <italic>x</italic> &#x003C; &#x2212;0.5 and state <italic>B</italic> is <italic>x</italic> &#x003E; 0.5. Only the <italic>A</italic> &#x2192; <italic>B</italic> transition is studied, with interface volumes from <italic>x</italic><sub>min</sub> &#x003D; &#x2212;&#x221E; to <italic>x</italic><sub>max,<italic>i</italic></sub> &#x003D; {&#x2212;0.4, &#x2212;0.3, &#x2212;0.2, &#x2212;0.1}. The potential energy surface, with states and interface boundaries, is shown in <xref rid="fig10" ref-type="fig">Fig. 10</xref>.</p>
<fig id="fig10" position="float" orientation="portrait" fig-type="figure">
<label>FIG. 10.</label>
<caption>
<title>Modelsystem forthe custom move scheme example.</title>
<p>Potential energy surface with states in blue and interface boundaries in red.</p></caption>
<graphic xlink:href="351510_fig10.tif"/>
</fig>
<p>The main difference with the examples in Paper I[<xref ref-type="bibr" rid="c24">24</xref>]. is that here, we define a custom <monospace>MoveStrategy</monospace> object, which creates a custom sequential mover. The code forthis mover and a move strategy to manage it is in Listing 2.</p>
<p>To use this strategy, we first create a default scheme, and then append the new strategy:
<fig id="ufig16" position="float" orientation="portrait" fig-type="figure">
<graphic xlink:href="351510_ufig16.tif"/>
</fig>
<fig id="ufig17" position="float" orientation="portrait" fig-type="figure">
<graphic xlink:href="351510_ufig17.tif"/>
</fig>
</p>
<p>The visualization of this move scheme in is <xref rid="fig11" ref-type="fig">Fig. 11</xref>. There is still a random choice of type of move, but the types available are now minus move, path reversal, and the sequential mover, which is the only choice under the &#x201C;<monospace>Repex_shoot_repexChooser</monospace>&#x201D; in the illustration of the move decision tree. The relative probabilities for each move type are determined as ratios. By default, a new move type has the same (relative) probability as a shooting move, which is twice that of a replica exchange or path reversal, and five times that of a minus move. This means that when the repex-shoot-repex move replaces shooting and replica exchange in the move scheme, the ratio of per-ensemble shootingattemptsto path reversalsorto minus moves stays the same.</p>
<fig id="fig11" position="float" orientation="portrait" fig-type="figure">
<label>FIG. 11.</label>
<caption>
<title>Move scheme including the repex-shoot-repex mover.</title></caption>
<graphic xlink:href="351510_fig11.tif"/>
</fig>
<p>On the other hand, the number of total MC steps per ensemble shooting attempts will, of course, be very different between the custom and default schemes. To compare these fairly, we use the function <monospace>scheme.n_steps_for_trials</monospace>, which takes a mover and the number of desired attempts of that mover as arguments. We can ensure the two simulations do about the same amount of work by aiming for the same number of per-ensemble shooting moves. Forthe default scheme, this is
<fig id="ufig18" position="float" orientation="portrait" fig-type="figure">
<graphic xlink:href="351510_ufig18.tif"/>
</fig>
and for the custom scheme, it is
<fig id="ufig19" position="float" orientation="portrait" fig-type="figure">
<graphic xlink:href="351510_ufig19.tif"/>
</fig>
where <monospace>n_tries_per_shooting</monospace> is a number we have chosen (50000 in the example). We arbitrarily select the first shooting mover in the default scheme, since all have the same probability. We take the total probability of selecting the &#x2018;<monospace>repex_shoot_repex</monospace>&#x2019; group, because there isonemoverin that group, and every time it occurs, it creates one shooting attempt foreach ensemble.</p>
<p>To ensure that this is a fair comparison, there are a few comparisons that should be made. First, we use the <monospace>scheme.move_summaryfunction</monospace> (described in PaperI[<xref ref-type="bibr" rid="c24">24</xref>])to show that we have the same number of path reversal and minus moves in each scheme. We can also use the move summary to see that we have the same number of shooting moves per ensemble, by comparing the per-ensemble shooting count obtained by adding &#x2018;shooting&#x2019; as a second argument to <monospace>default_scheme.move_summary</monospace> with the number of <monospace>repex-shoot-repex</monospace> moves in the <monospace>custom_scheme</monospace>. Since both schemes are sampling the same number of shooting moves in the same ensembles, they should create roughly the same numberoftotalsnapshots. We can check this with len(<monospace>storage.snapshots</monospace>) for each storage.</p>
<p>To analyze these results, we consider replica round trip times and replica flow [<xref ref-type="bibr" rid="c34">34</xref>], concepts that monitorthe presence of bottlenecks during the replica exchange. Both concepts require defining ensembles as &#x201C;top&#x201D; and &#x201C;bottom.&#x201D; We put the minus ensemble as the bottom ensemble, and the outermost TIS ensemble as the top ensemble. A round trip can start from either the first entry to the &#x201C;top&#x201D; ensemble or the first entry to the &#x201C;bottom&#x201D; ensemble, and will use whichever the given replica visits first. If the replica visits the &#x201C;top&#x201D; ensemble first, the round trip duration is the number of Monte Carlo steps from the first entry into &#x201C;top&#x201D; until the replica returns to &#x201C;top&#x201D; after visiting &#x201C;bottom,&#x201D; with the case starting in &#x201C;bottom&#x201D; defined analogously.</p>
<p>Replica flow is defined by labelling each replica as either travelling &#x201C;up&#x201D; or &#x201C;down,&#x201D; depending on whether it more recently visited the &#x201C;bottom&#x201D; or&#x201C;top&#x201D; ensemble, respectively. For each ensemble <italic>i</italic>, the count of visits by &#x201C;up&#x201D; replicas is given by <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline48.gif"/></alternatives></inline-formula>, with the number of visits by &#x201C;down&#x201D; replicas given by <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline49.gif"/></alternatives></inline-formula>. The flow for a given ensemble is defined as <inline-formula><alternatives><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="351510_inline50.gif"/></alternatives></inline-formula>. Formally, flow is 1 at the &#x201C;bottom&#x201D; ensemble and 0 at the &#x201C;top&#x201D; ensemble. The ideal flow is linear with the replica index. [<xref ref-type="bibr" rid="c34">34</xref>]</p>
<p>Round trip times and flow are both calculated as part of the <monospace>ReplicaNetwork</monospace> analysis tool. The code to analyze the default scheme is
<fig id="ufig20" position="float" orientation="portrait" fig-type="figure">
<graphic xlink:href="351510_ufig20.tif"/>
</fig>
</p>
<p>Then <monospace>default_trips</monospace>[&#x2018;round&#x2019;] returns a list of the duration (in Monte Carlo steps) of each round trip that occurred. Analysis forthe custom scheme is analogous.</p>
<p>For this simple example, we find the custom move scheme does not yield significant improvement. The default scheme generates 345 round trips, whereas the custom scheme generates 311. There may be a small difference in the distribution of the round trip times (see <xref rid="fig12" ref-type="fig">Fig. 12</xref>). The distribution of round trip times is skewed toward slightly longer round trips forthe custom scheme. The replica flow, shown in <xref rid="fig13" ref-type="fig">Fig. 13</xref>, are very similar for both approaches. Overall, the default scheme is probably a slightly better choice.</p>
<fig id="fig12" position="float" orientation="portrait" fig-type="figure">
<label>FIG. 12.</label>
<caption><p><bold>Histogram of round trip times</bold> for the default RETIS scheme and the custom scheme with the &#x201C;repex-shoot-repex&#x201D; move, with duration normalized to the total number of MC steps. Although both give about the same number of round trips, the distributions may differ somewhat.</p></caption>
<graphic xlink:href="351510_fig12.tif"/>
</fig>
<fig id="fig13" position="float" orientation="portrait" fig-type="figure">
<label>FIG. 13.</label>
<caption><p><bold>Replica flow</bold> for the default TIS scheme and the custom scheme with the &#x201C;repex-shoot-repex&#x201D; move. This example shows little difference, with the suggestion that the default scheme may be slightly better.</p></caption>
<graphic xlink:href="351510_fig13.tif"/>
</fig>
</sec>
</sec>
<sec id="s5">
<label>V.</label>
<title>CONCLUSION</title>
<p>In this paper we have described some advanced topics relevantto the OpenPathSamplingframework [<xref ref-type="bibr" rid="c24">24</xref>]. We have introduced a novel set-based approach to constructing path ensemble, along with a new notation suitable to this approach. This allows the application of set logic to path ensembles, and fits seamlessly with the way that OPS is written. Another advantage of this new notation is that it unifies the description ofthe monitorfunction of OPS with the path ensemble indicatorfunction. Of particular importance herein is the sequential path ensemble, which is directly related to the way that OPS implements the path sampling monitoringand testing. Usingthis new notation it is remark-ablysimpleto create new path ensembles, and immediately implement these in OPS.</p>
<p>In addition, we provided insight in how one can customize the path sampling Monte Carlo movers within OPS in order to build non standard sampling schemes. These customizations are required if one wants to develop new path sampling schemes, oradapt existing ones.</p>
<p>In short, in this paper we have illustrated the power and flexibility of the OPS package. Users can now develop their own advanced sampling protocol entirely in OPS, and apply it to compute kinetic and thermodynamic observables.</p>
<p>In future work we will further elaborate on the foundation of the ensemble set-logic. Anotherdirection is to parallelize the OPS code. While running multiple simulations in parallel is already possible, true parallelization requires the load balancing of multiple ensembles, where trajectories can have different and unpredictable path lengths, overthe available computational resources.</p>
</sec>
</body>
<back>
<ack>
<title>ACKNOWLEDGMENTS</title>
<p>DWHS and PGB acknowledge support from the European Union&#x2019;s Horizon 2020 research and innovation program, under grant agreement No 676531 (project E-CAM). JDC acknowledges support from Cycle for Survival, NIH grant P30 CA008748, and NIH grant R01 GM121505. JDC, JHP, and DWHS gratefully acknowledge support from the Sloan Kettering Institute. FN acknowledges ERC consolidator grant 772230 &#x201C;ScaleCell&#x201D;, DFG NO 825/3-1, and SFB1114, project A04. project A04.</p>
<p>The authors are grateful for feedback from many people who helped beta-test the software, whose names are listed at <monospace><ext-link ext-link-type="uri" xlink:href="http://openpathsampling.org/latest/acknowledgments.html">http://openpathsampling.org/latest/acknowledgments.html</ext-link></monospace>. The authors are particularly grateful to Sander Roet (University of Amsterdam) for his feedback, and to Jocelyne Vreede (University of Amsterdam) forthe feedback obtained by using OPS as a teaching tool in courses on biomolecularsimulation.</p>
</ack>
<sec sec-type="COI-statement">
<title>CONFLICT OF INTEREST STATEMENT</title>
<p>JDC is a member of the Scientific Advisory Board for Schr&#x00F6;dinger, LLC.</p>
</sec>
<ref-list>
<ref id="c1"><label>[1]</label><mixed-citation publication-type="journal"><string-name><given-names>K.</given-names> <surname>Lindorff-Larsen</surname></string-name>, <string-name><given-names>S.</given-names> <surname>Piana</surname></string-name>, <string-name><surname>Dror</surname> <given-names>R. O.</given-names></string-name>, and <string-name><given-names>D. E.</given-names> <surname>Shaw</surname></string-name>, <source>Science</source> <volume>334</volume>, <fpage>517</fpage> (<year>2011</year>).</mixed-citation></ref>
<ref id="c2"><label>[2]</label><mixed-citation publication-type="journal"><string-name><given-names>I.</given-names> <surname>Buch</surname></string-name>, <string-name><given-names>T.</given-names> <surname>Giorgino</surname></string-name>, and <string-name><given-names>G.</given-names> <surname>De Fabritiis</surname></string-name>, <source>Proc. Nat. Acad. Sci. USA</source> <volume>108</volume>, <fpage>10184</fpage> (<year>2011</year>).</mixed-citation></ref>
<ref id="c3"><label>[3]</label><mixed-citation publication-type="journal"><string-name><given-names>N.</given-names> <surname>Plattner</surname></string-name> and <string-name><given-names>F.</given-names> <surname>Noe</surname></string-name>, <source>Nat. Comm.</source> <volume>6</volume>, <fpage>7653</fpage> (<year>2015</year>).</mixed-citation></ref>
<ref id="c4"><label>[4]</label><mixed-citation publication-type="journal"><string-name><given-names>D.-A.</given-names> <surname>Silva</surname></string-name>, <string-name><given-names>G. R.</given-names> <surname>Bowman</surname></string-name>, <string-name><given-names>A.</given-names> <surname>Sosa-Peinado</surname></string-name>, and <string-name><given-names>X.</given-names> <surname>Huang</surname></string-name>, <source>PLoS Computational Biology</source> <volume>7</volume>, <fpage>e1002054</fpage> (<year>2011</year>).</mixed-citation></ref>
<ref id="c5"><label>[5]</label><mixed-citation publication-type="book"><string-name><given-names>C.</given-names> <surname>Sch&#x00FC;tte</surname></string-name> and <string-name><given-names>W.</given-names> <surname>Huisinga</surname></string-name>, in <source>Handbook of Numerical Analysis</source>, edited by <person-group person-group-type="editor"><string-name><given-names>P. G.</given-names> <surname>Ciaret</surname></string-name> and <string-name><given-names>J.-L.</given-names> <surname>Lions</surname></string-name></person-group> (<publisher-name>Elsevier, ADDRESS</publisher-name>, <year>2003</year>), Vol. <volume>X</volume>, pp. <fpage>699</fpage>&#x2013;<lpage>744</lpage>.</mixed-citation></ref>
<ref id="c6"><label>[6]</label><mixed-citation publication-type="journal"><string-name><given-names>F.</given-names> <surname>No&#x00E9;</surname></string-name>, <string-name><given-names>I.</given-names> <surname>Horenko</surname></string-name>, <string-name><given-names>C.</given-names> <surname>Schutte</surname></string-name>, and <string-name><given-names>J. C.</given-names> <surname>Smith</surname></string-name>, <source>J. Chem. Phys.</source> <volume>126</volume>, <fpage>155102</fpage> (<year>2006</year>).</mixed-citation></ref>
<ref id="c7"><label>[7]</label><mixed-citation publication-type="journal"><string-name><given-names>J. D.</given-names> <surname>Chodera</surname></string-name>, <string-name><given-names>N.</given-names> <surname>Singhal</surname></string-name>, <string-name><given-names>V. S.</given-names> <surname>Pande</surname></string-name>, <string-name><given-names>K. A.</given-names> <surname>Dill</surname></string-name>, and <string-name><given-names>W. C.</given-names> <surname>Swope</surname></string-name>, <source>J. Chem. Phys.</source> <volume>126</volume>,<fpage>155101</fpage> (<year>2007</year>).</mixed-citation></ref>
<ref id="c8"><label>[8]</label><mixed-citation publication-type="book"><string-name><given-names>D.</given-names> <surname>Chandler</surname></string-name>, in <chapter-title>Classical and Quantum Dynamics in Condensed Phase Simulations</chapter-title>, edited by <person-group person-group-type="editor"><string-name><given-names>B. J.</given-names> <surname>Berne</surname></string-name>, <string-name><given-names>G.</given-names> <surname>Ciccotti</surname></string-name>, and <string-name><given-names>D. F.</given-names> <surname>Coker</surname></string-name></person-group> (<publisher-name>World Scientific, ADDRESS</publisher-name>, <year>1998</year>), <source>Chap. Barrier crossings: classical theory of rare but important events</source>, pp. <fpage>3</fpage>&#x2013;<lpage>23</lpage>.</mixed-citation></ref>
<ref id="c9"><label>[9]</label><mixed-citation publication-type="journal"><string-name><given-names>G. M.</given-names> <surname>Torrie</surname></string-name> and <string-name><given-names>J. P.</given-names> <surname>Valleau</surname></string-name>, <source>Chem. Phys. Lett.</source> <volume>28</volume>, <fpage>578</fpage> (<year>1974</year>).</mixed-citation></ref>
<ref id="c10"><label>[10]</label><mixed-citation publication-type="journal"><string-name><given-names>E.</given-names> <surname>Carter</surname></string-name>, <string-name><given-names>G.</given-names> <surname>Ciccotti</surname></string-name>, <string-name><given-names>J. T.</given-names> <surname>Hynes</surname></string-name>, and <string-name><given-names>R.</given-names> <surname>Kapral</surname></string-name>, <source>Chem. Phys. Lett.</source> <volume>156</volume>,<fpage>472</fpage> (<year>1989</year>).</mixed-citation></ref>
<ref id="c11"><label>[11]</label><mixed-citation publication-type="journal"><string-name><given-names>T.</given-names> <surname>Huber</surname></string-name>, <string-name><given-names>A.</given-names> <surname>Torda</surname></string-name>, <string-name><given-names>W.</given-names> <surname>van Gunsteren</surname></string-name>, <source>J. Comput. Aided Mol. Des.</source> <volume>8</volume>,<fpage>695</fpage> (<year>1994</year>).</mixed-citation></ref>
<ref id="c12"><label>[12]</label><mixed-citation publication-type="journal"><string-name><given-names>H.</given-names> <surname>Grubm&#x00FC;ller</surname></string-name>, <source>Phys. Rev. E</source> <volume>52</volume>, <fpage>2893</fpage> (<year>1995</year>).</mixed-citation></ref>
<ref id="c13"><label>[13]</label><mixed-citation publication-type="journal"><string-name><given-names>A. F.</given-names> <surname>Voter</surname></string-name>, <source>J. Chem. Phys.</source> <volume>106</volume>, <fpage>4665</fpage> (<year>1997</year>).</mixed-citation></ref>
<ref id="c14"><label>[14]</label><mixed-citation publication-type="journal"><string-name><given-names>A.</given-names> <surname>Laio</surname></string-name> and <string-name><given-names>M.</given-names> <surname>Parrinello</surname></string-name>, <source>Proc. Nat. Acad. Sci. USA</source> <volume>99</volume>,<fpage>12562</fpage> (<year>2002</year>).</mixed-citation></ref>
<ref id="c15"><label>[15]</label><mixed-citation publication-type="journal"><string-name><given-names>E.</given-names> <surname>Darve</surname></string-name> and <string-name><given-names>A.</given-names> <surname>Pohorille</surname></string-name>, <source>J. Chem. Phys.</source> <volume>115</volume>, <fpage>9169</fpage> (<year>2001</year>).</mixed-citation></ref>
<ref id="c16"><label>[16]</label><mixed-citation publication-type="journal"><string-name><given-names>Y.</given-names> <surname>Sugita</surname></string-name>, and <string-name><given-names>Y.</given-names> <surname>Okamoto</surname></string-name>, <source>Chem. Phys. Lett.</source> <volume>314</volume>,<fpage>141</fpage> (<year>1999</year>).</mixed-citation></ref>
<ref id="c17"><label>[17]</label><mixed-citation publication-type="journal"><string-name><given-names>E.</given-names> <surname>Marinari</surname></string-name> and <string-name><given-names>G.</given-names> <surname>Parisi</surname></string-name>, <source>Europhys. Lett.</source> <volume>19</volume>,<fpage>451</fpage> (<year>1992</year>).</mixed-citation></ref>
<ref id="c18"><label>[18]</label><mixed-citation publication-type="journal"><string-name><given-names>L.</given-names> <surname>Zheng</surname></string-name>, <string-name><given-names>M.</given-names> <surname>Chen</surname></string-name>, and <string-name><given-names>W.</given-names> <surname>Yang</surname></string-name>, <source>Proceedings of the National Academy of Sciences</source> <volume>105</volume>, <fpage>20227</fpage> (<year>2008</year>).</mixed-citation></ref>
<ref id="c19"><label>[19]</label><mixed-citation publication-type="journal"><string-name><given-names>Y. Q.</given-names> <surname>Gao</surname></string-name>, <source>J. Chem. Phys.</source> <volume>128</volume>, <fpage>064105</fpage> (<year>2008</year>).</mixed-citation></ref>
<ref id="c20"><label>[20]</label><mixed-citation publication-type="journal"><string-name><given-names>C.</given-names> <surname>Dellago</surname></string-name>, <string-name><given-names>P. G.</given-names> <surname>Bolhuis</surname></string-name>, <string-name><given-names>F. S.</given-names> <surname>Csajka</surname></string-name>, and <string-name><given-names>D.</given-names> <surname>Chandler</surname></string-name>, <source>J. Chem. Phys.</source> <volume>108</volume>, <fpage>1964</fpage> (<year>1998</year>).</mixed-citation></ref>
<ref id="c21"><label>[21]</label><mixed-citation publication-type="journal"><string-name><given-names>P. G.</given-names> <surname>Bolhuis</surname></string-name>, <string-name><given-names>D.</given-names> <surname>Chandler</surname></string-name>, <string-name><given-names>C.</given-names> <surname>Dellago</surname></string-name>, and <string-name><given-names>P.</given-names> <surname>Geissler</surname></string-name>, <source>Ann. Rev. Phys. Chem.</source> <volume>53</volume>, <fpage>291</fpage> (<year>2002</year>).</mixed-citation></ref>
<ref id="c22"><label>[22]</label><mixed-citation publication-type="journal"><string-name><given-names>C.</given-names> <surname>Dellago</surname></string-name>, <string-name><given-names>P. G.</given-names> <surname>Bolhuis</surname></string-name>, and <string-name><given-names>P. L.</given-names> <surname>Geissler</surname></string-name>, <source>Adv. Chem. Phys.</source> <volume>123</volume>, <fpage>1</fpage> (<year>2002</year>).</mixed-citation></ref>
<ref id="c23"><label>[23]</label><mixed-citation publication-type="journal"><string-name><given-names>C.</given-names> <surname>Dellago</surname></string-name> and <string-name><given-names>P. G.</given-names> <surname>Bolhuis</surname></string-name>, <source>Adv Polym Sci</source> <volume>221</volume>, <fpage>167</fpage> (<year>2009</year>).</mixed-citation></ref>
<ref id="c24"><label>[24]</label><mixed-citation publication-type="book"><string-name><given-names>D. W.</given-names> <surname>Swenson</surname></string-name>, <string-name><given-names>J.-H.</given-names> <surname>Prinz</surname></string-name>, <string-name><given-names>F.</given-names> <surname>Noe</surname></string-name>, <string-name><given-names>P. G.</given-names> <surname>Bolhuis</surname></string-name>, and <publisher-name>J. Chodera, to be published</publisher-name> (<year>2018</year>).</mixed-citation></ref>
<ref id="c25"><label>[25]</label><mixed-citation publication-type="journal"><string-name><given-names>T.</given-names> <surname>van Erp</surname></string-name>, <source>Phys. Rev. Lett.</source> <volume>98</volume>, <fpage>268301</fpage> (<year>2007</year>).</mixed-citation></ref>
<ref id="c26"><label>[26]</label><mixed-citation publication-type="journal"><string-name><given-names>P. G.</given-names> <surname>Bolhuis</surname></string-name>, <source>J. Chem. Phys.</source> <volume>129</volume>, <fpage>114108</fpage> (<year>2008</year>).</mixed-citation></ref>
<ref id="c27"><label>[27]</label><mixed-citation publication-type="journal"><string-name><given-names>T. S.</given-names> <surname>van Erp</surname></string-name>, <source>Adv. Chem. Phys.</source> <volume>151</volume>, <fpage>27</fpage> (<year>2012</year>).</mixed-citation></ref>
<ref id="c28"><label>[28]</label><mixed-citation publication-type="book"><string-name><given-names>P. G.</given-names> <surname>Bolhuis</surname></string-name> and <string-name><given-names>C.</given-names> <surname>Dellago</surname></string-name>, <source>Reviews of Computational Chemistry</source> (<publisher-name>Wiley-VCH</publisher-name>, <publisher-loc>Hoboken</publisher-loc>, <year>2009</year>).</mixed-citation></ref>
<ref id="c29"><label>[29]</label><mixed-citation publication-type="book"><string-name><given-names>D. W.</given-names> <surname>Swenson</surname></string-name>, <publisher-name>to be published</publisher-name> (<year>2018</year>).</mixed-citation></ref>
<ref id="c30"><label>[30]</label><mixed-citation publication-type="journal"><string-name><given-names>T. S.</given-names> <surname>van Erp</surname></string-name>, <string-name><given-names>D.</given-names> <surname>Moroni</surname></string-name>, and <string-name><given-names>P. G.</given-names> <surname>Bolhuis</surname></string-name>, <source>J. Chem. Phys.</source> <volume>118</volume>, <fpage>7762</fpage> (<year>2003</year>).</mixed-citation></ref>
<ref id="c31"><label>[31]</label><mixed-citation publication-type="journal"><string-name><given-names>D. W. H.</given-names> <surname>Swenson</surname></string-name> and <string-name><given-names>P. G.</given-names> <surname>Bolhuis</surname></string-name>, <source>J. Chem. Phys.</source> <volume>141</volume>, <fpage>044101</fpage> (<year>2014</year>).</mixed-citation></ref>
<ref id="c32"><label>[32]</label><mixed-citation publication-type="journal"><string-name><given-names>B.</given-names> <surname>Peters</surname></string-name> and <string-name><given-names>B. L.</given-names> <surname>Trout</surname></string-name>, <source>The Journal of Chemical Physics</source> <volume>125</volume>, <fpage>054108</fpage> (<year>2006</year>).</mixed-citation></ref>
<ref id="c33"><label>[33]</label><mixed-citation publication-type="journal"><string-name><surname>Juraszek</surname> <given-names>J.</given-names></string-name> and <string-name><given-names>P. G.</given-names> <surname>Bolhuis</surname></string-name>, <source>Biophysical Journal</source> <volume>95</volume>, <fpage>4246</fpage> (<year>2008</year>).</mixed-citation></ref>
<ref id="c34"><label>[34]</label><mixed-citation publication-type="journal"><string-name><given-names>H. G.</given-names> <surname>Katzgraber</surname></string-name>, <string-name><given-names>S.</given-names> <surname>Trebst</surname></string-name>, <string-name><given-names>D. A.</given-names> <surname>Huse</surname></string-name>, and <string-name><given-names>M.</given-names> <surname>Troyer</surname></string-name>, <source>Journal of Statistical Mechanics: Theory and Experiment</source> <volume>2006</volume>, <fpage>P03018</fpage> (<year>2006</year>).</mixed-citation></ref>
</ref-list>
</back>
</article>