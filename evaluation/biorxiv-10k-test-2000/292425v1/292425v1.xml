<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.2d1 20170631//EN" "JATS-archivearticle1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" article-type="article" dtd-version="1.2d1" specific-use="production" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">BIORXIV</journal-id>
<journal-title-group>
<journal-title>bioRxiv</journal-title>
<abbrev-journal-title abbrev-type="publisher">bioRxiv</abbrev-journal-title>
</journal-title-group>
<publisher>
<publisher-name>Cold Spring Harbor Laboratory</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1101/292425</article-id>
<article-version>1.1</article-version>
<article-categories>
<subj-group subj-group-type="author-type">
<subject>Regular Article</subject>
</subj-group>
<subj-group subj-group-type="heading">
<subject>New Results</subject>
</subj-group>
<subj-group subj-group-type="hwp-journal-coll">
<subject>Bioinformatics</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>Mass Spectra alignment using virtual lock-masses</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes">
<contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-5804-6023</contrib-id>
<name><surname>Brochu</surname>
<given-names>Francis</given-names></name>
<xref ref-type="aff" rid="a1">1</xref>
<xref ref-type="aff" rid="a2">2</xref>
<xref ref-type="author-notes" rid="n1">&#x002A;</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Plante</surname>
<given-names>Pier-Luc</given-names></name>
<xref ref-type="aff" rid="a1">1</xref>
<xref ref-type="aff" rid="a3">3</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Drouin</surname>
<given-names>Alexandre</given-names></name>
<xref ref-type="aff" rid="a1">1</xref>
<xref ref-type="aff" rid="a2">2</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Laviolette</surname>
<given-names>Franc&#x00B8;ois</given-names></name>
<xref ref-type="aff" rid="a1">1</xref>
<xref ref-type="aff" rid="a2">2</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Marchand</surname>
<given-names>Mario</given-names></name>
<xref ref-type="aff" rid="a1">1</xref>
<xref ref-type="aff" rid="a2">2</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Corbeil</surname>
<given-names>Jacques</given-names></name>
<xref ref-type="aff" rid="a1">1</xref>
<xref ref-type="aff" rid="a3">3</xref>
</contrib>
<aff id="a1"><label>1</label><institution>Big Data Research Center</institution>, Laval University, Qu&#x00E9;bec, Qc, <country>Canada</country></aff>
<aff id="a2"><label>2</label><institution>D&#x00E9;partement d&#x2019;Informatique et G&#x00E9;nie Logiciel, Universit&#x00E9; Laval</institution>, Qu&#x00E9;bec, Qc, <country>Canada</country></aff>
<aff id="a3"><label>3</label><institution>Centre de Recherche du CHU de Qu&#x00E9;bec, Universit&#x00E9; Laval</institution>, Qu&#x00E9;bec, Qc, <country>Canada</country></aff>
</contrib-group>
<author-notes>
<fn id="n1" fn-type="present-address">
<label>&#x00A4;</label>
<p>Current Address: 2325 rue de l&#x2019;Universit&#x00E9;, Big Data Research Center, Universit&#x00E9; Laval, Qu&#x00E9;bec, Qc, Canada</p>
</fn>
<fn id="n2"><label>&#x002A;</label><p><email>francis.brochu.2@ulaval.ca</email></p>
</fn>
</author-notes>
<pub-date pub-type="epub">
<year>2018</year>
</pub-date>
<elocation-id>292425</elocation-id>
<history>
<date date-type="received">
<day>30</day>
<month>3</month>
<year>2018</year>
</date>
<date date-type="rev-recd">
<day>30</day>
<month>3</month>
<year>2018</year>
</date>
<date date-type="accepted">
<day>30</day>
<month>3</month>
<year>2018</year>
</date>
</history>
<permissions>
<copyright-statement>&#x00A9; 2018, Posted by Cold Spring Harbor Laboratory</copyright-statement>
<copyright-year>2018</copyright-year>
<license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by/4.0/"><license-p>This pre-print is available under a Creative Commons License (Attribution 4.0 International), CC BY 4.0, as described at <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link></license-p></license>
</permissions>
<self-uri xlink:href="292425.pdf" content-type="pdf" xlink:role="full-text"/>
<abstract>
<title>Abstract</title>
<p>Mass spectrometry is a valued method to evaluate the metabolomics content of a biological sample. The recent advent of rapid ionization technologies such as Laser Diode Thermal Desorption (LDTD) and Direct Analysis in Real Time (DART) has rendered high-throughput mass spectrometry possible. It can now be used for large-scale comparative analysis of populations of samples. In practice, many factors resulting from the environment, the protocol, and even the instrument itself, can lead to minor discrepancies between spectra, rendering automated comparative analysis difficult. In this work, a sequence/pipeline of algorithms to correct variations between spectra is proposed. The algorithms correct multiple spectra by identifying peaks that are common to all and, from those, computes a spectrum-specific correction. We show that these algorithms increase comparability within large datasets of spectra, facilitating comparative analysis, such as machine learning.</p>
<sec>
<title>Author summary</title>
<p>Mass spectrometry is a widespread technology used to measure the chemical content of samples. This measurement technique is often used with biological samples for diverse applications, such as protein sequencing, metabolomic profiling or quantitative measurements. However, with the increasing throughput of mass spectrometry technologies and methodologies, the resulting datasets are becoming larger. This reveals slight shifts in mass measured by the instruments, in the case of Time-of-Flight (ToF) mass spectrometers. These shifts render spectra harder to compare and analyze in large datasets. In this article, we propose algorithms that counter mass shifts and variations in datasets of ToF mass spectra. These algorithms use no external reference points, instead calculating spectrum-specific corrections by finding peaks present in all spectra of a dataset. Applying these algorithm yields a representation of the mass spectra that can then easily be used for statistical or machine learning analyses.</p>
</sec>
</abstract>
<counts>
<page-count count="32"/>
</counts>
</article-meta>
</front>
<body>
<sec id="s1">
<title>Introduction</title>
<p>Mass spectrometry (MS) is a widely used technique for acquiring data on the metabolome or the proteome of individuals [<xref ref-type="bibr" rid="c1">1</xref>] [<xref ref-type="bibr" rid="c2">2</xref>]. Proteomics applications can consist, among others, of typing of microbial organisms [<xref ref-type="bibr" rid="c3">3</xref>], imaging MS [<xref ref-type="bibr" rid="c4">4</xref>], quantitative comparisons [<xref ref-type="bibr" rid="c5">5</xref>], and peptide sequencing [<xref ref-type="bibr" rid="c6">6</xref>] [<xref ref-type="bibr" rid="c7">7</xref>]. For metabolomics applications, the two main approaches fall into the categories of targeted and untargeted studies. In comparison with targeted studies, untargeted studies acquire data using a shotgun approach. Therefore, this type of study is a good option for novel biomarker discovery and hypothesis generation [<xref ref-type="bibr" rid="c8">8</xref>] [<xref ref-type="bibr" rid="c9">9</xref>].</p>
<p>Through the recent years, novel ionization technologies have emerged leading to easier high-throughput acquisition of mass spectra [<xref ref-type="bibr" rid="c10">10</xref>]. These technologies, such as Laser Diode Thermal Desorption (LDTD) or Direct Analysis in Real Time (DART), allow for the rapid acquisition of large datasets. These methods often preclude or bypass the time separation process used in Liquid Chromatography (LC) or Gas Chromatography (GC) [<xref ref-type="bibr" rid="c11">11</xref>]. Thus, without any time separation, a single mass spectrum will often be represented as lists of peaks, composed of the mass-to-charge ratio of the ion (<italic>m/z</italic> value) and its intensity.</p>
<p>With the rise of larger datasets, multiple problems of comparability between spectra have emerged. Datasets are acquired in multiple batches over numerous days, on different instruments in multiple locations, with recalibrations of the instruments occurring between batches [<xref ref-type="bibr" rid="c12">12</xref>]. These factors induce variations in the spectra that render them harder to compare.</p>
<p>Multiple methods have been suggested in the literature to deal with this problem, mainly affecting Time-of-Flight mass spectrometers. Three such algorithms have been proposed by Tibshirani <italic>et al.</italic> [<xref ref-type="bibr" rid="c13">13</xref>], Jeffries [<xref ref-type="bibr" rid="c14">14</xref>] and Tracy <italic>et al.</italic> [<xref ref-type="bibr" rid="c15">15</xref>]. Tibshirani&#x2019;s algorithm uses a clustering algorithm to align peaks present in multiple spectra and picks them for further statistical analyses. However, it does not address the problem of inter-batch variations, unlike the algorithms proposed in this article. Jeffries&#x2019; algorithm is more appropriate for this problem. This method uses cubic splines to recalibrate spectra, based on the shifts between observed peaks and known reference masses. By contrast, we propose an algorithm that does not require references for repositioning. A similar algorithm has been proposed by Barry <italic>et al.</italic> for Fourier-Transform Mass Spectrometry [<xref ref-type="bibr" rid="c16">16</xref>]. This approach uses ambient ions in order to correct the spectra, once again using known reference masses. Another algorithm of interest for MALDI-ToF spectra has been proposed by Tracy <italic>et al.</italic> [<xref ref-type="bibr" rid="c15">15</xref>]. In this case, commonly occurring peaks within the dataset are used to correct the spectra and determine the binning distance used. This method however computes a single constant correction factor for the entire spectrum. The method we propose, by contrast, computes correction factors that vary across the <italic>m/z</italic> axis of the spectra in order to obtain a more accurate correction.</p>
<p>The algorithms proposed in this article aim to render spectra more comparable prior to peak selection and statistical analyses. The correction algorithm proposed was inspired by the internal lock masses approach. It does not require the use of an internal or external lock mass but they would enhance the algorithms potential. The idea the algorithms exploits is that a set of spectra of the same nature (i.e. blood plasma samples, urine samples, etc.) will contain numerous compounds that are always present. For example, human blood plasma will contain such compounds as glucose and amino acids. [<xref ref-type="bibr" rid="c17">17</xref>]. In the case of urine, it is expected that urea, creatinine, citric acid and many more will always be present in some quantity [<xref ref-type="bibr" rid="c18">18</xref>]. These points called &#x201C;virtual lock masses&#x201D; can even come from ambient ions such as solvent or gas ions. This idea is similar to the one proposed by Barry <italic>et al.</italic> [<xref ref-type="bibr" rid="c16">16</xref>] but does not limit the possibilities to ambient ions. By detecting these &#x201C;virtual Lock Masses&#x201D; (VLM), tens to hundreds of peaks can be used as reference points to re-align the spectra and reduce inter-batch variations. Furthermore, a slight adjustment to the algorithm to detect these reference points allows for it to become an alignment algorithm. This algorithm will align and select peaks within a sliding window on the <italic>m/z</italic> axis and allow to discover every point on the <italic>m/z</italic> axis that does not present ambiguities in the <italic>m/z</italic> window, such as multiple peaks coming from the same spectrum.</p>
</sec>
<sec id="s2">
<title>Results</title>
<sec id="s2a">
<title>Comparison of VLMs</title>
<p>A first experiment was conducted on the Days Dataset in order to find if the same virtual lock masses are detected among similar datasets, and within parts of the same dataset. The VLM detection algorithm was independently applied to 1) every spectra in the dataset, to 2) only the spectra acquired on the first day, and to 3) only the spectra acquired on the second day. The detected VLMs were then compared in the following manner. We define that if we have two sets of spectra <italic>A</italic> and <italic>B</italic>, their detected VLMs will be <inline-formula><alternatives><inline-graphic xlink:href="292425_inline1.gif"/></alternatives></inline-formula> and <inline-formula><alternatives><inline-graphic xlink:href="292425_inline2.gif"/></alternatives></inline-formula>. Each element of <inline-formula><alternatives><inline-graphic xlink:href="292425_inline3.gif"/></alternatives></inline-formula> is a VLM <italic>v<sub>A</sub></italic> that is composed of a peak per spectrum from the spectra in <italic>A</italic>. If <italic>B</italic> &#x2282; <italic>A</italic>, then a VLM <inline-formula><alternatives><inline-graphic xlink:href="292425_inline4.gif"/></alternatives></inline-formula> and a VLM <inline-formula><alternatives><inline-graphic xlink:href="292425_inline5.gif"/></alternatives></inline-formula> are homologous if the peaks forming <italic>v<sub>B</sub></italic> are a subset of the peaks forming <italic>v<sub>A</sub></italic>. Additionally, we can define comparisons between VLMs of subsets of <italic>A</italic>. If we have sets of spectra <italic>A</italic>,<italic>B</italic> and <italic>C</italic>, where <italic>B</italic> &#x2282; <italic>A</italic> and <italic>C</italic> &#x2282; <italic>A</italic>, then we can define that VLMs <italic>v<sub>B</sub></italic> and <italic>v<sub>C</sub></italic> are homologous if <italic>v<sub>B</sub></italic> if homologous to <italic>v<sub>A</sub></italic> and <italic>v<sub>C</sub></italic> is homologous to <italic>v<sub>A</sub></italic>.</p>
<p>The VLM detection algorithm (presented in the Methods section) was applied to only the spectra acquired on the first day, then only the spectra acquired on the second day, and finally on all spectra. The algorithm was applied with the same window size of 40 ppm in all cases. This window size was determined by the procedure described in the Methods section, being the <italic>w</italic> that yielded the largest number of isolated VLMs on the entire dataset. The algorithm detected 113 VLMs, 148 VLMs, and 118 VLMs, respectively in all spectra, the first day spectra, and the second day spectra.</p>
<p>We have compared the peak groups forming the VLMs in all spectra with the spectra acquired on the first day, and saw that the 113 VLMs detected on all spectra have homologues in the set of 148 VLMs detected on the first day. Conversely, we observed that the 113 VLMs also have homologues within the set of 118 VLMs detected in the spectra acquired on the second day.</p>
<p>We have also compared the <italic>m/z</italic> values of the VLM points between the three sets of VLMs. We have found a mean difference of 31.38 &#x00B1; 1.03 ppms (in absolute values) between the <italic>m/z</italic> values of the VLMs detected on the first day and those detected on the second day. The maximum difference is 33.17 ppms, and the minimum is 27.24 ppms. We have also found a mean difference of 15.68 &#x00B1; 0.54 ppms between the <italic>m/z</italic> values of the VLMs detected on the first day and those detected on all spectra (with all the differences localized between 16.50 and 13.32 ppms). Finally, the comparison of the VLMs detected on the second day with those detected on all spectra yielded a mean difference is of 15.71 &#x00B1; 0.53 ppms (with all the differences localized between 16.67 and 13.93 ppms).</p>
<p>Thus, the algorithm behaves as expected on multiple batches of samples acquired days apart and with the instrument re-calibrated in the meantime.</p>
</sec>
<sec id="s2b">
<title>Machine Learning</title>
<p>Machine learning experiments were run on three datasets. These experiments were conducted in order to evaluate the effect of the proposed algorithms on a statistical analysis and on the comparability of mass spectra. From these datasets, we designed four binary classification tasks. Two tasks were on the Clomiphene-Acetaminophen Dataset. A first task was to predict if clomiphene was added to the plasma sample or not. Similarly, the second task consisted of predicting whether acetaminophen was added in a sample. A third task was applied to the Malaria Dataset. In this case, the objective was to predict if the red blood cell sample was infected by malaria. The third dataset is the Cancer Dataset, and the fourth task consisted of predicting whether the sample came from a cancer patient or a healthy patient.</p>
<p>Multiple machine learning algorithms were applied to the spectra. The first algorithm used is the AdaBoost ensemble method [<xref ref-type="bibr" rid="c19">19</xref>]. This method learns a weighted majority vote on a set of simple classifiers, which in our case are decision stumps on alignment point intensities. We also used the Decision Tree Classifier known as CART [<xref ref-type="bibr" rid="c20">20</xref>]. This algorithm builds a tree structure of different rules that classify the samples. In our case, the rules are (again) decision stumps on alignment point intensities. An advantage of this method is the sparsity and the interpretability of its solution. The Set Covering Machine (SCM) was also used for classification [<xref ref-type="bibr" rid="c21">21</xref>]. The SCM classifies samples with a conjunction or disjunction of few boolean rules (here, decision stumps on alignment point intensities). The resulting classifier is often sparser than the one returned by CART. Finally, a Support Vector Machine (SVM) [<xref ref-type="bibr" rid="c22">22</xref>] on alignment point intensities was also used with a linear kernel, along with a L1 norm regularization to ensure that the SVM classifier will assign weights to fewer features and thus will be sparser than a conventional L2-regularized SVM. We used the Scikit-learn implementations for AdaBoost, CART, and the L1-regularized SVM [<xref ref-type="bibr" rid="c23">23</xref>]; whereas we used our own implementation of the SCM. This implementation is available at <ext-link ext-link-type="uri" xlink:href="https://github.com/aldro61/pyscm">https://github.com/aldro61/pyscm</ext-link>.</p>
<p>For each experiment, the spectra were split into a training set and a test set. For the Clomiphene-Acetaminophen and the Cancer Datasets, the test set consisted of 50 randomly selected samples, and the remaining 142 examples were used for the training set. In the case of the Malaria Dataset, the test set consisted of 100 randomly selected samples, and the remaining 234 examples were used for the training set. The hyper-parameters of each learning algorithm were chosen by 5-fold cross-validation on the training set. Each machine learning experiment was repeated 10 times independently on re-sampled test sets.</p>
<p>Two different experimental protocols were tested. First, the correction and alignment algorithms were applied in the transductive learning setting [<xref ref-type="bibr" rid="c24">24</xref>]. In this setting, the whole dataset, prior to being split into a training set and testing set, is exposed to the pipeline of proposed algorithms (VLM detection &#x002B; VLM correction &#x002B; alignment point detection). The training and testing sets are then split randomly. Each training and testing instance (input example) consists of the set of intensities on the alignment points. The second experimental protocol was conducted as the inductive learning setting, in which the pipeline of proposed algorithms were only applied to the training set. Hence the set of alignment points is found from the training set only. Again, each training and testing instance consists of the set of intensities on the alignment points. For the inductive learning protocol, the percentile parameter of the alignment algorithm is considered an hyper-parameter and is thus cross-validated on the training set. For the transductive learning protocol, the percentile parameter is set at 95&#x0025;.</p>
<p>For each dataset, we compare the performance of classifiers if only binning was applied, if the VLM correction was applied and then binning, or if the VLM correction and alignment algorithms were applied. Binning is a commonly used technique in mass spectrometry analysis [<xref ref-type="bibr" rid="c25">25</xref>]. It consists in grouping peaks and intensities found in a larger bin on the <italic>m/z</italic> axis into a single point or peak.</p>
<p><xref rid="tbl1" ref-type="table">Table 1</xref> shows the results of the machine learning experiments in the transductive setting for different datasets. Let us first consider the case of the clomiphene detection problem in the Clomiphene-Acetaminophen Dataset. In all conditions, we observe excellent results, with accuracies over 90&#x0025; in almost every case. However, we know that the solution to this problem is the appearance of a single additional molecule and its fragments in the spectra, since a solution of water and clomiphene is added in the plasma samples. Thus, it is expected that a single peak (feature) should be sufficient to classify the spectra. Considering this information, we see that a single peak is used for classification only when applying the VLM correction and alignment algorithms when using the Decision Tree and SCM. We also see a decrease in the number of features used for the AdaBoost classifier when using the VLM correction and alignment algorithms. In the case of the L1-regularized SVM, the sparsest solution (with an average of 2.6 features used) was obtained when the VLM correction algorithm was applied in addition to binning.</p>
<table-wrap id="tbl1" orientation="portrait" position="float">
<label>Table 1.</label>
<caption><p>Machine learning results in the transductive setting. The percentage in each column is the average accuracy of classifiers on 10 repeats of the experiment. The number shown in parentheses is the average number of features used by the classifiers.</p></caption>
<graphic xlink:href="292425_tbl1.tif"/>
</table-wrap>
<p>Consider now the results for acetaminophen detection on the same dataset. In this case, an acetaminophen pill was added to the blood plasma samples. Thus, it is expected that multiple molecules and their fragments appear in the spectra in this case, at extremely high concentration not normally found in physiological blood plasma. It is then not surprising that most algorithms can identify acetaminophen with the use of a singe feature (peak). Note that in the case of the L1-regularized Support Vector Machine, the best results, both in terms of accuracy and sparsity, are obtained when the VLM correction and alignment algorithms were used.</p>
<p>The next two datasets represent more realistic problems with unknown solutions. For the Malaria dataset, the task is to identify the samples that are infected by malaria. For each algorithm, applying the VLM correction algorithm yields an increase in prediction accuracy. For the AdaBoost classifier, we observe an increase of about 1&#x0025; and the best sparsity in the case of the VLM correction applied before binning, with a slight increase in accuracy with the alignment algorithm. The Decision Tree classifier increases its accuracy by approximately 5&#x0025; with the VLM correction algorithm, both with alignment and with binning. We see a similar increase in accuracy for the Set Covering Machine in the case of VLM correction with binning. Finally, the L1-regularized SVM obtains a 3&#x0025; increase in accuracy with the VLM correction algorithm applied, and a better sparsity.</p>
<p>Finally, let us consider the results on the Cancer Dataset. This classification problem is much harder, with few machine learning algorithms having a prediction accuracy over 70&#x0025;. Still, both the AdaBoost and Decision Tree classifiers have similar results in all cases, with slight losses in accuracy but improved sparsity with the proposed algorithms applied. The Set Covering Machine sees its accuracy increased by 4&#x0025; with both correction and alignment algorithms applied and with comparable sparsity. However, in the case of the L1-regularized SVM, the classifier accuracy increases of almost 20&#x0025; with the proposed algorithms compared to binning only.</p>
<p>In <xref rid="tbl2" ref-type="table">Table 2</xref>, we compare the effect of using the proposed algorithms in the transductive setting versus the inductive setting. On the clomiphene-acetaminophen dataset, there is very little difference between the two approaches for both clomiphene detection and acetaminophen detection. The inductive setting yields slightly sparser classifiers, but the results are very similar. For the malaria detection problem, the difference in sparsity is not significant for the Decision Tree and Set Covering Machine algorithms. The AdaBoost classifier is sparser for the inductive setting, while the L1 SVM has a significant advantage in the transductive setting. The results are also very similar in terms of accuracy for both settings, with very slightly better accuracies in the transductive setting. Finally, the transductive setting appears to be the best setting for cancer detection. The AdaBoost classifier is sparser in this case, with a slight decrease in accuracy. The Decision Tree and Set Covering Machine have better accuracies in the transductive setting, though the SCM is sparser in the inductive setting. The L1-regularized SVM is, on the other hand, much more accurate and slightly sparser in the transductive setting, with an increase in accuracy of about 6&#x0025;.</p>
<table-wrap id="tbl2" orientation="portrait" position="float">
<label>Table 2.</label>
<caption><p>Comparison of transductive and inductive learning of the VLM and Alignment algorithms</p></caption>
<graphic xlink:href="292425_tbl2.tif"/>
</table-wrap>
<p>Finally, and perhaps not surprisingly, we can see (for AdaBoost and L1-SVM) that cancer and malaria detection need far more features then clomiphene and acetaminophen detection.</p>
</sec>
<sec id="s2c">
<title>Cross Validation of Virtual Lock Masses</title>
<p>The algorithm for VLM detection was also cross-validated on the Days Dataset and the Clomiphene-Acetaminophen Dataset. Each dataset was randomly split into <italic>k</italic> folds. The VLM detection algorithm was applied to the first <italic>k</italic> &#x2212; 1 folds, the training folds. The detected VLMs on the training folds are then used for VLM correction of the spectra in last remaining fold, the testing fold. When the correction is applied, we note if every VLM is found in the spectra of the testing fold. The algorithm is scored according to the ratio of detected VLMs on the training folds that are also found in the testing fold. This process is repeated <italic>k</italic> times so that each fold serves as a test fold once. Multiples values of <italic>k</italic> were used in the experiment, such that <italic>k</italic> &#x2208; {3, 5, 8, 10, 15, 20}.</p>
<p>In each case, we found that <italic>every</italic> VLM point detected on the training set was detected on the testing set. This thus results in a ratio of VLMs found in the testing set over the VLMs detected on the training set of 100&#x0025; in all cases. This provides empirical evidence of the stability of VLM points across different sets of spectra.</p>
</sec>
<sec id="s2d">
<title>Learning Curves</title>
<p>A learning curve experiment was performed in order to evaluate the behavior of the VLM detection and correction algorithms on varying numbers of samples. In a first step, the VLM detection algorithm followed by the VLM correction algorithm was performed on the whole set of spectra. 25 spectra were randomly selected as a test set. These test spectra will be considered the &#x201C;ground truth&#x201D;, i.e., the best correction that the algorithm can achieve for these 25 spectra.</p>
<p>The algorithm was subsequently applied once again to a number of spectra. The number of spectra the algorithm was exposed to was gradually increased, from 10 spectra to 160 spectra. At each point, the uncorrected test spectra are corrected and compared to the ground truth spectra. The difference in <italic>m/z</italic> value between the homologous peaks is calculated in ppm. Then, the difference is squared and summed for all test spectra. Finally, this sum is divided by the number of peaks in the test spectra and the square root is taken. The difference in correction is thus expressed as the Root Mean Squared Error (RMSE) in ppm units for each peak. This experiment was repeated 50 times, with randomly re-sampled test sets, in order to obtain statistically significant results.</p>
<p><xref rid="fig1" ref-type="fig">Fig 1</xref> shows the learning curves obtained on three different datasets. In each case, the trends is similar. When sub-sampling a low number of spectra as a training set for the VLM detection and correction algorithms, a higher number of lock masses is found. As the number of training spectra increases, the number of virtual lock masses found diminishes and starts to plateau near the number of lock masses found in the whole dataset. This is explained by the fact that when few spectra are in the training set, there is a higher number of candidates. As new spectra are added in the training set, there is a probability that one of the new spectra are missing at least one peak that was previously considered a virtual lock mass. These peaks could be missing because of strong noise, either on the <italic>m/z</italic> axis or in terms of intensity, rendering its intensity too small to be considered a VLM. A peak could also be missing simply because the compound or fragment generating that peak is not present in all samples.</p>
<fig id="fig1" position="float" fig-type="figure">
<label>Fig 1.</label>
<caption><title>Learning Curves of Virtual Lock Mass Detection and Correction.</title>
<p>Subfigures (A), (B) and (C) show the learning curves for three different datasets (Days, Clomiphene-Acetaminophen, Malaria). Subfigure (D) shows the RMSE of VLM Correction for these datasets.</p></caption>
<graphic xlink:href="292425_fig1.tif"/>
</fig>
<p>The same trend is found in all three datasets for the Root Mean Squared Error (RMSE) in Subfigure (D). The error is initially high when few spectra are in the training set, but as more spectra are added in the training set it gradually decreases. In the case of the Days Dataset, the final average RMSE when using 160 spectra to train the algorithm is 0.56 ppms. For the other two datasets (Clomiphene-Acetaminophen and Malaria), the final RMSEs are approximately 1.10 ppms. In each case, the RMSE drops under 2.0 ppms when using 100 spectra or more to train the correction algorithm. In conjunction with the results of inductive learning shown above, these results suggest that the VLM detection and correction algorithms can generalize the virtual lock masses and correction it learns to unseen spectra of the same nature, such as those of a new test set.</p>
</sec>
</sec>
<sec id="s3">
<title>Discussion</title>
<p>The algorithms proposed in this article aim to render mass spectra more comparable for large datasets acquired in single or multiple batches. The VLM detection algorithm is stable and detects virtual lock masses reliably in datasets. It also detects peaks that are present in mass spectra of the same type but that are not part of the training set. In addition, applying the proposed pipeline of algorithms (VLM detection &#x002B; VLM correction &#x002B; alignment point detection) on sets of mass spectra before statistical and machine learning analyses generally yields classifiers with increased accuracy and sometimes with increased sparsity, leading to interpretable models that could serve for biomarker discovery. The proposed pipeline of algorithms has a very low running time complexity of <italic>O</italic>(<italic>n</italic> log <italic>m</italic>) for a collection of <italic>m</italic> spectra containing a total of <italic>n</italic> peaks which, as argued, cannot be surpassed by algorithms based on clustering (with the current state of knowledge).</p>
<p>However, the algorithms, as presented, have a number of drawbacks. Since the virtual lock masses are assigned the average <italic>m/z</italic> value of the peaks associated to it, the correction algorithm does not correct the peaks to the exact <italic>m/z</italic> value of the ion. The alignment algorithm has also the same property. However, the virtual lock mass approach is compatible with any external lock masses added to the spectra. Thus, by applying both methods, any shift away from the exact (and known) <italic>m/z</italic> value of an external lock mass can be corrected. Some situations are also unsuitable for the proposed algorithms. In order for the VLM detection algorithm to function properly and detect virtual lock masses, the mass spectra forming the dataset must be of the same &#x201C;nature&#x201D; so that the algorithm can detect a sufficient number of peaks that are common to all spectra. Additionally, the correction algorithm works best in a situation where there are more peaks than spectra. In the cases where each spectrum contains very few peaks, there is a much lower probability that that algorithm can find peaks present in all spectra of the set.</p>
<sec id="s3a">
<title>Future works</title>
<p>The algorithms, as presented here, can only be applied to mass spectra represented by a list of peaks of the form (<italic>&#x00B5;, &#x03B9;</italic>) where <italic>&#x00B5;</italic> is the <italic>m/z</italic> value of the peak and <italic>&#x03B9;</italic> its intensity. Hence, the algorithms are currently not applicable with mass spectra having additional dimensions for the peaks, such as ion mobility. It is also not applicable to chromatogram where multiple mass spectra are acquired over time for a single sample and where each spectra contains different peaks due to the chromatographic separation. It is thus relevant to investigate if the proposed approach, based on virtual lock masses, can be extended to incorporate these extra dimensions.</p>
</sec>
</sec>
<sec id="s4">
<title>Materials and methods</title>
<p>In this section, we present the mathematical basis of the proposed methodology. First, the problem of virtual lock-mass identification is addressed. A formal definition of VLM peaks is introduced, along with an highly efficient algorithm capable of identifying such peaks in a set of mass spectra. Second, a methodology for correcting mass spectra based on a set of identified virtual lock masses is described. Thirdly, an algorithm for mass spectra alignment based on the previous algorithm is proposed. Finally, the datasets used and the experimental methodologies are presented.</p>
<sec id="s4a">
<title>Definitions</title>
<p>Let us first recall that a <italic>set</italic> is an un-ordered collection of elements whereas a <italic>sequence</italic> is an ordered collection of elements. Hence, in a sequence we have a first element, a second element, and so on. If <italic>A</italic> is a sequence or a set, |<italic>A</italic>| denotes the number of elements in <italic>A</italic>.</p>
<p>Let <inline-formula><alternatives><inline-graphic xlink:href="292425_inline6.gif"/></alternatives></inline-formula> be a sequence of mass spectra. Each spectrum <italic>S<sub>i</sub></italic> is a sequence of peaks, where each peak is a pair (<italic>&#x00B5;, &#x03B9;</italic>) with an <italic>m/z</italic> value <italic>&#x00B5;</italic> and a peak intensity <italic>&#x03B9;</italic>.</p>
<p>We will use intervals that are centered on a peak that are measured in units relative to the <italic>m/z</italic> value of the peak. Hence, a <italic>window</italic> of size 2<italic>w</italic> centered on peak (<italic>&#x00B5;, &#x03B9;</italic>) covers the <italic>m/z</italic> interval that starts at <italic>&#x00B5;</italic>(1 &#x2212; <italic>w</italic>) and ends at <italic>&#x00B5;</italic>(1 &#x002B; <italic>w</italic>). In that case, we say that the window size parameter <italic>w</italic> is expressed in <italic>relative units</italic>. The reason for using window sizes in relative units follows from the fact that the <italic>m/z</italic> uncertainty of ToF mass spectrometers increases linearly with the <italic>m/z</italic> value of a peak. This is also confirmed by our experiments (<xref rid="fig3" ref-type="fig">Figure (3)</xref> displayed in the subsection <italic>From VLM correction to spectra alignment</italic>). Moreover, we are normally interested in values for <italic>w</italic> that typically lie within the range from 10<sup><italic>&#x2212;</italic>6</sup> to 10<sup><italic>&#x2212;</italic>5</sup>. When <italic>w</italic> &#x003D; <italic>z</italic> &#x00D7; 10<sup><italic>&#x2212;</italic>6</sup>, it is customary to write that <italic>w</italic> &#x003D; <italic>z</italic> ppm.</p>
<fig id="fig3" position="float" fig-type="figure">
<label>Fig 3.</label>
<caption><title>Error in ppm versus mass units.</title>
<p>Subfigure (A) shows the error on left-out VLMs in ppms, while Subfigure (B) shows the error in Daltons.</p></caption>
<graphic xlink:href="292425_fig3.tif"/>
</fig>
<p>Given a sequence S of mass spectra and a window size parameter <italic>w</italic> expressed in relative units, a <italic>virtual lock mass</italic> (VLM) with respect to <inline-formula><alternatives><inline-graphic xlink:href="292425_inline7.gif"/></alternatives></inline-formula> is a point <italic>v</italic> on the <italic>m/z</italic> axis such that there exists a sequence <inline-formula><alternatives><inline-graphic xlink:href="292425_inline8.gif"/></alternatives></inline-formula> of peaks from <inline-formula><alternatives><inline-graphic xlink:href="292425_inline9.gif"/></alternatives></inline-formula> that satisfies the following properties</p>
<list list-type="order">
<list-item><p><inline-formula><alternatives><inline-graphic xlink:href="292425_inline10.gif"/></alternatives></inline-formula> contains exactly one peak from each spectrum in <inline-formula><alternatives><inline-graphic xlink:href="292425_inline11.gif"/></alternatives></inline-formula>.</p></list-item>
<list-item><p>The average of the <italic>m/z</italic> values of the peaks in <inline-formula><alternatives><inline-graphic xlink:href="292425_inline12.gif"/></alternatives></inline-formula> is equal to <italic>v</italic>.</p></list-item>
<list-item><p>Every peak in <inline-formula><alternatives><inline-graphic xlink:href="292425_inline13.gif"/></alternatives></inline-formula> has a <italic>m/z</italic> value located in the interval [<italic>v</italic>(1 &#x2212; <italic>w</italic>), <italic>v</italic>(1 &#x002B; <italic>w</italic>)].</p></list-item>
<list-item><p>No other peak in <inline-formula><alternatives><inline-graphic xlink:href="292425_inline14.gif"/></alternatives></inline-formula> has an <italic>m/z</italic> value that belongs to [<italic>v</italic>(1 &#x2212; <italic>w</italic>), <italic>v</italic>(1 &#x002B; <italic>w</italic>)].</p></list-item>
<list-item><p>Every peak in <inline-formula><alternatives><inline-graphic xlink:href="292425_inline15.gif"/></alternatives></inline-formula> has an intensity superior to a threshold <italic>t</italic>.</p></list-item></list>
<p>Whenever these criteria are satisfied, we say that <inline-formula><alternatives><inline-graphic xlink:href="292425_inline16.gif"/></alternatives></inline-formula> is the sequence of peaks associated to the VLM <italic>v</italic>.</p>
<p>The threshold on intensity <italic>t</italic> is added as a criterion because a peak with a higher intensity will tend to have a higher mass accuracy. Hence, in principle, a VLM is defined only with respect to (w.r.t.) (<inline-formula><alternatives><inline-graphic xlink:href="292425_inline17.gif"/></alternatives></inline-formula>, <italic>w, t</italic>). However, we will drop the reference to <italic>t</italic> to simplify the notation.</p>
<p>A crucial aspect of the definition of VLM is the fact that it holds only w.r.t. a given value of a window size <italic>w</italic>. Indeed, consider <xref rid="fig2" ref-type="fig">Fig (2)</xref> which represents the peaks coming from three different spectra. We clearly see a grouping within a window size <italic>w</italic><sub>1</sub>. Hence, this set of 3 spectra identifies 4 VLM points w.r.t. <italic>w</italic><sub>1</sub>. Note that we could not unambiguously define a VLM point as a sequence of <inline-formula><alternatives><inline-graphic xlink:href="292425_inline18.gif"/></alternatives></inline-formula> peaks (without referring to a window size) since, in that case, the peaks surrounded by window <italic>w</italic><sub>2</sub> would also qualify as being a VLM and, consequently and ambiguously, each peak would belong to more than one VLM. Note that if the chosen window size is too large, as it is the case for <italic>w</italic><sub>2</sub>, then the different VLM sequences will overlap. If the chosen window size is too small (i.e. smaller than <italic>w</italic><sub>1</sub>), we will have no VLM point. If it is too large however, we will see too many but, in this case, they will overlap and we can thus identify that case. Hence, this motivates the following definition of overlapping VLM points. Given <inline-formula><alternatives><inline-graphic xlink:href="292425_inline19.gif"/></alternatives></inline-formula>, a VLM <italic>v<sub>i</sub></italic> w.r.t. (<inline-formula><alternatives><inline-graphic xlink:href="292425_inline20.gif"/></alternatives></inline-formula> is said to <italic>overlap</italic> with another VLM <italic>v<sub>j</sub></italic> (with respect to <inline-formula><alternatives><inline-graphic xlink:href="292425_inline21.gif"/></alternatives></inline-formula>) if and only if there exists a non empty intersection between the <italic>m/z</italic> interval [<italic>v<sub>i</sub></italic>(1 &#x2212; <italic>w</italic>), <italic>v<sub>i</sub></italic>(1 &#x002B; <italic>w</italic>)] and the <italic>m/z</italic> interval [<italic>v<sub>j</sub></italic>(1 &#x2212; <italic>w</italic>), <italic>v<sub>j</sub></italic>(1 &#x002B; <italic>w</italic>)]. Moreover, we say that a VLM <italic>v</italic> w.r.t. (<inline-formula><alternatives><inline-graphic xlink:href="292425_inline22.gif"/></alternatives></inline-formula>, <italic>w</italic>) is <italic>isolated</italic> from all all other VLM with w.r.t. <inline-formula><alternatives><inline-graphic xlink:href="292425_inline23.gif"/></alternatives></inline-formula> if and only if there does not exists any other VLM <italic>v<sup>i</sup></italic> w.r.t. <inline-formula><alternatives><inline-graphic xlink:href="292425_inline24.gif"/></alternatives></inline-formula> that overlaps with <italic>v</italic>. For a given window size <italic>w</italic>, the algorithm that we present in the next subsection identifies <italic>all</italic> isolated VLM points w.r.t. <inline-formula><alternatives><inline-graphic xlink:href="292425_inline25.gif"/></alternatives></inline-formula>. Consequently, the best value for <italic>w</italic> is one for which the number of isolated VLM points is the largest.</p>
<fig id="fig2" position="float" fig-type="figure">
<label>Fig 2.</label>
<caption><title>Peaks coming from three different spectra</title>
<p>(identified as 1, 2, and 3).</p></caption>
<graphic xlink:href="292425_fig2.tif"/>
</fig>
</sec>
<sec id="s4b">
<title>An Algorithm for Virtual Lock Mass Identification</title>
<p>Given a sequence <inline-formula><alternatives><inline-graphic xlink:href="292425_inline26.gif"/></alternatives></inline-formula> of <italic>m</italic> spectra, each peak is identified by a pair (<italic>&#x03C3;, &#x03C1;</italic>) where <italic>&#x03C3;</italic> &#x2208; {1, <italic>&#x2026;,m</italic>} is the index of its spectrum of origin and <italic>&#x03C1;</italic> &#x2208; {1<italic>,&#x2026;,n<sub>&#x03C3;</sub></italic>} is the index of the peak in spectrum <italic>S<sub>&#x03C3;</sub></italic> containing <italic>n<sub>&#x03C3;</sub></italic> peaks. Given that we have a total of <italic>n</italic> peaks in <inline-formula><alternatives><inline-graphic xlink:href="292425_inline27.gif"/></alternatives></inline-formula>, we have that <inline-formula><alternatives><inline-graphic xlink:href="292425_inline28.gif"/></alternatives></inline-formula>. For the description of the algorithm, <italic>&#x00B5;</italic>(<italic>&#x03C3;, &#x03C1;</italic>) denotes the <italic>m/z</italic> value of peak (<italic>&#x03C3;, &#x03C1;</italic>). Finally, we assume that the peaks in each spectra <italic>S<sub>i</sub></italic> are listed in increasing order of their <italic>m/z</italic> values.</p>
<p>The proposed algorithm uses two data structures: a <italic>binary heap</italic> and a so-called <italic>active sequence</italic>. A binary heap is a classical data structure used for priority queues which are useful when one wants to efficiently remove the element of highest priority in a queue. In our case, the heap will maintain, at any time, the next peak of each spectra to be processed by the algorithm. Hence, given a sequence <inline-formula><alternatives><inline-graphic xlink:href="292425_inline29.gif"/></alternatives></inline-formula> of <italic>m</italic> spectra, the heap generally contains a set of <italic>m</italic> peaks, where each peak belongs to a different spectrum of <inline-formula><alternatives><inline-graphic xlink:href="292425_inline30.gif"/></alternatives></inline-formula>. The &#x201C;priority value&#x201D; for each peak (<italic>&#x03C3;, &#x03C1;</italic>) in the heap is given by its <italic>m/z</italic> value <italic>&#x00B5;</italic>(<italic>&#x03C3;, &#x03C1;</italic>); a peak with the smaller mass is always on top of the heap. Given a sequence <inline-formula><alternatives><inline-graphic xlink:href="292425_inline31.gif"/></alternatives></inline-formula> of <italic>m</italic> mass spectra, a heap <italic>H</italic> containing the first peak of each spectrum can be constructed in <italic>O</italic>(<italic>m</italic>) time. Moreover, we can read the <italic>m/z</italic> value at the top of the heap in constant time; we can remove the peak (<italic>&#x03C3;, &#x03C1;</italic>) of the top of the heap and replace it with the next available peak in the spectrum <italic>S<sub>&#x03C3;</sub></italic> in <italic>O</italic>(log <italic>m</italic>) time <sup>1</sup>.</p>
<p>The second data structure is, what we call, the <italic>active sequence A</italic>. At any time, <italic>A</italic> contains a sequence of peaks, listed in increasing order of their <italic>m/z</italic> values, which are currently being considered to become a VLM sequence. That data structure uses a doubly linked list <italic>L</italic> and a boolean-valued vector <italic>B</italic> of dimension <italic>m</italic>. The linked list <italic>L</italic> is actually containing the sequence of peaks to be considered for the next VLM and the vector <italic>B</italic> is such that, at any time, <italic>B</italic>[<italic>&#x03C3;</italic>] &#x003D; <italic>True</italic> if and only if a peak from spectrum <italic>S<sub>&#x03C3;</sub></italic> is present in <italic>L</italic>. The active sequence <italic>A</italic> also maintains the <italic>m/z</italic> value <italic>&#x00B5;<sub>l</sub></italic> of the last peak that was removed from <italic>L</italic>, the average <italic>m/z</italic> value <italic>&#x00B5;<sub>A</sub></italic> of the peaks in <italic>L</italic>, and a copy <italic>w<sub>A</sub></italic> of the window size <italic>w</italic> chosen by the user. Since <italic>L</italic> is a linked list, we can read the front (first) and back (last) values of <italic>L</italic> in constant time, as well as obtaining its size (number of peaks). Removing the value at the front of <italic>L</italic> is also performed in constant time. We now present a short description of the algorithm for virtual lock mass identification. The detailed description is provided in Supplementary Information 1.</p>
<sec id="s4b1">
<title>Validation of an active sequence</title>
<p>For this step, we use a method, call <italic>A.isValid</italic>(), that returns <italic>True</italic> if and only if the peaks in the active sequence <italic>A</italic> satisfies all the criteria enumerated in the definition of a VLM. A precondition for the validity of this method is that <italic>L</italic> contains only peaks that belong to distinct spectra of <inline-formula><alternatives><inline-graphic xlink:href="292425_inline32.gif"/></alternatives></inline-formula>. This precondition holds initially for an empty list <italic>L</italic> and will always be enforced each time a new peak gets inserted in <italic>A</italic>, as we will see below. Thus, this step of the algorithm checks first that the active sequence contains exactly <inline-formula><alternatives><inline-graphic xlink:href="292425_inline33.gif"/></alternatives></inline-formula> peaks, thus one peak from each spectrum in the set. Then, if there are still peaks in the heap, we verify that the peak at the top of <italic>H</italic> (thus, the peak immediately following the active sequence) has a <italic>m/z</italic> value that is out of the interval [<italic>&#x00B5;<sub>A</sub></italic>(1 &#x2212; <italic>w</italic>), <italic>&#x00B5;<sub>A</sub></italic>(1 &#x002B; <italic>w</italic>)]. Similarly, it is verified that the peak whose <italic>m/z</italic> value immediately precedes the active sequence also has an <italic>m/z</italic> value outside of [<italic>&#x00B5;<sub>A</sub></italic>(1 &#x2212; <italic>w</italic>), <italic>&#x00B5;<sub>A</sub></italic>(1 &#x002B; <italic>w</italic>)]. If either peak lies inside this window, then the property (4) of a VLM is violated, as the window contains more than |S| peaks. Finally, we ensure that the first and last peaks in the active sequence <italic>A</italic> are both within the window [<italic>&#x00B5;<sub>A</sub></italic>(1 &#x2212; <italic>w</italic>), <italic>&#x00B5;<sub>A</sub></italic>(1 &#x002B; <italic>w</italic>)]. If all checks pass, then the current sequence is considered a potential virtual lock mass.</p>
</sec>
<sec id="s4b2">
<title>Advancing the active sequence</title>
<p>This step tries to insert at the end of the list <italic>L</italic> of <italic>A</italic> the peak (<italic>&#x03C3;, &#x03C1;</italic>) located on top of <italic>H</italic>. The insertion succeeds if the resulting <italic>A</italic> still have some probability that the peak sequence can become a VLM after zero or more future insertions. Thus, we first verify if another peak from spectrum <inline-formula><alternatives><inline-graphic xlink:href="292425_inline34.gif"/></alternatives></inline-formula> is present in <italic>A</italic>. If that is the case, then the insertion fails. Otherwise, we compute the new value <italic>&#x00B5;<sup>i</sup>A</italic> that <italic>&#x00B5;<sub>A</sub></italic> will have after the insertion. If the peak at the front of <italic>L</italic> (the peak in <italic>A</italic> having the smallest <italic>m/z</italic> value) and the new peak (<italic>&#x03C3;, &#x03C1;</italic>) have masses that are within the window <inline-formula><alternatives><inline-graphic xlink:href="292425_inline35.gif"/></alternatives></inline-formula>, then the insertion succeeds. The peak is inserted, and <italic>H</italic> is updated by removing the peak (<italic>&#x03C3;, &#x03C1;</italic>) and adding the next peak from the spectrum <inline-formula><alternatives><inline-graphic xlink:href="292425_inline36.gif"/></alternatives></inline-formula>. Thus, this step ensures that we can insert a new peak in <italic>A</italic> and still have some probability that the sequence can become a VLM after zero or more future insertions.</p>
<p>Whenever we have an insertion failure, it means that the active sequence cannot become a valid VLM and that we must remove from <italic>A</italic> the peak having the smallest <italic>m/z</italic> value (which is located in the front of <italic>L</italic>) in order to have a chance that the sequence of peaks in <italic>A</italic> becomes a valid VLM.</p>
</sec>
<sec id="s4b3">
<title>Advancing the lower bound</title>
<p>This step is called to remove the peak (<italic>&#x03C3;, &#x03C1;</italic>) at the front of <italic>L</italic> until a valid insertion can be made. First, it updates <italic>B</italic>[<italic>&#x03C3;</italic>] to <italic>False</italic>, as peak (<italic>&#x03C3;, &#x03C1;</italic>) is about to be removed and no peak from <italic>S<sub>&#x03C3;</sub></italic> will be in the active sequence <italic>A</italic> anymore. The <italic>m/z</italic> value of peak (<italic>&#x03C3;, &#x03C1;</italic>) is copied in <italic>&#x00B5;<sub>l</sub></italic>, and the peak is then removed from <italic>L</italic>. If <italic>L</italic> is empty at this point, its average <italic>m/z</italic> value <italic>&#x00B5;<sub>A</sub></italic> is set to 0. Otherwise, <italic>&#x00B5;<sub>A</sub></italic> is set to the average value of the peaks remaining in the active sequence.</p>
</sec>
<sec id="s4b4">
<title>Removing overlapping virtual lock masses</title>
<p>The final step of the algorithm removes all overlapping VLMs. As described in Appendix 1, a Boolean vector (with a number of components equal to the number of VLMs found) is initialized to <italic>False</italic>. Then, we simply iterate over all the VLM points found and assign the corresponding vector entry to <italic>True</italic> whenever a VLM point (with <italic>m/z</italic> value <italic>&#x00B5;</italic>) is found such that its window [<italic>&#x00B5;</italic>(1 &#x2212; <italic>w</italic>), <italic>&#x00B5;</italic>(1 &#x002B; <italic>w</italic>)] overlaps with that of its neighboring VLMs. Only the VLMs whose entry in the vector is <italic>False</italic> are kept.</p>
</sec>
<sec id="s4b5">
<title>Main algorithm</title>
<p>Having described the data structures used and their methods, we are now in position to present the main algorithm for virtual lock mass detection, which is described by Algorithm (1). The task of this algorithm is to find all the isolated VLM points w.r.t. <inline-formula><alternatives><inline-graphic xlink:href="292425_inline37.gif"/></alternatives></inline-formula>. To achieve this, the central part of the algorithm is to find find the sequence <inline-formula><alternatives><inline-graphic xlink:href="292425_inline38.gif"/></alternatives></inline-formula> of all possible VLM points w.r.t. <inline-formula><alternatives><inline-graphic xlink:href="292425_inline39.gif"/></alternatives></inline-formula>. This sequence may contain several pairs of overlapping VLMs. The strategy to achieve this central task is to use <inline-formula><alternatives><inline-graphic xlink:href="292425_inline40.gif"/></alternatives></inline-formula> to try to insert in <italic>A</italic> (consequently in <italic>L</italic>) the next unprocessed peak of <inline-formula><alternatives><inline-graphic xlink:href="292425_inline41.gif"/></alternatives></inline-formula>, which is always located on the top of the heap <italic>H</italic>. Initially, the first such peak of <inline-formula><alternatives><inline-graphic xlink:href="292425_inline42.gif"/></alternatives></inline-formula>, a peak having the smallest <italic>m/z</italic> value among those in <inline-formula><alternatives><inline-graphic xlink:href="292425_inline43.gif"/></alternatives></inline-formula>, gets eventually inserted in an empty <italic>A</italic> by <inline-formula><alternatives><inline-graphic xlink:href="292425_inline44.gif"/></alternatives></inline-formula>. Next, after verifying with <inline-formula><alternatives><inline-graphic xlink:href="292425_inline45.gif"/></alternatives></inline-formula> if the content of <italic>A</italic> satisfies the criteria to be a valid VLM sequence, we try to insert again in <italic>A</italic> the next available peak. On each insertion failure, we test if, before this insertion, the content of <italic>A</italic> was a valid VLM sequence. This is done with the Boolean variable <italic>found</italic> (which is set to <italic>True</italic> as soon as the content of <italic>A</italic> is a valid VLM sequence and which is set to <italic>False</italic> immediately after the average <italic>m/z</italic> value <italic>&#x00B5;<sub>A</sub></italic> of <italic>A</italic>&#x2019;s content is appended to <inline-formula><alternatives><inline-graphic xlink:href="292425_inline46.gif"/></alternatives></inline-formula>). Hence, for each considered peak in <italic>L.front</italic>(), we try to insert one more peak in <italic>L</italic> and test after the insertion if <italic>L</italic>&#x2019;s content is a valid VLM sequence. If we cannot insert an extra peak in <italic>L</italic> with the current peak in <italic>L.front</italic>() this means that there is no possibility of finding one more VLM sequence with the current peak in <italic>L.front</italic>(). In that case we remove that peak from <italic>L</italic> with <italic>A.advanceLowerBound</italic>() and, consequently, <italic>L.front</italic>() now becomes the peak that was next to <italic>L.front</italic>() in <italic>L</italic>. Hence, with this strategy, the algorithm attempts to find the largest consecutive sub-sequence of peaks from <inline-formula><alternatives><inline-graphic xlink:href="292425_inline47.gif"/></alternatives></inline-formula> that starts with any given peak in <inline-formula><alternatives><inline-graphic xlink:href="292425_inline48.gif"/></alternatives></inline-formula> and that forms a valid VLM sequence<sup>2</sup>. In addition, note that in the <bold>else</bold> branch of Algorithm (1), we verify if <italic>H</italic> becomes empty after a successful insertion. In that case, we need to check if we can find a valid VLM sequence by incrementing sequentially the lower bound <italic>L.front</italic>() and then append to <inline-formula><alternatives><inline-graphic xlink:href="292425_inline49.gif"/></alternatives></inline-formula> the first VLM found. Then, we can safely exit the <bold>while</bold> loop since any other possible VLM sequence will be a subset of the one already found. Without this <bold>else</bold> branch, a VLM sequence that ends with the last peak presented by <italic>H</italic> would be missed by the algorithm. As explained in Appendix 1, the running time of Algorithm (1) (i.e., the VLM detection algorithm) is in <italic>O</italic>(<italic>n</italic> log <italic>m</italic>) for a sequence <inline-formula><alternatives><inline-graphic xlink:href="292425_inline50.gif"/></alternatives></inline-formula> of <italic>m</italic> spectra that contains a total of <italic>n</italic> peaks. This, however, is for a fixed value of window size <italic>w</italic>. Note that in order to obtain the most accurate correction (by interpolation) for the spectra in <inline-formula><alternatives><inline-graphic xlink:href="292425_inline51.gif"/></alternatives></inline-formula>, we should use the largest number of isolated (i.e., non-overlapping) VLMs we can find. Consequently, the optimal value for <italic>w</italic> is the one for which Algorithm (1) will give the largest number of isolated VLMs. Moreover, note that if <italic>w</italic> is too small, very few VLMs will be detected as <italic>w</italic> will not be able to cover exactly one peak per spectra. If, on the other hand, <italic>w</italic> is too large, a large number of the VLMs found in the first phase of the algorithm will overlap and the remaining isolated VLMs will be rare.</p>
<statement>
<label>Algorithm 1</label>
<title>The Virtual Lock Mass Detection Algorithm</title>
<p><fig id="ufig1" position="float" fig-type="figure">
<graphic xlink:href="292425_ufig1.tif"/>
</fig></p>
</statement>
<p>Consequently, because of this &#x201C;unimodal&#x201D; behavior, one can generally find rapidly the best value for <italic>w</italic>. In our case, we never needed to tried more than 20 different values.</p>
</sec>
<sec id="s4b6">
<title>An Algorithm for Virtual Lock Mass Correction</title>
<p>Given a sequence <inline-formula><alternatives><inline-graphic xlink:href="292425_inline52.gif"/></alternatives></inline-formula> of spectra and a widow size parameter <italic>w</italic> expressed in relative units, once the sequence <inline-formula><alternatives><inline-graphic xlink:href="292425_inline53.gif"/></alternatives></inline-formula> of all isolated VLM points w.r.t. <inline-formula><alternatives><inline-graphic xlink:href="292425_inline54.gif"/></alternatives></inline-formula> has been determined, the individual spectra in <inline-formula><alternatives><inline-graphic xlink:href="292425_inline55.gif"/></alternatives></inline-formula> can be corrected in a manner similar as it is usually done with traditional lock masses. Algorithm (2) performs the correction needed for each peak in a spectrum <inline-formula><alternatives><inline-graphic xlink:href="292425_inline56.gif"/></alternatives></inline-formula>.</p>
<statement>
<label>Algorithm 2</label>
<title>Virtual Lock Mass Correction Algorithm</title>
<p><fig id="ufig2" position="float" fig-type="figure">
<graphic xlink:href="292425_ufig2.tif"/>
</fig></p>
</statement>
<p>First, in the <bold>for</bold> loop, we identify each peak of <inline-formula><alternatives><inline-graphic xlink:href="292425_inline57.gif"/></alternatives></inline-formula> corresponding to a lock mass point <inline-formula><alternatives><inline-graphic xlink:href="292425_inline58.gif"/></alternatives></inline-formula>. Since <inline-formula><alternatives><inline-graphic xlink:href="292425_inline59.gif"/></alternatives></inline-formula> is a VLM point w.r.t. <inline-formula><alternatives><inline-graphic xlink:href="292425_inline60.gif"/></alternatives></inline-formula>, we are assured to find exactly one such peak <italic>p<sub>j</sub></italic> &#x2208; <italic>S</italic> with an observed <italic>m/z</italic> value of <italic>&#x00B5;<sub>j</sub></italic> such that <italic>&#x00B5;<sub>j</sub></italic> lies in the interval [(1 &#x2212; <italic>w</italic>)<italic>v<sub>i</sub>,</italic> (1 &#x002B; <italic>w</italic>)<italic>v<sub>i</sub></italic>]. For such <italic>&#x00B5;<sub>j</sub></italic>, we assign the index <italic>j</italic> to <italic>&#x03B1;<sub>i</sub></italic> so that <italic><bold>&#x03B1;</bold></italic> &#x003D; (<italic>&#x03B1;</italic><sub>1</sub>, <italic>&#x2026;, &#x03B1;<sub>n</sub></italic>) is a vector of <italic>n</italic> indexes, each pointing to the peak in <italic>S</italic> associated to a VLM point.</p>
<p>Note that for <italic>&#x00B5;<sub>j</sub></italic> &#x2208; [(1 &#x2212; <italic>w</italic>)<italic>v<sub>i</sub>,</italic> (1 &#x002B; <italic>w</italic>)<italic>v<sub>i</sub></italic>], its corrected <italic>m/z</italic> value must be equal to <italic>v<sub>i</sub></italic>. Instead of performing these corrections immediately in the <bold>for</bold> loop, we delay them to the linear interpolation <italic>&#x03B1;</italic><sub>1</sub> &#x2264; <italic>j</italic> &#x2264; <italic>&#x03B1;<sub>n</sub></italic> will be corrected.</p>
<p>Next, for each VLM <italic>v<sub>i</sub></italic>, we correct by linear interpolation all the <italic>m/z</italic> values <italic>&#x00B5;<sub>j</sub></italic> such that <italic>&#x03B1;<sub>i</sub></italic> &#x2264; <italic>j</italic> &#x2264; <italic>&#x03B1;<sub>i</sub></italic><sub>&#x002B;1</sub>. To explain precisely this procedure, let <italic>&#x00B5;&#x2032;</italic>(<italic>&#x00B5;<sub>j</sub></italic>) denote the corrected value of <italic>&#x00B5;<sub>j</sub></italic>. Linear interpolation consists at looking for a correction of the form
<disp-formula id="ueqn1">
<alternatives><graphic xlink:href="292425_ueqn1.gif"/></alternatives>
</disp-formula>
where <italic>a</italic> is called the <italic>slope</italic> and <italic>b</italic> is the <italic>intercept</italic>. By imposing that <italic>&#x00B5;&#x2032;</italic>(<italic>&#x00B5;<sub>j</sub></italic>) &#x003D; <italic>v<sub>i</sub></italic> for <italic>j</italic> &#x003D; <italic>&#x03B1;<sub>i</sub></italic> and <italic>&#x00B5;&#x2032;</italic>(<italic>&#x00B5;<sub>j</sub></italic>) &#x003D; <italic>v<sub>i</sub></italic><sub>&#x002B;1</sub> for <italic>j</italic> &#x003D; <italic>&#x03B1;<sub>i</sub></italic><sub>&#x002B;1</sub>, we find that
<disp-formula id="ueqn2">
<alternatives><graphic xlink:href="292425_ueqn2.gif"/></alternatives>
</disp-formula>
and <italic>b</italic> &#x003D; <italic>v<sub>i</sub></italic> &#x2212; <italic>a&#x00B5;<sub>&#x03B1;</sub>i</italic>. The nested <bold>while</bold> loops of the algorithm performs exactly these linear interpolation corrections for all <italic>&#x00B5;<sub>j</sub></italic> such that <italic>&#x03B1;<sub>i</sub></italic> &#x2264; <italic>j</italic> &#x2264; <italic>&#x03B1;<sub>i</sub></italic><sub>&#x002B;1</sub> for <italic>i</italic> &#x003D; 1 to <italic>n</italic> &#x2212; 1.</p>
<p>Once all <italic>m/z</italic> values <italic>&#x00B5;<sub>j</sub></italic> such that <italic>&#x03B1;</italic><sub>1</sub> &#x2264; <italic>j</italic> &#x2264; <italic>&#x03B1;<sub>n</sub></italic> have been corrected, the algorithm is done. Hence, we have decided not to correct any <italic>m/z</italic> value of <italic>S</italic> that is either smaller that <italic>v</italic><sub>1</sub>(1 &#x2212; <italic>w</italic>) or larger than <italic>v<sub>n</sub></italic>(1 &#x002B; <italic>w</italic>) because such a peak has only one adjacent VLM and, consequently, could only be corrected by extrapolation, which is much less reliable than interpolation<sup>3</sup>. Finally, the intensities of the peaks remain unchanged. The running time complexity of this algorithm is <italic>O</italic>(<italic>m</italic>) where <italic>m</italic> is the number of peaks in the spectrum <italic>S</italic> (see the full details in Appendix 1).</p>
</sec>
</sec>
<sec id="s4c">
<title>From VLM correction to spectra alignment</title>
<p>After running the VLM detection and correction algorithms, all the peaks associated with VLM points will be perfectly aligned in the sense that each peak in different spectra associated to a VLM point <italic>v</italic> will have exactly the same <italic>m/z</italic> value <italic>v</italic>. However, all the other peaks corrected by Algorithm (2) will not be perfectly aligned in the sense that a molecule fragment responsible for a peak in different spectra will not yield exactly the same mass after correction. This is due to possibly many uncontrollable phenomena that vary each time a sample gets processed by a mass spectrometer, and by the fact that the correction of each peak was performed by an approximate numerical interpolation. However, if all the peaks have been corrected by Algorithm (2), we expect that the peaks corresponding to the same molecule fragment <italic>f</italic> across different spectra will have very similar masses and will all be localized within a very small window of <italic>m/z</italic> values. Moreover, we also expect that the <italic>m/z</italic> values of the peaks coming from another molecule fragment <italic>g</italic> having a different mass will not cross the <italic>m/z</italic> values coming from molecule fragment <italic>f</italic>.</p>
<p>More precisely, suppose that we have executed Algorithms (1) and (2) with a window size parameter <italic>w</italic> (in relative units) on a sequence <inline-formula><alternatives><inline-graphic xlink:href="292425_inline61.gif"/></alternatives></inline-formula> of mass spectra. In addition, suppose that a molecule fragment <italic>f</italic> gives rise to a peak of <italic>m/z</italic> value <italic>&#x00B5;</italic><sub>1</sub> in spectrum <italic>S</italic><sub>1</sub>, and a peak of <italic>m/z</italic> value <italic>&#x00B5;</italic><sub>2</sub> in spectrum <italic>S</italic><sub>2</sub>, and so on for a sub-sequence of spectra in <inline-formula><alternatives><inline-graphic xlink:href="292425_inline62.gif"/></alternatives></inline-formula>. Let <inline-formula><alternatives><inline-graphic xlink:href="292425_inline63.gif"/></alternatives></inline-formula> be the sequence of these <italic>m/z</italic> values. Moreover, let <italic>&#x00B5;<sub>f</sub></italic> be the average of the <italic>m/z</italic> values in <inline-formula><alternatives><inline-graphic xlink:href="292425_inline64.gif"/></alternatives></inline-formula>. Then, we expect that there exists a window size <italic>&#x03B8;</italic> in relative units, such that 0 <italic>&#x003C; &#x03B8;</italic> &#x00AB; <italic>w</italic>, and for which we have <italic>&#x00B5;<sub>i</sub></italic> &#x2208; [<italic>&#x00B5;<sub>f</sub></italic> (1 &#x2212; <italic>&#x03B8;</italic>), <italic>&#x00B5;<sub>f</sub></italic> (1 &#x002B; <italic>&#x03B8;</italic>)] for all <inline-formula><alternatives><inline-graphic xlink:href="292425_inline65.gif"/></alternatives></inline-formula>. Moreover, if <italic>&#x03B8;</italic> is sufficiently small, we expect that the sequence <inline-formula><alternatives><inline-graphic xlink:href="292425_inline66.gif"/></alternatives></inline-formula> referring to peaks produced by another molecule fragment <italic>g</italic> having a different mass will be such that each <inline-formula><alternatives><inline-graphic xlink:href="292425_inline67.gif"/></alternatives></inline-formula> will not be located within [<italic>&#x00B5;<sub>f</sub></italic> (1 &#x2212; <italic>&#x03B8;</italic>), <italic>&#x00B5;<sub>f</sub></italic> (1 &#x002B; <italic>&#x03B8;</italic>)].</p>
<p>Motivated by this hypothesis, let us introduce the following definitions. Given that Algorithms (1) and (2) have been executed on a sequence <inline-formula><alternatives><inline-graphic xlink:href="292425_inline68.gif"/></alternatives></inline-formula> of mass spectra with window size parameter <italic>w</italic> in relative units, and given that we have another window size parameter <italic>&#x03B8;</italic> &#x00AB; <italic>w</italic> in relative units, we say that a <italic>m/z</italic> value <italic>&#x00B5;<sub>f</sub></italic> is an alignment point w.r.t. <inline-formula><alternatives><inline-graphic xlink:href="292425_inline69.gif"/></alternatives></inline-formula> if there exists a sequence <inline-formula><alternatives><inline-graphic xlink:href="292425_inline70.gif"/></alternatives></inline-formula> of peaks from <inline-formula><alternatives><inline-graphic xlink:href="292425_inline71.gif"/></alternatives></inline-formula> that satisfies the following properties.</p>
<list list-type="order">
<list-item><p>Every peak in <inline-formula><alternatives><inline-graphic xlink:href="292425_inline72.gif"/></alternatives></inline-formula> comes from a different spectrum of <inline-formula><alternatives><inline-graphic xlink:href="292425_inline73.gif"/></alternatives></inline-formula>.</p></list-item>
<list-item><p>The average of the <italic>m/z</italic> values of the peaks in <inline-formula><alternatives><inline-graphic xlink:href="292425_inline74.gif"/></alternatives></inline-formula> is equal to <italic>&#x00B5;<sub>f</sub></italic>.</p></list-item>
<list-item><p>Every peak in <inline-formula><alternatives><inline-graphic xlink:href="292425_inline75.gif"/></alternatives></inline-formula> has an <italic>m/z</italic> value in [<italic>&#x00B5;<sub>f</sub></italic> (1 &#x2212; <italic>&#x03B8;</italic>), <italic>&#x00B5;<sub>f</sub></italic> (1 &#x002B; <italic>&#x03B8;</italic>)] and all other peaks of <inline-formula><alternatives><inline-graphic xlink:href="292425_inline76.gif"/></alternatives></inline-formula> have an <italic>m/z</italic> value outside this interval.</p></list-item>
<list-item><p>There does not exist another peak in <inline-formula><alternatives><inline-graphic xlink:href="292425_inline77.gif"/></alternatives></inline-formula> that we can add to <inline-formula><alternatives><inline-graphic xlink:href="292425_inline78.gif"/></alternatives></inline-formula> and still satisfy the above properties.</p></list-item></list>
<p>Whenever these criteria are satisfied, we say that <inline-formula><alternatives><inline-graphic xlink:href="292425_inline79.gif"/></alternatives></inline-formula>is the <italic>alignment sequence associated</italic> to alignment point <italic>&#x00B5;<sub>f</sub></italic>. Given <inline-formula><alternatives><inline-graphic xlink:href="292425_inline80.gif"/></alternatives></inline-formula> and <italic>&#x03B8;</italic>, an alignment point <italic>&#x00B5;<sub>f</sub></italic> w.r.t. <inline-formula><alternatives><inline-graphic xlink:href="292425_inline81.gif"/></alternatives></inline-formula> is said to <italic>overlap</italic> with another alignment point <italic>&#x00B5;<sub>g</sub></italic> w.r.t. <inline-formula><alternatives><inline-graphic xlink:href="292425_inline82.gif"/></alternatives></inline-formula> if and only if there exists a nonempty intersection between the <italic>m/z</italic> intervals [<italic>&#x00B5;<sub>f</sub></italic> (1 &#x2212; <italic>&#x03B8;</italic>), <italic>&#x00B5;<sub>f</sub></italic> (1 &#x002B; <italic>&#x03B8;</italic>)] and [<italic>&#x00B5;<sub>g</sub></italic>(1 &#x2212; <italic>&#x03B8;</italic>), <italic>&#x00B5;<sub>g</sub></italic>(1 &#x002B; <italic>&#x03B8;</italic>)].</p>
<p>Let <inline-formula><alternatives><inline-graphic xlink:href="292425_inline83.gif"/></alternatives></inline-formula>. Note that there are only two differences between the definition of alignment point (and its associated alignment sequence) and the definition of VLM point (and its associated VLM sequence). The first difference is the fact that a VLM sequence must contain exactly <italic>m</italic> peaks, whereas an alignment sequence can contain any number of peaks between 1 to <italic>m</italic> (since the peaks in an alignment sequence may originate from a molecule fragment which is not present in all the samples for which we have a spectrum in <inline-formula><alternatives><inline-graphic xlink:href="292425_inline84.gif"/></alternatives></inline-formula>). Hence, if we remove the constraint that each virtual lock mass must be formed of <inline-formula><alternatives><inline-graphic xlink:href="292425_inline85.gif"/></alternatives></inline-formula> peaks from the validation step, Algorithm (1) then finds all the maximum-length sub-sequence of peaks that satisfy the 4 criteria for a valid alignment sequence when it reaches the overlap deletion step. The second difference is that there is no intensity threshold <italic>t</italic> applied to the peaks for alignment, as we wish to align every peak in the spectra if possible. Note that, generally, a lower intensity threshold is still applied to the peaks in order to remove peaks that are the result of background noise. Consequently, with that very minor change,
<disp-formula id="ueqn3">
<alternatives><graphic xlink:href="292425_ueqn3.gif"/></alternatives>
</disp-formula>
finds all isolated alignment points w.r.t. <inline-formula><alternatives><inline-graphic xlink:href="292425_inline86.gif"/></alternatives></inline-formula> in <italic>O</italic>(<italic>n</italic> log <italic>m</italic>) time, where <italic>n</italic> is the total number of peaks in <inline-formula><alternatives><inline-graphic xlink:href="292425_inline87.gif"/></alternatives></inline-formula>.</p>
<p>If the window size parameter <italic>&#x03B8;</italic> is too large, then many alignment points will overlap and Algorithm (1) will return very few isolated alignment points. If <italic>&#x03B8;</italic> is very very small, then, in contrast with the VLM identification case, Algorithm (1) will return a very large number of isolated alignment points associated to aligned sequences that contain only one point. Hence, in contrast with the VLM identification case, the best parameter <italic>&#x03B8;</italic> is not the one for which we obtain the largest number of alignment points. What should then be the choice for <italic>&#x03B8;</italic>? To answer this question, we consider each VLM point (and its associated sequence of peaks) found by Algorithm (1). If we leave out one VLM point <italic>v<sub>i</sub></italic> from the correction algorithm (2) and use this algorithm to correct all the <italic>m/z</italic> values of the peaks associated to this VLM point, the maximum deviation from <italic>v<sub>i</sub></italic> among these <italic>m/z</italic> values will give us the smallest window size <italic>&#x03B8;<sub>i</sub></italic> such that each <italic>m/z</italic> value will be located within [<italic>v<sub>i</sub></italic>(1 &#x2212; <italic>&#x03B8;<sub>i</sub></italic>), <italic>v<sub>i</sub></italic>(1 &#x002B; <italic>&#x03B8;<sub>i</sub></italic>)]. Essentially, this window size <italic>&#x03B8;<sub>i</sub></italic> is the smallest one for which we can still recognize all the peaks associated to the same VLM <italic>v<sub>i</sub></italic>. It would then certainly be a very good choice for <italic>&#x03B8;</italic> in that region of <italic>m/z</italic> values. We can then repeat this procedure for all isolated VLM points (except the VLMs with the smallest and largest <italic>m/z</italic> values) found by Algorithm (1) to obtain a sequence of <italic>&#x03B8;<sub>i</sub></italic> values. One interesting possibility for <italic>&#x03B8;</italic> is the maximum among the <italic>&#x03B8;<sub>i</sub></italic> values. However, this is clearly an overestimate of the maximum spreading of peaks associated to the same molecule fragment since all the VLMs will be used for the correction, including the one that was left out. Moreover, as we can see in <xref rid="fig3" ref-type="fig">Figure (3)</xref>, we can recover a large fraction of the non-overlapping VLMs if we use a significantly smaller window size than the max<sub>i</sub> &#x03B8;<sub>i</sub>. For that reason, we have decided to use, for the window size <italic>&#x03B8;</italic>, the smallest value covering 95&#x0025; of the non-overlapping VLMs, i.e., the 95th percentile. Alternatively, to attempt to maximize the accuracy of a learning algorithm, a percentile <italic>z</italic> can be selected by cross-validation along with the selection of the hyperparameters of the learning algorithm.</p>
<p>If we have <italic>r</italic> VLM points, each <italic>&#x03B8;<sub>i</sub></italic> associated to the <italic>i</italic>th VLM point is found in <italic>O</italic>(<italic>m</italic>) time for a sequence <inline-formula><alternatives><inline-graphic xlink:href="292425_inline88.gif"/></alternatives></inline-formula> of <italic>m</italic> spectra; thus implying a running time in <italic>O</italic>(<italic>mr</italic>) to find every <italic>&#x03B8;<sub>i</sub></italic>. Then, the 95th percentile is found by sorting the vector of <italic>&#x03B8;<sub>i</sub></italic>s in <italic>O</italic>(<italic>r</italic> log <italic>r</italic>) time. Assuming that we always have log(<italic>r</italic>) <italic>&#x003C; m</italic>, the total running time to find <italic>&#x03B8;</italic> is in <italic>O</italic>(<italic>mr</italic>), and hence in <italic>O</italic>(<italic>n</italic>) when <inline-formula><alternatives><inline-graphic xlink:href="292425_inline89.gif"/></alternatives></inline-formula> contains a total of <italic>n</italic> peaks.</p>
<p>Once the window size <italic>&#x03B8;</italic> is found, we can then run Algorithm (1) just once on the full sequence <inline-formula><alternatives><inline-graphic xlink:href="292425_inline90.gif"/></alternatives></inline-formula> of spectra with that value of <italic>&#x03B8;</italic> in <italic>O</italic>(<italic>n</italic> log <italic>m</italic>) time. Consequently, the total running time of the alignment algorithm, which includes the running time to find <italic>&#x03B8;</italic> and to find all non overlapping alignment points w.r.t. <inline-formula><alternatives><inline-graphic xlink:href="292425_inline91.gif"/></alternatives></inline-formula>, is in <italic>O</italic>(<italic>n</italic> log <italic>m</italic>).</p>
<p>Once we have the VLM points and the alignment points, these are used to provide a</p>
<p><italic>representation</italic> of the spectra which is well suited for running machine learning algorithms on them. Indeed, consider <xref rid="fig4" ref-type="fig">Fig (4)</xref>. For any new spectrum <italic>S</italic>, the VLM points are first used correct the <italic>m/z</italic> value of each peak of <italic>S</italic> and, following that, the intensity of any corrected peak that fall into the window associated to an alignment point give a feature of <italic>S</italic>. Hence, the vector of these intensities provides a new representation of the spectrum <italic>S</italic> that we will use for the input into a classifier to predict the label of <italic>S</italic>.</p>
<fig id="fig4" position="float" fig-type="figure">
<label>Fig 4.</label>
<caption><title>A representation of the original spectra</title><p>is given by the intensities of the VLM-corrected peaks that fall into the windows associated to alignment points.</p></caption>
<graphic xlink:href="292425_fig4.tif"/>
</fig>
<p>Finally, it might be tempting to use a clustering approach to solve the problem of finding the isolated alignment points. After all, the alignment sequences are just clusters of peaks belonging to different spectra. However, we have to keep in mind that current trends lead to the processing of hundreds of spectra, each potentially containing thousands of peaks. The total number of peaks to be processed can thus reach a million peaks or more. In our case, the total running time of the full pipeline (finding all isolated VLMs, correcting all the mass spectra with the VLMs, and finding all the isolated alignment points) is in <italic>O</italic>(<italic>n</italic> log <italic>m</italic>). Hence, any algorithm running in &#x2126;(<italic>n</italic><sup>2</sup>) time, will be completely surpassed by the proposed pipeline of algorithms. As far as we know, the running times of popular of-the-shelf clustering algorithms such as K-means and linkage-based clustering algorithms all require a running time in &#x2126;(<italic>n</italic><sup>2</sup>). Moreover, all the clustering algorithms that we know have at least one parameter to tune, which often includes the number of desired clusters. Hence, with the current state of knowledge, a clustering-based algorithm is bound to be substantially less efficient than the proposed pipeline of algorithms.</p>
<p>An implementation of the algorithms for Python is available at <ext-link ext-link-type="uri" xlink:href="https://github.com/francisbrochu/msvlm">https://github.com/francisbrochu/msvlm</ext-link>.</p>
</sec>
</sec>
<sec id="s5">
<title>Dataset descriptions</title>
<sec id="s5a">
<title>Days Dataset</title>
<p>Plasma from 20 healthy persons was equally pooled together. The pooled plasma was aliquoted and kept at &#x2212;20 &#x00B0;C.</p>
<p>Two consecutive days, an acetonitrile crash was performed using 9 parts of acetonitrile (Fisher Optima) for 1 part of unfrozen plasma pool. The crash solution was centrifuged at 4000 rpm for 5 minutes. 2 <italic>&#x00B5;</italic>l of the solution was spotted on every well of a 96 wells Lazwell plate (Phytronix). The same experiment was repeated the next day.</p>
</sec>
<sec id="s5b">
<title>Clomiphene-Acetaminophen Dataset</title>
<p>One pill of acetaminophen (500 mg) was diluted in 50 mL of methanol and water (50:50). The solution was put in a sonicating bath for 20 minutes. The resulting solution was centrifuged and diluted 1:100 in water. For clomiphene, we used a solution of 100<italic>&#x00B5;</italic>g/ml of clomiphene in methanol (Phytronix).</p>
<p>A pool of plasma was crashed as previously described. The solution was split in 3 parts. One received 10 <italic>&#x00B5;</italic>l of the acetaminophen solution, another 10 <italic>&#x00B5;</italic>l of the clomiphene solution and the last one stayed unmodified. Each type of sample was spotted 32 times.</p>
</sec>
<sec id="s5c">
<title>Malaria Dataset</title>
<p><italic>Plasmodium falciparum</italic> parasites were put in culture in red blood cells and tightly synchronized. Culture was performed for 28-36 hours, until parasites are in the trophozoite stage and parasitaemia reached 5-10&#x0025;. In the same conditions, red blood cells were kept uninfected. Cells were diluted to 2&#x0025; hematrocrit by adding the correct amount of pelleted cells to complete RPMI media. 200 <italic>&#x00B5;</italic>L of the cell suspensions was deposited in a 96 well plate in order to have 40 samples of infected cells and 40 samples of uninfected cells.</p>
<p>After 4 hours at 37 &#x00B0;C, the plate was spin at 800x <italic>g</italic> for 5 minutes. 180 <italic>&#x00B5;</italic>L of culture media was removed. Pellet was resuspended in the remaining 20 <italic>&#x00B5;</italic>L and 10 <italic>&#x00B5;</italic>L was transferred to a new 96 well plate. 100 <italic>&#x00B5;</italic>L of ice-cold methanol was quickly added to the plate and put on dry-ice to stop any metabolic reaction. The plate was vortexed 3 times, for 15 seconds each, over 15 minutes incubation on dry-ice. The plate then was placed for sonication in a water bath for 5 times 1 minute with 2 minutes breaks on dry-ice. Finally, the plate was centrifuged at 3200 rpm for 5 minutes at 4&#x00B0;C. 30<italic>&#x00B5;</italic>L of the supernatant was transferred to another plate and kept at &#x2212;80&#x00B0;C until LDTD-MS analysis.</p>
<p>For analysis, 2 <italic>&#x00B5;</italic>l of the metabolomic extract was spotted on a 96 well Lazwell plate and left at room temperature until dryness.</p>
</sec>
<sec id="s5d">
<title>Cancer Dataset</title>
<p>Plasma from patients diagnosed for breast cancer and from healthy patients were individually treated using the same acetonitrile crash protocol. A total of 96 samples from breast cancer patients were acquired. In addition, 96 plasma samples from healthy patients were also acquired in order to have control samples.</p>
</sec>
<sec id="s5e">
<title>Data acquisition</title>
<p>All data were acquired on a Synapt G2-Si mass spectrometer. The instrument was operated in high resolution mode. Except if stated otherwise, data acquisition was performed in positive ionization. The acquisition method was <italic>MS<sup>e</sup></italic> with a scan time of 0.1 second. Calibration of the instrument was performed daily before data acquisition using a solution of sodium formate 0.5 mM. The instrument was operated with Mass Lynx software. The source is a LDTD 960 ion source (Phytronix). The laser pattern used is the following: 2 seconds at 0&#x0025;, ramp up to 65&#x0025; in 6 seconds, hold at 65&#x0025; for 2 seconds and back at 0&#x0025; in 0.1 second.</p>
</sec>
<sec id="s5f">
<title>Data conversion</title>
<p>Raw files produced by the mass spectrometer were converted to ion list using a continuous to centroid approach using the ProcessKernel software (Waters Corporation) using only the first function (low energy) present in the files. The resulting centroided peak list were used for data analysis.</p>
<p>For all experiments presented in this article, the <italic>t</italic> threshold on intensity for virtual lock mass detection was set at 1000 counts.</p>
</sec>
</sec>
</body>
<back>
<ack>
<title>Acknowledgments</title>
<p>We thank Water Corporation for their support and expertise that helped to the design of the proposed algorithms and for the support using their instruments. We also thank Phytronix Technologies Inc. for their support with their instruments. Computations were made on the supercomputer Colosse from Universit&#x00E9; Laval, managed by Calcul Qu&#x00E9;bec and Compute Canada. The operation of this supercomputer is funded by the Canada Foundation for Innovation (CFI), the minist&#x00E9;re de l&#x2019;E&#x00B4;conomie, de la science et de l&#x2019;innovation du Qu&#x00E9;bec (MESI) and the Fonds de recherche du Qu&#x00E9;bec - Nature et technologies (FRQ-NT). Computations were also made on the supercomputer Graham from Waterloo University, managed by Compute Canada. Finally, we thank Dr. Dave Richard for providing us with the malaria dataset samples and Dr. Francine Durocher for providing the breast cancer dataset samples.</p></ack>
<ref-list>
<title>References</title>
<ref id="c1"><label>1.</label><mixed-citation publication-type="journal"><string-name><surname>Dettmer</surname> <given-names>K</given-names></string-name>, <string-name><surname>Aronov</surname> <given-names>PA</given-names></string-name>, <string-name><surname>Hammock</surname> <given-names>BD</given-names></string-name>. <article-title>Mass spectrometry-based metabolomics</article-title>. <source>Mass spectrometry reviews</source>. <year>2007</year>;<volume>26</volume>(<issue>1</issue>):<fpage>51</fpage>&#x2013;<lpage>78</lpage>.</mixed-citation></ref>
<ref id="c2"><label>2.</label><mixed-citation publication-type="journal"><string-name><surname>Han</surname> <given-names>X</given-names></string-name>, <string-name><surname>Aslanian</surname> <given-names>A</given-names></string-name>, <string-name><surname>Yates</surname> <suffix>III</suffix> <given-names>JR</given-names></string-name>. <article-title>Mass spectrometry for proteomics</article-title>. <source>Current opinion in chemical biology</source>. <year>2008</year>;<volume>12</volume>(<issue>5</issue>):<fpage>483</fpage>&#x2013;<lpage>490</lpage>.</mixed-citation></ref>
<ref id="c3"><label>3.</label><mixed-citation publication-type="journal"><string-name><surname>Fenselau</surname> <given-names>C</given-names></string-name>, <string-name><surname>Demirev</surname> <given-names>PA</given-names></string-name>. <article-title>Characterization of intact microorganisms by MALDI mass spectrometry</article-title>. <source>Mass spectrometry reviews</source>. <year>2001</year>;<volume>20</volume>(<issue>4</issue>):<fpage>157</fpage>&#x2013;<lpage>171</lpage>.</mixed-citation></ref>
<ref id="c4"><label>4.</label><mixed-citation publication-type="journal"><string-name><surname>Caprioli</surname> <given-names>RM</given-names></string-name>, <string-name><surname>Farmer</surname> <given-names>TB</given-names></string-name>, <string-name><surname>Gile</surname> <given-names>J</given-names></string-name>. <article-title>Molecular imaging of biological samples: localization of peptides and proteins using MALDI-TOF MS</article-title>. <source>Analytical chemistry</source>. <year>1997</year>;<volume>69</volume>(<issue>23</issue>):<fpage>4751</fpage>&#x2013;<lpage>4760</lpage>.</mixed-citation></ref>
<ref id="c5"><label>5.</label><mixed-citation publication-type="journal"><string-name><surname>Cox</surname> <given-names>J</given-names></string-name>, <string-name><surname>Mann</surname> <given-names>M</given-names></string-name>. <article-title>Quantitative, high-resolution proteomics for data-driven systems biology</article-title>. <source>Annual review of biochemistry</source>. <year>2011</year>;<volume>80</volume>:<fpage>273</fpage>&#x2013;<lpage>299</lpage>.</mixed-citation></ref>
<ref id="c6"><label>6.</label><mixed-citation publication-type="journal"><string-name><surname>Hunt</surname> <given-names>DF</given-names></string-name>, <string-name><surname>Yates</surname> <given-names>JR</given-names></string-name>, <string-name><surname>Shabanowitz</surname> <given-names>J</given-names></string-name>, <string-name><surname>Winston</surname> <given-names>S</given-names></string-name>, <string-name><surname>Hauer</surname> <given-names>CR</given-names></string-name>. <article-title>Protein sequencing by tandem mass spectrometry</article-title>. <source>Proceedings of the National Academy of Sciences</source>. <year>1986</year>;<volume>83</volume>(<issue>17</issue>):<fpage>6233</fpage>&#x2013;<lpage>6237</lpage>.</mixed-citation></ref>
<ref id="c7"><label>7.</label><mixed-citation publication-type="journal"><string-name><surname>Cottrell</surname> <given-names>JS</given-names></string-name>, <string-name><surname>London</surname> <given-names>U</given-names></string-name>. <article-title>Probability-based protein identification by searching sequence databases using mass spectrometry data</article-title>. <source>electrophoresis</source>. <year>1999</year>;<volume>20</volume>(<issue>18</issue>):<fpage>3551</fpage>&#x2013;<lpage>3567</lpage>.</mixed-citation></ref>
<ref id="c8"><label>8.</label><mixed-citation publication-type="journal"><string-name><surname>Alonso</surname> <given-names>A</given-names></string-name>, <string-name><surname>Marsal</surname> <given-names>S</given-names></string-name>, <string-name><surname>Juli&#x00E0;</surname> <given-names>A</given-names></string-name>. <article-title>Analytical methods in untargeted metabolomics: state of the art in 2015</article-title>. <source>Frontiers in bioengineering and biotechnology</source>. <year>2015</year>;<volume>3</volume>:<fpage>23</fpage>.</mixed-citation></ref>
<ref id="c9"><label>9.</label><mixed-citation publication-type="journal"><string-name><surname>Dunn</surname> <given-names>WB</given-names></string-name>, <string-name><surname>Erban</surname> <given-names>A</given-names></string-name>, <string-name><surname>Weber</surname> <given-names>RJ</given-names></string-name>, <string-name><surname>Creek</surname> <given-names>DJ</given-names></string-name>, <string-name><surname>Brown</surname> <given-names>M</given-names></string-name>, <string-name><surname>Breitling</surname> <given-names>R</given-names></string-name>, <etal>et al.</etal> <article-title>Mass appeal: metabolite identification in mass spectrometry-focused untargeted metabolomics</article-title>. <source>Metabolomics</source>. <year>2013</year>;<volume>9</volume>(<issue>1</issue>):<fpage>44</fpage>&#x2013;<lpage>66</lpage>.</mixed-citation></ref>
<ref id="c10"><label>10.</label><mixed-citation publication-type="other"><string-name><surname>R&#x00A8;ompp</surname> <given-names>A</given-names></string-name>, <string-name><surname>Karst</surname> <given-names>U</given-names></string-name>. <article-title>Current trends in mass spectrometry imaging</article-title>; <year>2015</year>.</mixed-citation></ref>
<ref id="c11"><label>11.</label><mixed-citation publication-type="journal"><string-name><surname>Huang</surname> <given-names>MZ</given-names></string-name>, <string-name><surname>Yuan</surname> <given-names>CH</given-names></string-name>, <string-name><surname>Cheng</surname> <given-names>SC</given-names></string-name>, <string-name><surname>Cho</surname> <given-names>YT</given-names></string-name>, <string-name><surname>Shiea</surname> <given-names>J</given-names></string-name>. <article-title>Ambient ionization mass spectrometry</article-title>. <source>Annual review of analytical chemistry</source>. <year>2010</year>;<volume>3</volume>:<fpage>43</fpage>&#x2013;<lpage>65</lpage>.</mixed-citation></ref>
<ref id="c12"><label>12.</label><mixed-citation publication-type="journal"><string-name><surname>Semmes</surname> <given-names>OJ</given-names></string-name>, <string-name><surname>Feng</surname> <given-names>Z</given-names></string-name>, <string-name><surname>Adam</surname> <given-names>BL</given-names></string-name>, <string-name><surname>Banez</surname> <given-names>LL</given-names></string-name>, <string-name><surname>Bigbee</surname> <given-names>WL</given-names></string-name>, <string-name><surname>Campos</surname> <given-names>D</given-names></string-name>, <etal>et al.</etal> <article-title>Evaluation of serum protein profiling by surface-enhanced laser desorption/ionization time-of-flight mass spectrometry for the detection of prostate cancer: I. Assessment of platform reproducibility</article-title>. <source>Clinical Chemistry</source>. <year>2005</year>;<volume>51</volume>(<issue>1</issue>):<fpage>102</fpage>&#x2013;<lpage>112</lpage>.</mixed-citation></ref>
<ref id="c13"><label>13.</label><mixed-citation publication-type="journal"><string-name><surname>Tibshirani</surname> <given-names>R</given-names></string-name>, <string-name><surname>Hastie</surname> <given-names>T</given-names></string-name>, <string-name><surname>Narasimhan</surname> <given-names>B</given-names></string-name>, <string-name><surname>Soltys</surname> <given-names>S</given-names></string-name>, <string-name><surname>Shi</surname> <given-names>G</given-names></string-name>, <string-name><surname>Koong</surname> <given-names>A</given-names></string-name>, <etal>et al.</etal> <article-title>Sample classification from protein mass spectrometry, by &#x2018;peak probability contrasts&#x2019;</article-title>. <source>Bioinformatics</source>. <year>2004</year>;<volume>20</volume>(<issue>17</issue>):<fpage>3034</fpage>&#x2013;<lpage>3044</lpage>.</mixed-citation></ref>
<ref id="c14"><label>14.</label><mixed-citation publication-type="journal"><string-name><surname>Jeffries</surname> <given-names>N</given-names></string-name>. <article-title>Algorithms for alignment of mass spectrometry proteomic data</article-title>. <source>Bioinformatics</source>. <year>2005</year>;<volume>21</volume>(<issue>14</issue>):<fpage>3066</fpage>&#x2013;<lpage>3073</lpage>.</mixed-citation></ref>
<ref id="c15"><label>15.</label><mixed-citation publication-type="journal"><string-name><surname>Tracy</surname> <given-names>MB</given-names></string-name>, <string-name><surname>Chen</surname> <given-names>H</given-names></string-name>, <string-name><surname>Weaver</surname> <given-names>DM</given-names></string-name>, <string-name><surname>Malyarenko</surname> <given-names>DI</given-names></string-name>, <string-name><surname>Sasinowski</surname> <given-names>M</given-names></string-name>, <string-name><surname>Cazares</surname> <given-names>LH</given-names></string-name>, <etal>et al.</etal> <article-title>Precision enhancement of MALDI-TOF MS using high resolution peak detection and label-free alignment</article-title>. <source>Proteomics</source>. <year>2008</year>;<volume>8</volume>(<issue>8</issue>):<fpage>1530</fpage>&#x2013;<lpage>1538</lpage>.</mixed-citation></ref>
<ref id="c16"><label>16.</label><mixed-citation publication-type="journal"><string-name><surname>Barry</surname> <given-names>JA</given-names></string-name>, <string-name><surname>Robichaud</surname> <given-names>G</given-names></string-name>, <string-name><surname>Muddiman</surname> <given-names>DC</given-names></string-name>. <article-title>Mass recalibration of FT-ICR mass spectrometry imaging data using the average frequency shift of ambient ions</article-title>. <source>Journal of the American Society for Mass Spectrometry</source>. <year>2013</year>;<volume>24</volume>(<issue>7</issue>):<fpage>1137</fpage>&#x2013;<lpage>1145</lpage>.</mixed-citation></ref>
<ref id="c17"><label>17.</label><mixed-citation publication-type="journal"><string-name><surname>Psychogios</surname> <given-names>N</given-names></string-name>, <string-name><surname>Hau</surname> <given-names>DD</given-names></string-name>, <string-name><surname>Peng</surname> <given-names>J</given-names></string-name>, <string-name><surname>Guo</surname> <given-names>AC</given-names></string-name>, <string-name><surname>Mandal</surname> <given-names>R</given-names></string-name>, <string-name><surname>Bouatra</surname> <given-names>S</given-names></string-name>, <etal>et al.</etal> <article-title>The human serum metabolome</article-title>. <source>PloS one</source>. <year>2011</year>;<volume>6</volume>(<issue>2</issue>):<fpage>e16957</fpage>.</mixed-citation></ref>
<ref id="c18"><label>18.</label><mixed-citation publication-type="journal"><string-name><surname>Bouatra</surname> <given-names>S</given-names></string-name>, <string-name><surname>Aziat</surname> <given-names>F</given-names></string-name>, <string-name><surname>Mandal</surname> <given-names>R</given-names></string-name>, <string-name><surname>Guo</surname> <given-names>AC</given-names></string-name>, <string-name><surname>Wilson</surname> <given-names>MR</given-names></string-name>, <string-name><surname>Knox</surname> <given-names>C</given-names></string-name>, <etal>et al.</etal> <article-title>The human urine metabolome</article-title>. <source>PloS one</source>. <year>2013</year>;<volume>8</volume>(<issue>9</issue>):<fpage>e73076</fpage>.</mixed-citation></ref>
<ref id="c19"><label>19.</label><mixed-citation publication-type="book"><string-name><surname>Freund</surname> <given-names>Y</given-names></string-name>, <string-name><surname>Schapire</surname> <given-names>RE</given-names></string-name>. <chapter-title>A desicion-theoretic generalization of on-line learning and an application to boosting</chapter-title>. In: <source>European conference on computational learning theory</source>. <publisher-name>Springer</publisher-name>; <year>1995</year>. p. <fpage>23</fpage>&#x2013;<lpage>37</lpage>.</mixed-citation></ref>
<ref id="c20"><label>20.</label><mixed-citation publication-type="book"><string-name><surname>Breiman</surname> <given-names>L</given-names></string-name>, <string-name><surname>Friedman</surname> <given-names>J</given-names></string-name>, <string-name><surname>Olshen</surname> <given-names>R</given-names></string-name>, <string-name><surname>Stone</surname> <given-names>C</given-names></string-name>. <chapter-title>Classification and Regression Trees</chapter-title>. <publisher-loc>Monterey, CA</publisher-loc>: <publisher-name>Wadsworth and Brooks</publisher-name>; <year>1984</year>.</mixed-citation></ref>
<ref id="c21"><label>21.</label><mixed-citation publication-type="journal"><string-name><surname>Marchand</surname> <given-names>M</given-names></string-name>, <string-name><surname>Shawe-Taylor</surname> <given-names>J</given-names></string-name>. <article-title>The set covering machine</article-title>. <source>Journal of Machine Learning Research</source>. <year>2002</year>;<volume>3</volume>(<issue>Dec</issue>):<fpage>723</fpage>&#x2013;<lpage>746</lpage>.</mixed-citation></ref>
<ref id="c22"><label>22.</label><mixed-citation publication-type="journal"><string-name><surname>Cortes</surname> <given-names>C</given-names></string-name>, <string-name><surname>Vapnik</surname> <given-names>V</given-names></string-name>. <article-title>Support-vector networks</article-title>. <source>Machine learning</source>. <year>1995</year>;<volume>20</volume>(<issue>3</issue>):<fpage>273</fpage>&#x2013;<lpage>297</lpage>.</mixed-citation></ref>
<ref id="c23"><label>23.</label><mixed-citation publication-type="journal"><string-name><surname>Pedregosa</surname> <given-names>F</given-names></string-name>, <string-name><surname>Varoquaux</surname> <given-names>G</given-names></string-name>, <string-name><surname>Gramfort</surname> <given-names>A</given-names></string-name>, <string-name><surname>Michel</surname> <given-names>V</given-names></string-name>, <string-name><surname>Thirion</surname> <given-names>B</given-names></string-name>, <string-name><surname>Grisel</surname> <given-names>O</given-names></string-name>, <etal>et al.</etal> <article-title>Scikit-learn: Machine Learning in Python</article-title>. <source>Journal of Machine Learning Research</source>. <year>2011</year>;<volume>12</volume>:<fpage>2825</fpage>&#x2013;<lpage>2830</lpage>.</mixed-citation></ref>
<ref id="c24"><label>24.</label><mixed-citation publication-type="book"><string-name><surname>Gammerman</surname> <given-names>A</given-names></string-name>, <string-name><surname>Vovk</surname> <given-names>V</given-names></string-name>, <string-name><surname>Vapnik</surname> <given-names>V</given-names></string-name>. <chapter-title>Learning by transduction</chapter-title>. In: <source>Proceedings of the Fourteenth conference on Uncertainty in artificial intelligence</source>. <publisher-name>Morgan Kaufmann Publishers Inc</publisher-name>.; <year>1998</year>. p. <fpage>148</fpage>&#x2013;<lpage>155</lpage>.</mixed-citation></ref>
<ref id="c25"><label>25.</label><mixed-citation publication-type="journal"><string-name><surname>Nordstr&#x00F6;m</surname> <given-names>A</given-names></string-name>, <string-name><surname>O&#x2019;Maille</surname> <given-names>G</given-names></string-name>, <string-name><surname>Qin</surname> <given-names>C</given-names></string-name>, <string-name><surname>Siuzdak</surname> <given-names>G</given-names></string-name>. <article-title>Nonlinear data alignment for UPLC-MS and HPLC-MS based metabolomics: quantitative analysis of endogenous and exogenous metabolites in human serum</article-title>. <source>Analytical chemistry</source>. <year>2006</year>;<volume>78</volume>(<issue>10</issue>):<fpage>3289</fpage>&#x2013;<lpage>3295</lpage>.</mixed-citation></ref>
</ref-list>
<fn-group>
<fn id="fn1"><label><sup>1</sup></label>
<p>We refer here to the well-known running times (available from any introductory textbook on data structures and algorithms) for heap construction, removal of its top element, and insertion of a new element.</p></fn>
<fn id="fn2"><label><sup>2</sup></label>
<p>This may appear to be a strategy a bit too complicated than necessary in view of the fact that the largest (and smallest) such sub-sequence must contain exactly <italic>m</italic> peaks to be a valid VLM. However, we will see below that a significant advantage of using the proposed strategy is the fact that the same algorithm, modulo some very small and trivial modification, can also be used to detect the alignment points of <italic>S</italic>.</p></fn>
<fn id="fn3"><label><sup>3</sup></label>
<p>Therefore, we recommend removing all these peaks from <italic>S</italic> to perform statistical analyses or machine learning experiments.</p></fn>
</fn-group>
</back>
</article>