<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">ANNarchy: a code generation approach to neural simulations on parallel hardware</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2015-07-31">31 July 2015</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Andrew</forename><forename type="middle">P</forename><surname>Davison</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Mikael</forename><surname>Djurfeldt</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Thomas</forename><forename type="middle">Glyn</forename><surname>Close</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Julien</forename><surname>Vitay</surname></persName>
							<affiliation key="aff6">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Chemnitz University of Technology</orgName>
								<address>
									<settlement>Chemnitz, Germany</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Helge</forename><forename type="middle">Ü</forename><surname>Dinkelbach</surname></persName>
							<affiliation key="aff6">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Chemnitz University of Technology</orgName>
								<address>
									<settlement>Chemnitz, Germany</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Fred</forename><forename type="middle">H</forename><surname>Hamker</surname></persName>
							<affiliation key="aff6">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Chemnitz University of Technology</orgName>
								<address>
									<settlement>Chemnitz, Germany</settlement>
								</address>
							</affiliation>
							<affiliation key="aff7">
								<orgName type="department">Bernstein Center for Computational Neuroscience</orgName>
								<orgName type="institution">Charité University Medicine</orgName>
								<address>
									<settlement>Berlin</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Centre National de la Recherche Scientifique</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Royal Institute of Technology</orgName>
								<address>
									<country key="SE">Sweden</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Marcel Stimberg</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">École Normale Supérieure</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">Okinawa Institute of Science and Technology Graduate University</orgName>
								<address>
									<country key="JP">Japan</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="department" key="dep1">Fakultät für Informatik</orgName>
								<orgName type="department" key="dep2">Professur Künstliche Intelligenz</orgName>
								<orgName type="institution">Technische Universität Chemnitz</orgName>
								<address>
									<addrLine>Straße der Nationen 62</addrLine>
									<postCode>D-09107</postCode>
									<settlement>Chemnitz</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">ANNarchy: a code generation approach to neural simulations on parallel hardware</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2015-07-31">31 July 2015</date>
						</imprint>
					</monogr>
					<idno type="MD5">C2F901F5DF544A432F0350D31DC3A25D</idno>
					<idno type="DOI">10.3389/fninf.2015.00019</idno>
					<note type="submission">Received: 31 March 2015 Accepted: 13 July 2015</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2-SNAPSHOT" ident="GROBID" when="2022-05-18T11:18+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>neural simulator</term>
					<term>Python</term>
					<term>rate-coded networks</term>
					<term>spiking networks</term>
					<term>parallel computing</term>
					<term>code generation</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p><s>Many modern neural simulators focus on the simulation of networks of spiking neurons on parallel hardware.</s><s>Another important framework in computational neuroscience, rate-coded neural networks, is mostly difficult or impossible to implement using these simulators.</s><s>We present here the ANNarchy (Artificial Neural Networks architect) neural simulator, which allows to easily define and simulate rate-coded and spiking networks, as well as combinations of both.</s><s>The interface in Python has been designed to be close to the PyNN interface, while the definition of neuron and synapse models can be specified using an equation-oriented mathematical description similar to the Brian neural simulator.</s><s>This information is used to generate C++ code that will efficiently perform the simulation on the chosen parallel hardware (multi-core system or graphical processing unit).</s><s>Several numerical methods are available to transform ordinary differential equations into an efficient C++code.</s><s>We compare the parallel performance of the simulator to existing solutions.</s></p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p><s>The efficiency and flexibility of neural simulators becomes increasingly important as the size and complexity of the models studied in computational neuroscience grows.</s><s>Most recent efforts focus on spiking neurons, either of the integrate-and-fire or Hodgkin-Huxley type (see <ref type="bibr" target="#b9">Brette et al., 2007</ref>, for a review).</s><s>The most well-known examples include Brian <ref type="bibr" target="#b25">(Goodman and Brette, 2008;</ref><ref type="bibr" target="#b47">Stimberg et al., 2014)</ref>, NEST <ref type="bibr" target="#b24">(Gewaltig and Diesmann, 2007)</ref>, NEURON <ref type="bibr" target="#b28">(Hines and Carnevale, 1997)</ref>, GENESIS <ref type="bibr" target="#b6">(Bower and Beeman, 2007)</ref>, Nengo <ref type="bibr" target="#b3">(Bekolay et al., 2014)</ref>, or Auryn <ref type="bibr" target="#b54">(Zenke and Gerstner, 2014)</ref>.</s><s>These neural simulators focus on the parallel simulation of neural networks on shared memory systems (multi-core or multi-processor) or distributed systems (clusters) using either OpenMP (open multi-processing) or MPI (message parsing interface).</s><s>Recent work address the use of general-purpose graphical processing cards (GPU) through the CUDA or OpenCL frameworks (see <ref type="bibr" target="#b8">Brette and Goodman, 2012</ref>, for a review).</s><s>The neural simulators GeNN 1 , NCS <ref type="bibr" target="#b48">(Thibeault et al., 2011)</ref>, NeMo <ref type="bibr" target="#b21">(Fidjeland et al., 2009)</ref>, and CARLsim <ref type="bibr" target="#b12">(Carlson et al., 2014)</ref> provide in particular support for the simulation of spiking and compartmental models on single or multiple GPU architectures.</s></p><p><s>A common approach to most of these neural simulators is to provide an extensive library of neuron and synapse models which are optimized in a low-level language for a particular computer architecture.</s><s>These models are combined to form the required network by using a high-level interface, such as a specific scripting language (as in NEST or NEURON) or an interpreted programming language (e.g., Python).</s><s>As these interfaces are simulator-specific, the PyNN interface has been designed to provide a common Python interface to multiple neural simulators, allowing a better exchange of models between researchers <ref type="bibr" target="#b14">(Davison et al., 2008)</ref>.</s><s>The main drawback of this approach is that a user is limited to the neuron and synapse models provided by the simulator: if one wants to even marginally modify the equations of a model, one has to write a plugin in a low-level language without breaking the performance of the simulator.</s><s>This can be particularly tedious, especially for CUDA code on GPUs.</s></p><p><s>A notable exception is the Brian simulator, which allows the user to completely define the neuron and synapse models using a simple mathematical description of the corresponding equations.</s><s>Brian uses a code generation approach to transform these descriptions into executable code <ref type="bibr" target="#b26">(Goodman, 2010)</ref>, allowing the user to implement any kind of neuron or synapse model.</s><s>The first version of Brian executes the code in Python directly (although some code portions can be generated in a lower-level language) using vectorized computations <ref type="bibr" target="#b7">(Brette and Goodman, 2011)</ref>, making the simulation relatively slow and impossible to run in parallel on shared memory systems.</s><s>The second version in development (Brian 2, <ref type="bibr" target="#b47">Stimberg et al., 2014)</ref> proposes a complete code generation approach where the simulation can be implemented in different languages or parallel frameworks.</s><s>This approach is promising as it combines flexibility in model design with efficient and parallel simulation performance.</s></p><p><s>Rate-coded networks, however, do not benefit much from the advances of spiking simulators.</s><s>Rate-coded neurons do not communicate through discrete spike events but through instantaneous firing rates (real values computed at each step of the simulation).</s><s>Rate-coded simulators are either restricted to classical neural networks (static neurons learning with the backpropagation algorithm) or optimized for particular structures such as convolutional networks.</s><s>To our knowledge, no rate-coded simulator provides a flexibility similar to what Brian proposes.</s><s>The Emergent simulator <ref type="bibr" target="#b0">(Aisa et al., 2008)</ref> provides some features-including parallel computing-and is used in a number of models in computational neuroscience (e.g., <ref type="bibr" target="#b41">O'Reilly and Frank, 2006)</ref> but is restricted to a set of neuron and synapse models provided by the Leabra library.</s><s>Topographica <ref type="bibr" target="#b1">(Bednar, 2009)</ref> and CNS (Cortical Network Simulator, <ref type="bibr" target="#b37">Mutch et al., 2010)</ref> primarily focus on convolutional networks.</s><s>DANA (Distributed, Asynchronous, Numerical and Adaptive computing framework, <ref type="bibr" target="#b43">Rougier and Fix, 2012</ref>) is a generic solver for distributed equations which can flexibly simulate dynamical rate-coded networks, but it does not address parallel computing yet.</s></p><p><s>Rate-coded networks are nevertheless an important paradigm in computational neuroscience, as they allow to model complex structures and dynamics with a smaller computational footprint than spiking networks.</s><s>Each unit of a rate-coded network can model the dynamics of several biological neurons, so a ratecoded network typically requires less units to perform a function than a functionally equivalent spiking network.</s><s>The rate-coded domain also benefits from a wide range of biologically realistic learning rules-such as the Bienenstock-Cooper-Munro (BCM) rule <ref type="bibr" target="#b5">(Bienenstock et al., 1982)</ref> or the Oja learning rule <ref type="bibr" target="#b40">(Oja, 1982)</ref>.</s><s>Synaptic plasticity in spiking networks, including spiketiming dependency plasticity (STDP), is an active research field and the current implementations can be hard to parameterize.</s><s>Except in cases where synchronization mechanisms take place or where precise predictions at the single-cell level are required, rate-coded networks can provide a valid approximation of the brain's dynamics at the functional level, see for example models of reinforcement learning in the basal ganglia <ref type="bibr" target="#b41">(O'Reilly and Frank, 2006;</ref><ref type="bibr" target="#b18">Dranias et al., 2008;</ref><ref type="bibr" target="#b44">Schroll et al., 2014)</ref>, models of visual attention <ref type="bibr" target="#b55">(Zirnsak et al., 2011;</ref><ref type="bibr" target="#b4">Beuth and Hamker, 2015)</ref> or models of gain normalization <ref type="bibr" target="#b11">(Carandini and Heeger, 2012)</ref>.</s></p><p><s>Another reason why rate-coded networks should not be neglected by neural simulators is that advances in computational neuroscience allow to aim at complete functional models of the brain which could be implemented in simulated agents or robots (e.g., <ref type="bibr" target="#b19">Eliasmith et al., 2012)</ref>.</s><s>However, spiking networks may not yet be able to perform all the required functions, especially when in a learning context.</s><s>Hybrid architectures, combining ratecoded and spiking parts, may prove very useful to achieve this goal.</s><s>We consider there is a need for a parallel neural simulator which should: (1) be flexible for the definition of neuron and synapse models, (2) allow the definition of rate-coded, spiking and hybrid networks, (3) be computationally efficient on CPUand GPU-based hardware and (4) be easy to interface with external programs or devices (such as robots).</s></p><p><s>This article presents the neural simulator ANNarchy (Artificial Neural Networks architect) which allows to simulate rate-coded, spiking as well as hybrid neural networks.</s><s>It proposes a high-level interface in Python directly inspired from PyNN for the global structure and Brian for the definition of neuron and synapse models.</s><s>It uses a C++ code generation approach to perform the simulation in order to avoid the costs of an interpreted language such as Python.</s><s>Furthermore, rate-coded and spiking networks raise different problems for parallelization <ref type="bibr" target="#b16">(Dinkelbach et al., 2012)</ref>, so code generation ensures the required computations are adapted to the parallel framework.</s><s>ANNarchy is released under the version 2 of the GNU Public License.</s><s>Its source code and documentation 2 are freely available.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Interface of the Simulator</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Structure of a Network</head><p><s>The interface of ANNarchy focuses on the definition of populations of neurons and their interconnection through projections.</s><s>Populations are defined as homogeneous sets of identical neurons, while projections gather all synapses formed between the neurons of the pre-synaptic population and the ones of the post-synaptic population.</s><s>Each projection is associated to a target name (e.g., "exc" for excitatory synapses and "inh" for inhibitory ones).</s><s>This allows the post-synaptic neurons receiving these synapses to integrate them differently, for example to implement modulatory effects.</s><s>The target can represent the excitatory/inhibitory nature, the corresponding neurotransmitter ("ampa, " "nmda, " "gaba") or even the functional role of a synapse ("feedforward, " "feedback").</s></p><p><s>Figure <ref type="figure">1</ref> shows a simple example implementing the pulsecoupled spiking network proposed by <ref type="bibr" target="#b30">Izhikevich (2003)</ref>.</s><s>It creates a population of 1000 Izhikevich neurons and splits it into two subsets of 800 excitatory and 200 inhibitory neurons each.</s><s>These neurons are reciprocally connected with each other (all-to-all connection pattern) through excitatory and inhibitory synapses.</s><s>Such a pulse-coupled network exhibits oscillating pattern at various frequencies, depending on the strength of the connections.</s><s>The example uses Izhikevich neurons, which are defined by Equation (1):</s></p><formula xml:id="formula_0">I(t) = g exc (t) − g inh (t) + n • χ dv(t) dt = 0.04 • v(t) 2 + 5 • v(t) + 140 − u(t) + I(t) du(t) dt = a • (b • v(t) − u(t)) if v(t) &gt; v thresh : v(t) = c and u(t) += d</formula><p><s>(1) with I(t) being the total input current to a neuron at time t, g exc (t) (resp.</s><s>g inh (t)) the total current current injected by excitatory FIGURE 1 | ANNarchy script reproducing the pulse-coupled spiking network described in <ref type="bibr" target="#b30">Izhikevich (2003)</ref>.</s><s>A population of 1000 Izhikevich neurons is created and split into subsets of 800 excitatory and 200 inhibitory neurons.</s><s>The different parameters of the Izhikevich neuron are then initialized through attributes of the two populations.</s><s>a, b, c, and d are dimensionless parameters, noise is a multiplicative factor on the random variable Normal(0., 1.) drawn each step from the standard normal distribution N (0, 1), v_thresh is the spiking theshold of the neurons and tau is the time constant in milliseconds of the membrane conductances.</s><s>The network is fully connected, with weight values initialized randomly using uniform distributions whose range depend on the pre-synaptic population.</s><s>The source code for the network is then generated, compiled and simulated for 1000 ms.</s></p><p><s>(resp.</s><s>inhibitory) synapses, v(t) the membrane potential and u(t) a recovery variable.</s><s>χ is an additive random variable following a standard normal distribution and n a multiplicative factor.</s><s>When the membrane potential v(t) exceeds a threshold v thresh , a spike is emitted, the membrane potential is reset and the recovery variable is incremented.</s><s>a, b, c, and d are dimensionless parameters specifying the dynamics of the neuron type.</s></p><p><s>Populations are defined by three fields: (1) the geometry, which can represent either the total number of neurons (a single integer) or a multi-dimensional structure (tuple) similar to the shape of a Numpy array <ref type="bibr" target="#b48">(van der Walt et al., 2011)</ref>; (2) the type of neuron used in the population (either a pre-defined neuron model or one defined by the user, see Sections 2.3 and 2.4) and (3) an optional unique name allowing to access the population globally.</s><s>Defining a multi-dimensional geometry is primarily useful for visualization purposes and when defining distancedependent connection patterns between two populations, but the internal data is arranged in one-dimensional arrays (see Section 3.1).</s></p><p><s>Once the populations are created, the value of each parameter and variable can be directly set using population attributes, by providing either a single value (which will be the same for all neurons) or lists/Numpy arrays of the same size/shape as the population.</s><s>Like many other simulators, but unlike Brian, parameters and variables use implicit physical units: except for time which is expressed in milliseconds, the user must decide if the value of a variable represents volts or millivolts, for example.</s><s>Brian uses explicit physical units, which allows to ensure consistency between the parameters.</s><s>The neurons of a population can be accessed either individually or in subsets (similar to the PopulationViews of PyNN), allowing a finer control over the parameter values.</s><s>Subsets use the slice notation of NumPy.</s></p><p><s>Projections are defined by four values: (1) the pre-synaptic population, (2) the post-synaptic population, (3) the associated target (e.g., "exc" or "inh") and (4) optionally the synapse type.</s><s>Subsets of a population can also be used to create the projection.</s><s>A connecting method has to be applied on the projection in order to create the synapses using a pre-defined scheme and initialize the corresponding weights and delays.</s><s>The network is here fully connected, using the connect_all_to_all() method.</s><s>Several methods are provided by the simulator (allto-all, one-to-one, distance-dependent, probabilistic. . . ) but the user can also define its own connection patterns in Python, or load connection matrices from a file.</s><s>Compatibility with the Connection Set Algebra proposed by <ref type="bibr" target="#b17">Djurfeldt (2012)</ref> is currently under development.</s></p><p><s>Once the populations and projections are defined and initialized, the corresponding C++code has to be generated and compiled by calling the compile() method.</s><s>If the network structure has not changed since the last execution of the script, compilation is skipped.</s><s>The C++ structures storing the parameters and variables of the populations and projections are then initialized with the values previously defined.</s><s>The network can be then simulated for a certain duration in milliseconds.</s><s>The values of all population/projection attributes can be read and modified at any point between two calls to simulate(), allowing an easy definition of complex experimental protocols.</s><s>This simple script outlines the high-level interface necessary to create a network: in its most simple form, all implementation details (including the neuron/synapse models) are hidden to the user.</s><s>At this level, there is also no distinction between ratecoded and spiking networks.</s><s>This distinction only appears when defining or using neuron and synapse models.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Equation-Oriented Description</head><p><s>Neuron and synapse models are described using an equationoriented approach, where each equation is expressed by a simple textual description.</s><s>The goal of the syntax is to provide a high flexibility to the user while being close to natural mathematical descriptions <ref type="bibr" target="#b47">(Stimberg et al., 2014)</ref>.</s><s>Our equationoriented syntax has been designed to be close to the Brian syntax <ref type="bibr" target="#b25">(Goodman and Brette, 2008)</ref>, although some differences had to be introduced to take into account the semantic difference between rate-coded and spiking neurons.</s></p><p><s>The syntax chosen for the equations ruling each variable allows to describe most common mathematical operations.</s><s>Each variable has to be described by an equation, either regular or differential.</s><s>For the moment, ANNarchy only supports first-order ordinary differential equations (ODE).</s><s>For regular equations, the left side must hold only the name of the variable which will be updated (e.g., a = b + c).</s><s>The available operators are assignment (=) and the different augmented assignments (+=, -=, * =, /=).</s><s>For ODEs, the left term can be more complex (tau * dv/dt + v = E is the same as dv/dt = (E -v)/tau), but only the assignment operator is allowed.</s><s>The right term can use single operations (+, -, * , /) or power functions (y^d) of other parameters or variables.</s><s>Different mathematical functions are available (given they exist in the C math library), for example cos, sin, exp, log. . .</s><s>Conditional statements (if/then/else) can be useful for some rate-coded neurons, although they are classically avoided in spiking neurons.</s><s>They follow a Python-like syntax using the if and else keywords and : as a separator.</s><s>The rectifier transfer function can for example be implemented like this: r = if v &gt; 0.0: v else: 0.0 with r being the output of a neuron and v its net activation.</s><s>The condition can use any parameters or variable of the neuron or synapse.</s><s>All relational operators are available (&lt;, &gt;, &lt;=, &gt;=, ==, !=. . .</s><s>), and they can be combined using the and and or logical operators.</s><s>Conditioal statements can be nested.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Rate-coded Neurons and Synapses</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.1.">Rate-coded Neurons</head><p><s>The definition of a rate-coded neuron model is done by instantiating a Neuron object, with arguments specifying the parameters and variables of the neuron.</s><s>Let us consider a simple noisy leaky-integrator rate-coded neuron:</s></p><formula xml:id="formula_1">τ • dr(t) dt + r(t) = N i=1 w i • r i (t) + B(t) + U(−1, 1)<label>(2)</label></formula><p><s>where r(t) is the instantaneous firing rate of the neuron at time t, τ its time constant, B(t) its baseline firing rate (which can change over time), U(−1, 1) a random variable taken at each time t in the uniform range [−1, 1] in order to add noise and N i=1 w i • r i represents the weighted sum of excitatory inputs to a particular neuron.</s><s>Figure <ref type="figure" target="#fig_0">2A</ref> shows a possible implementation of such a neuron in ANNarchy.</s></p><p><s>The first argument parameters is a string or multi-line string defining two parameters: tau, the time constant of the neuron, initialized to 10 ms, and B, the baseline firing rate, initialized to 0. Parameter definitions can be placed on different lines or separated by semi-colons.</s><s>Once a population is created, these parameters are accessible and modifiable through population attributes.</s><s>Various flags can be set after the : symbol.</s><s>In this example, the flag population tells the code generator that the value of tau will be shared by all neurons of a population, so it only needs to store one value.</s><s>It is also possible to specify the type of the parameter: parameters (and variables) are by default represented by double precision floating-point values.</s><s>The int and bool flags change the type of the attribute to integer or boolean, if needed.</s></p><p><s>The second argument equations defines the variables of the neuron, whose value will evolve with time during the simulation.</s><s>The number of variables defined in the model is unlimited, but at least one of them should be named r, as this is the default variable used by post-synaptic neurons to compute their weighted sum of inputs.</s><s>The code corresponding to Equation ( <ref type="formula" target="#formula_1">2</ref>) is straightforward.</s><s>The temporal derivative of r(t) is symbolized by the term dr/dt.</s><s>The random variable U(−1, 1) is generated by the term Uniform(-1.0, 1.0), where -1.0 and 1.0 and the FIGURE 3 | Examples of spiking neuron and synapse definitions.</s><s>(A) Izhikevich neuron.</s><s>The parameters and equations fields follow the same principles as for rate-coded neurons.</s><s>The variable I gathers the inputs to the neuron, namely the sum of the excitatory g_exc and inhibitory g_inh input currents and a constant current i_offset.</s><s>The membrane potential v and the recovery variable u are updated according to the desired dynamics, with initial values specified with the init keyword.</s><s>The spike field defines the condition for emitting a spike, here when the membrane potential v exceeds the threshold v_thresh.</s><s>The reset field specifies the modifications happening after a spike is emitted.</s><s>Here the membrane potential is clamped to the value c and the recovery variable u is incremented by d.</s><s>The refractory period is determined by the refractory field, here 2 ms.</s><s>(B) Short-term plasticity (STP) synapse.</s><s>For this synapse, the increment of the post-synaptic conductance g_target when a pre-synaptic spike arrives depends not only on the synaptic efficiency w, but also on the value of variables internal to the synapse x and u.</s><s>These are updated through two mechanisms: the equations field specifies their exponentially-decreasing dynamics, while the pre_spike defines their increments when a pre-synaptic spike arrives at the synapse.</s><s>However, the integration of the corresponding ODEs is event-driven through the use of the event-driven flag: when a pre-or post-synaptic spikes occurs, the new value of these variables is directly computed using the analytical solution of the ODE.</s><s>This can speed up the simulation if the number of spiking events is low.</s><s>(C) Spike-timing dependent plasticity (STDP) synapse.</s><s>For this synapse, the post-synaptic conductance is increased by w after a pre-synaptic spike is received, but the synaptic efficiency is adapted depending on two internal variables Apre and Apost.</s><s>The pre_spike field states what should happen when a pre-synaptic spike arrives at the synapse, while the post_spike field describes the changes occuring when the post-synaptic neuron fires.</s><s>The variables Apre and Apost are integrated in an event-driven manner.</s><s>The clip() function is used to maintain w in the range [0, w_max].</s><s>(D) NMDA non-linear synapse.</s><s>This synapse does not transmit information to the post-synaptic neuron in an event-driven manner.</s><s>Rather, the synaptic variable g is summed at each time step by the post-synaptic neuron, as for rate-coded networks.</s><s>This is specified by the psp field.</s><s>When a pre-synaptic spike occurs, the variable x is increased by w, which in turn will modify the evolution of g through the coupled equations described in the equations field.</s><s>These equations cannot be solved with the event-driven method, as their values should be available at each time step.</s></p><p><s>bounds of the uniform range.</s><s>Different distributions can be used in an equation, including the normal, log-normal, exponential and gamma distributions.</s><s>The weighted sum of excitatory inputs is represented by sum(exc), which sums over all projections possibly reaching a particular neuron the product between the connection weight w and the firing rate of the pre-synaptic neuron r.</s><s>The term exc corresponds to the target name defined when creating the projections.</s><s>By default, this ODE will be solved using the explicit (forward) Euler method, but other methods are available, see Section 3.4.</s><s>The flag init defines the initial value of the variable for all neurons and min defines a lower bound for the variable (if r is negative after an update, it will be set to 0), as the firing rate r is usually ensured positive in rate-coded networks.</s><s>The max flag is also available.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.2.">Rate-coded Synapses</head><p><s>When the pre-synaptic population of a projection is rate-coded, the synapses of the projection are assumed to be also ratecoded.</s><s>A synapse is represented by a fixed connection weight (or synaptic efficiency) named w and a delay in synaptic transmission d (in milliseconds).</s><s>Each synapse will participate in the weighted sum of inputs of the post-synaptic neuron with w(t) * r(t − d), where r(t − d) is the firing rate of the pre-synaptic neuron at time t − d.</s><s>Synaptic delays in a network must be a multiple of the fixed integration step dt (see Section 3.4), but each synapse of a projection can define a different delay.</s><s>The minimal delay is dt, as neurons can only access the value of variables computed at the previous time step (synchronous computation).</s><s>Note that the Brian simulator can simulate rate-coded synapses, but only without delay.</s></p><p><s>In a learning context, connection weights evolve with time according to a variety of learning rules <ref type="bibr" target="#b15">(Dayan and Abbott, 2001)</ref>.</s><s>Synapse models can be created to override the default behavior and implement synaptic plasticity or non-linear transmission.</s><s>Figure <ref type="figure" target="#fig_0">2B</ref> shows a possible implementation of the IBCM learning rule (Intrator and Cooper form of the BCM rule) <ref type="bibr" target="#b29">(Intrator and Cooper, 1992)</ref>.</s><s>It is a Hebb-like product of the presynaptic firing rate and a quadratic function of the post-synaptic firing rate.</s><s>The quadratic function uses a dynamical threshold θ (t) which is defined as the expectation of the square of the post-synaptic firing rate:</s></p><formula xml:id="formula_2">θ (t) = E(y 2 (t)) dw(t) dt = y(t) • (y(t) − θ (t)) • x(t)<label>(3)</label></formula><p><s>where x(t) is the pre-synaptic firing rate, y(t) the post-synaptic one, w(t) the connection weight and θ (t) is defined as the moving average of y 2 (t) through the E() expectation operator.</s><s>In the code displayed on Figure <ref type="figure" target="#fig_0">2B</ref>, the moving average is calculated using a first-oder ODE integrating the square of the post-synaptic firing rate, with a time constant tau of 2 s by default.</s><s>Pre-and postsynaptic neural variables (usually the firing rate r, but any other variable can be used) can be accessed by prefixing the variable name by pre. and post., respectively.</s><s>The update rule for the weight w is simply derived from Equation (3) using these conventions.</s><s>theta is a post-synaptic variable, as it only depends on the post-synaptic neural activity.</s><s>It would therefore be a waste of resources to compute it for each synapse: once per post-synaptic neuron is enough.</s><s>The equation for theta (as well as the corresponding parameter tau) is associated with the flag postsynaptic, which has a similar meaning as population for a neuron: the global variable will be updated only once per post-synaptic neuron.</s><s>The variable w is local to a synapse, so the flag should not be set.</s><s>Instead, min=0.0 is used to ensure that the weight will not become negative over time.</s></p><p><s>In a rate-coded neuron model, the term sum(exc) represents by default the weighted sum of excitatory inputs to this neuron.</s><s>It is possible to change this behavior in the synapse definition by adding a psp argument to the synapse definition, whose default value is "w * pre.r".</s><s>Non-linear synapses, where for example w i • log(r i ) should be summed over all synapses instead of w i • r i , can be implemented by setting psp = "w * log(pre.r)".</s><s>The summation operation can also be changed, by defining the operator argument, whose default value is "sum".</s><s>If "max", "min" or "mean" is used, the maximal (resp.</s><s>minimal or mean) value of psp is calculated over all synapses associated to the target exc will be returned by sum(exc).</s><s>This is particularly useful for pooling operations, which are used for example in hierarchical visual processing <ref type="bibr" target="#b42">(Riesenhuber and Poggio, 1999;</ref><ref type="bibr" target="#b27">Hamker, 2004)</ref>.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.">Spiking Neurons and Synapses</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.1.">Spiking Neurons</head><p><s>Integrate-and-fire neurons (IF) describe the temporal evolution of the membrane potential v(t) through a system of firstorder ODEs.</s><s>When the membrane potential exceeds a given threshold, a spike is emitted and the value of the different neural variables is clamped to a reset value for a certain duration called the refractory period.</s><s>The condition for spike emission as well as the reset and refractory behaviors have to be explicitly defined in addition to the internal dynamics.</s><s>More complex spiking neurons such as the Hodgkin-Huxley neuron model have their own dynamics for the reset and refractory mechanisms.</s><s>Figure <ref type="figure">3A</ref> shows a possible implementation of the Izhikevich neuron described by Equation ( <ref type="formula">1</ref>).</s></p><p><s>As for rate-coded neurons, the argument parameters describes the different parameters of the neuron model: a, b, c and d are dimension-less parameters, v_thresh is the spiking threshold, noise is a multiplying factor on the noise random variable and tau is the time constant in milliseconds of the conductances.</s><s>The argument equations describes the evolution of the three variables I, v and u of Equation (1).</s><s>Normal(0., 1.) is a random variable taken fromthe standard normal distribution.</s><s>g_exc and g_inh represent the total excitatory and inhibitory currents or conductances generated by incoming pre-synaptic spikes.</s><s>They are the equivalent for spiking neurons of sum(exc) and sum(inh) for rate-coded neurons.</s><s>The syntax g_target is different from the rate-coded case because they have a different behavior: while sum(target) is computed at every time step of the simulation by summing pre-synaptic activity, g_target is event-driven.</s><s>Every time a pre-synaptic spike arrives to a neuron, the corresponding conductance is increased from a value corresponding to the weight (or efficiency) w of the synapse.</s><s>If no spike arrives, the conductance evolves with its own dynamics, independently from inputs.</s></p><p><s>The default behavior for conductances is governed by instantaneous synapses: once all the incoming spikes have been summed, the total conductance is reset to 0 for the next time step.</s><s>More realistic models use exponentially decreasing or alpha (double exponential) functions to model the dynamics of the conductance.</s><s>The example of Figure <ref type="figure">3A</ref> uses exponentially decreasing synapses, by specifying a linear first-order ODE for the conductances g_exc and g_inh.</s><s>If no spike arrives for a certain duration, the conductances will progressively decay back to 0, with a time constant defined by the parameter tau.</s></p><p><s>Two other arguments of the Neuron object have to be defined: spike defines the spiking condition, i.e., the condition that must be satisfied in order to emit a spike (typically when the membrane potential exceeds a given threshold); reset describes what should happen after a spike is emitted.</s><s>The spiking condition has to be a boolean expression; it can depend on any parameter or variable, possibly combined through the logical operators and and or.</s><s>The reset statement forces some neural variables to take predefined values after a spike is emitted: here the membrane potential is clamped to a reset value c and the recovery variable is incremented by d.</s></p><p><s>Spiking neurons can also define a refractory period, during which the ODEs are not evaluated (i.e., the membrane potential stays at its reset value), except for the conductances g_exc and g_inh.</s><s>This corresponds to the hyper-polarized state of a neuron after spike emission, where no spike can be further emitted.</s><s>The duration of this refractory period is set through the refractory argument, which takes here a constant value of 2 ms, but the name of a parameter or variable can be given, allowing for dynamical refractory period: for example, the refractory period can be progressively increased if the firing rate becomes too high.</s></p><p><s>As shown in <ref type="bibr" target="#b47">Stimberg et al. (2014)</ref>, the five arguments parameters, equations, spike, reset, and refractory are sufficient to describe the dynamics of most point-spiking neurons, including IF and Hodgkin-Huxley models, and are directly related to the Brian syntax (although parameters is implicit in Brian).</s><s>They are not well suited to describe multicompartment models, which are the main focus of simulators such as NEURON or GENESIS.</s><s>However, Brian 2 introduces support for this kind of models.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.2.">Event-driven Synaptic Transmission</head><p><s>Synaptic behavior in spiking networks is also different from rate-coded networks, and requires additional description.</s><s>The basic type of synapses is the linear synapse, where synaptic transmission is event-driven: when the pre-synaptic neuron emits a spike, it increases the corresponding post-synaptic conductance by a given value (generally the synaptic efficiency w).</s><s>If no spike occurs, the synapse does not need to transmit any information: the dynamics of conductances are already defined at the post-synaptic neuron level.</s><s>As in Brian, a spiking synapse can therefore define two additional arguments: pre_spike which specifies what should happen when a pre-synaptic spike arrives at the synapse (potentially after a given delay) and post_spike when the post-synaptic neuron emits a spike.</s><s>The default linear synapse only defines pre_spike with the value g_target += w. g_target is a generic name for the conductance associated to the synapse.</s><s>Depending on the target of the projection, g_target will be replaced by g_exc or g_inh, for example.</s><s>The underlying idea is that the same synapse type can be used in different projections, regardless of their target.</s><s>Some event-driven synapse models modify the post-synaptic conductance with a value depending on specific synaptic variables.</s><s>This is for example the case in short-term plasticity (STP) synapses <ref type="bibr" target="#b35">(Markram et al., 1998)</ref>, where the increment of the post-synaptic conductance depends on the history of the synapse.</s><s>Frequent stimulation of a facilitating synapse leads to an increased influence on the post-synaptic neuron, while depressing synapses show the opposite effect.</s><s>A possible model of STP synapses uses two internal variables u(t) and x(t), which evolve continuously according to linear ODEs:</s></p><formula xml:id="formula_3">τ rec • dx(t) dt = 1 − x(t) τ facil • du(t) dt = U − u(t)<label>(4)</label></formula><p><s>When a pre-synaptic spike arrives at the synapse, the postsynaptic conductance should be incremented with w(t)•u(t)•x(t), while the synaptic variables should be modified according to:</s></p><formula xml:id="formula_4">x(t) ← x(t) • (1 − u(t)) u(t) ← u(t) + U • (1 − u(t))<label>(5)</label></formula><p><s>Figure <ref type="figure">3B</ref> shows an implementation of a synapse with shortterm plasticity.</s><s>The parameters are tau_rec, tau_facil, and U, which define the dynamics of the synapse and whether it is facilitating or depressing.</s><s>The two variables u and x directly relate to Equation (4).</s><s>The pre_spike argument defines what should be modified when the pre-synaptic spike occurs: g_target should be incremented with w * u * x instead of w by default, and u and x are modified according to Equation (5).</s></p><p><s>The equations for u and x use the flag event-driven.</s><s>As explained later in Section 3.4, this defines the numerical method used to integrate the ODE.</s><s>Here both variables are defined by first-order linear ODEs, so their current value can be directly calculated whenever a pre-or post-synaptic spike occurs, based on the time elapsed since the last event (exponentially decreasing function of time).</s><s>This can spare a lot of computations if the number of spikes in the network is not very high.</s></p><p><s>An event-driven synapse does not need to rely only on spike times for its dynamics.</s><s>As for rate-coded synapses, it can access pre-and post-synaptic variables during updates: the pre-(resp.</s><s>post-) synaptic membrane potential is accessed with pre.v (resp.</s><s>post.v).</s><s>Pre-synaptic variables are delayed if necessary.</s><s>However, only the post-synaptic conductance g_target can be modified by a synapse, contrary to Brian 2.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.3.">Synaptic Plasticity</head><p><s>Synaptic plasticity can also be described using event-driven mechanisms: the weight w of a synapse usually only needs to be updated when a pre-or post-synaptic spike occurs.</s><s>Most biologically-realistic synaptic plasticity mechanisms in spiking networks indeed derive from the spike timing dependent plasticity (STDP) rule <ref type="bibr" target="#b23">(Gerstner et al., 1996;</ref><ref type="bibr" target="#b34">Markram et al., 1997)</ref>.</s><s>Although many different implementations exist, there is an online version of STDP which is event-driven <ref type="bibr" target="#b46">(Song et al., 2000)</ref>.</s><s>With this rule, each synapse integrates two variables A pre (t) and A post (t) which represent traces of the pre-and post-synaptic spikes, respectively.</s><s>Between two spikes, they follow linear firstorder ODEs:</s></p><formula xml:id="formula_5">τ + • dA pre (t) dt = −A pre (t) τ − • dA post (t) dt = −A post (t)<label>(6)</label></formula><p><s>When a pre-synaptic spike occurs, the pre-synaptic trace A pre (t) is incremented by a fixed value, and at the same time the postsynaptic trace A post (t) is substracted from the synaptic efficiency w(t), allowing long-term depression (LTD):</s></p><formula xml:id="formula_6">A pre (t) ← A pre (t) + A + • w max w(t) ← w(t) − A post (t) (7)</formula><p><s>with w max being the maximal value allowed for the weight.</s><s>When a post-synaptic spike occurs, the post-synaptic trace is incremented, and the synaptic efficiency w(t) is increased from the pre-synaptic trace, allowing long-term potentiation (LTP):</s></p><formula xml:id="formula_7">A post (t) ← A post (t) + A − • w max w(t) ← w(t) + A pre (t) (8)</formula><p><s>Figure <ref type="figure">3C</ref> shows a possible implementation of this STDP plasticity rule.</s><s>The equations for Apre and Apost can be integrated with an event-driven method, as their value is only required when a pre-or post-synaptic spike occurs.</s><s>Synaptic transmission is linear, so pre_spike defines g_target += w.</s></p><p><s>The increments in pre_spike and post_spike follow Equations ( <ref type="formula">7</ref>) and ( <ref type="formula">8</ref>), while the weight w is clipped between 0 and w max by using the clip function.</s><s>An alternative implementation could have used the min and max flags instead of the clip function, as w is a variable of the synapse.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.4.">Continuous Synaptic Transmission</head><p><s>In some cases, synaptic transmission cannot be described in an event-driven framework.</s><s>Synapses using the NMDA neurotransmitter are for example often modeled as non-linear synapses <ref type="bibr" target="#b50">(Wang, 2002)</ref>.</s><s>These synapses require the post-synaptic conductance to be a sum of synapse-specific variables, as for rate-coded neurons, and not simply incremented when a presynaptic spike occurs.</s><s>This is similar to the summed flag of Brian 2. NMDA synapses can be represented by two variables x(t) and g(t) following first-order ODEs:</s></p><formula xml:id="formula_8">τ • dx(t) dt = −x(t) τ • dg(t) dt = −g(t) + x(t) • (1 − g(t))<label>(9)</label></formula><p><s>When a pre-synaptic spike occurs, x(t) is incremented by the weight w(t).</s><s>However, it does not directly influence the postsynaptic neuron, as the output of a synapse is the signal g(t).</s><s>The post-synaptic conductance is defined at each time t as the sum over all synapses of the same type of their variable g(t):</s></p><formula xml:id="formula_9">g exc (t) = N exc i=1 g i (t) (10)</formula><p><s>Figure <ref type="figure">3D</ref> shows a possible implementation of such a non-linear NMDA synapse.</s><s>The main difference with the previous models is that it defines a psp argument which means that the post-synaptic conductance should be summed over this value (g in this case) at every time step.</s><s>It is therefore not possible to use the eventdriven scheme for such non-linear synapses.</s><s>The psp argument can access any synaptic variable, as well as any pre-or postsynaptic variable.</s><s>For example, it can be used for gap junctions (also called electrical synapses) which do not exchange spikes but directly a function of the pre-and post-synaptic membrane potentials.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.">Additional Features</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.1.">Standard Neurons and Synapses</head><p><s>Although the definition of neuron and synapse types is rather simple, the library provides a set of predefined models which can be used directly when creating populations and projections.</s><s>Spiking neuron models are conveniently standardized, especially since the introduction of the PyNN interface <ref type="bibr" target="#b14">(Davison et al., 2008)</ref>  <ref type="bibr">process)</ref>.</s><s>The SpikeArray class allows to create a population and to specify for each neuron the exact times at which they will emit a spike.</s><s>These spiking times can be modified between two simulations using attributes.</s></p><p><s>The ImagePopulation class allows to represent images through the firing rates of a rate-coded population with the same geometry as the image (two-dimensional for grayscale, three for colored images, the last dimension representing the R, G, and B components).</s><s>Firing rates are normalized between 0 and 1.</s><s>It relies on the Python Imaging Library (PIL), which allows the use of many file formats, including JPEG.</s><s>Similarly, the VideoPopulation class allows to grab image streams from webcams and use them as firing rates of a population.</s><s>It relies on the OpenCV 2.x C++ library to access the desired hardware.</s><s>Grabbing images has to be explicitly called by the user between two simulations.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.3.">Hybrid Networks</head><p><s>Apart from the neuron and synapse definitions, there is no difference in the interface between rate-coded and spiking networks: populations and projections behave the same regardless of the framework.</s><s>It then becomes possible to create hybrid networks, composed of rate-coded and spiking populations interacting with each other.</s><s>Interaction between the two types of neurons is achieved by introducing specific populations and projections to perform the conversion.</s></p><p><s>Converting a rate-coded population into a spiking one is straightforward: the output r of the rate-coded population is interpreted as an instantaneous firing rate in Hz and used to generate spikes according to a Poisson distribution.</s><s>The abovementioned PoissonPopulation object accepts a target argument, stating that the rate of each Poisson neuron is determined by its weighted sum of inputs: The connectivity matrix can have any form, but in the most simple case one single rate-coded neuron should determine the firing rate of a group of spiking neurons (one-to-many pattern).</s><s>The weight of the connection determines the scaling: a weight of 1.0 means that a pre-synaptic rate of 1.0 will generate Poisson spike trains at 1 Hz.</s><s>With a weight of 100.0, the train would be at 100 Hz.</s><s>Other distributions than Poisson will be added in future versions.</s></p><p><s>Converting a spiking population into a rate-coded one is a much more difficult problem.</s><s>Estimating neural firing rates from single spike trains instead of averaging over multiple trials is an open issue in neuroscience <ref type="bibr" target="#b13">(Cunningham et al., 2009)</ref>.</s><s>The main methods include peri-stimulus time histograms (PSTH, <ref type="bibr" target="#b22">Gerstein and Kiang, 1960)</ref>, smoothing kernels <ref type="bibr" target="#b38">(Nawrot et al., 1999)</ref>, Kalman filters <ref type="bibr" target="#b52">(Wu et al., 2004)</ref>, or Bayesian estimation <ref type="bibr" target="#b45">(Shimokawa and Shinomoto, 2009)</ref>.</s><s>All these methods are biased and can only infer firing frequencies in a particular bandwidth.</s></p><p><s>Here, the problem is even more difficult as it has to be performed online during the simulation: in the interval between two spikes of the same neuron, it is not possible to predict the real instantaneous firing rate of the neuron, as future incoming spikes are still unknown.</s></p><p><s>ANNarchy provides a simple method to infer online the firing rate of a spiking population, using the assumption that a ratecoded neuron usually represents a large group of spiking neurons.</s><s>The two populations are connected with a specific projection object DecodingProjection and a many-to-one pattern.</s><s>For example, a single rate-coded neuron could decode the firing rate of a population of 1000 Poisson neurons: The input sum(target) of a post-synaptic neuron at time t is a weighted sum of all spikes received during a sliding window of duration T (defined by the argument window), normalized by the total number of synapses to this neuron:</s></p><formula xml:id="formula_10">sum(target)(t) =</formula><p><s>Weighted sum of spikes received in [t − T, t] T * Number of incoming synapses (11) It approximates the mean firing rate in the pre-synaptic population during the last T milliseconds.</s><s>By default, T is equal to the simulation step dt, but the decoded rate may be fluctuating if the number of pre-synaptic neurons is too small.</s><s>One should either increase T or apply a low-pass filter to sum(target) in the post-synaptic neuron.</s><s>The weights of the projection can be used to scale the output firing rate: by default, an input firing rate at 1 Hz leads to sum(target)=1.0.</s></p><p><s>Figure <ref type="figure" target="#fig_3">4</ref> illustrates the use of hybrid networks.</s><s>A single ratecoded neuron is used to activate a population of 1000 Poisson neuron with a firing rate increasing every 250 ms (0, 10, 50, and 100 Hz). Figure <ref type="figure" target="#fig_3">4A</ref> shows a raster plot of the spikes emitted by the Poisson population.</s><s>Figure <ref type="figure" target="#fig_3">4B</ref> shows the original (blue) and decoded (green) firing rate, for a single rate-coded neuron connected to all 1000 Poisson neurons.</s><s>The projection uses a sliding window of 10 ms to smoothen the rate.</s><s>The decoded firing rate follows the original one, but with a small variance due to the stochastic nature of the Poisson spike trains, and with a small temporal lag corresponding to the sliding window: when the firing rate suddenly increases, it takes approximately T milliseconds to completely reflect the change.</s></p><p><s>Figure <ref type="figure" target="#fig_3">4C</ref> shows the effect of the number of connected neurons on the precision of the decoding.</s><s>For the three stimulations at 10, 50, and 100 Hz, we measure the mean of the normalized error between the decoded firing rate r(t) and its target value F ∈ [10, 50, 100]: ǫ = 1 250 250 t=0 |r(t)−F| F dt for post-synaptic neurons receiving 1-1000 inputs from the Poisson population.</s><s>Unsurprisingly, the more inputs are used for decoding, the better is the precision.</s><s>The sliding window method is also more precise at high frequencies, as more spikes can be used to estimate the firing rate.</s><s>The remaining error for a high number of neurons is mostly due to the temporal lag of the For small number of neurons, the decoding error is high as individual spike trains are stochastic.</s><s>When the number of neurons is increased (over 200), the decoding error is reduced.</s><s>Decoding is relatively more precise at high frequencies than at low ones.</s></p><p><s>integration.</s><s>The script allowing to reproduce Figure <ref type="figure" target="#fig_3">4</ref> is given in the Supplementary Material.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.4.">Weight Sharing and Convolution Operations</head><p><s>Regular projections instantiate a set of connection weights per post-synaptic neuron.</s><s>This can be a waste of resources when the weights are identical for each neuron, the only difference being the coordinates of the corresponding neurons in the pre-synaptic population, as it is the case in convolutional networks <ref type="bibr" target="#b33">(Lecun et al., 1998)</ref> or image filtering.</s><s>Such convolution operations can be implemented by creating a SharedProjection instead of a Projection and calling the "convolve()" connector method: proj = SharedProjection(pre=pop1, post=pop2, target='exc') proj.convolve(weights=kernel)</s></p><p><s>The generated code depends on the respective geometry of the pre-and post-synaptic populations, as well as on the weights kernel.</s><s>If they all have the same number of dimensions (for example two-dimensional), a regular convolution will be performed:</s></p><formula xml:id="formula_11">sum exc (x, y) = d i i=−d i d j j=−d j W(i, j) • pre.r(x − i, y − j)<label>(12)</label></formula><p><s>with (d i , d j ) representing the extent of the weights kernel W. If the pre-and post-populations do not have the same number of neurons in each dimension (for example 200 * 200 and 100 * 100, corresponding to a sub-sampling ratio of 2), the mapping between the coordinates of the post-synaptic neurons and the center of the corresponding pre-synaptic region is automatically computed, but this can be overwritten.</s></p><p><s>The convolution operation can also be performed in parallel over a specific dimension of the pre-synaptic population.</s><s>For example, if the last dimension of the population represents the RGB color channels of an image, the first two being the width and height, a two-dimensional filter can be applied on each color channel separately.</s><s>The post-synaptic population has then three dimensions too.</s><s>It is also possible to apply a bank of filters on the pre-synaptic population (e.g., edge detection with different orientations), leading to a post-synaptic population with one additional dimension (feature map).</s></p><p><s>Pooling (e.g., max-pooling) can also be implemented using a shared projection.</s><s>The operation must be specified when creating the projection, before calling the pooling connector method: proj = SharedProjection(pre=pop1, post=pop2, target='exc', operation='max') proj.pooling()</s><s>Each post-synaptic neuron will be associated to a region of the pre-synaptic population and will extract the maximal firing rate in this region, without defining any weight.</s><s>For example, if the two populations are 200 * 200 and 100 * 100, each postsynaptic neuron covers a 2 * 2 area.</s><s>The extent of the region is automatically computed based on the respective geometries, but this can be overwritten.</s><s>The operation can be changed to the minimal or mean firing rate in the region ('min' and 'mean').</s><s>Weight sharing is for the moment only possible for rate-coded networks and learning is disabled.</s><s>This will be improved in future versions.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.5.">Recording of Variables</head><p><s>All neural and synaptic variables (defined in the equations argument of a neuron or synapse) can be recorded during a simulation.</s><s>Populations (or subsets of a population) and projections can be associated to a Monitor object together with a list of variable names.</s><s>A frequency of recording can also be defined, e.g., once every 10 ms.</s><s>In the following calls to simulate(), the value of these variables for all neurons/synapses will be internally appended to a vector until get() is called, which returns a matrix containing the recorded values and empties the recording vectors.</s><s>Recording can be stopped, paused and resumed using methods of Monitor.</s></p><p><s>The advantage of this recording method is that the user is not bound to a specific file format: the returned values are a dictionary of Numpy arrays (one per variable) which can be directly manipulated or saved into a file.</s><s>The drawback is that the available RAM can quickly be filled, especially when recording synaptic variables such as weights.</s><s>It is the user's responsibility to record only the necessary periods of the simulation (using pause/resume) and to save intermediary results regularly.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.6.">Conditional Simulations</head><p><s>By default, simulate() runs the simulation for a fixed duration.</s><s>In some cases it may be useful to simulate until a criterion is reached, for example when the maximal firing rate in a population crosses a threshold, or a neuron has emitted a certain number of spikes.</s><s>This can be used to run conditional simulations, e.g., the network has made a decision and we need to perform the corresponding action.</s><s>Each population accepts a stop_condition argument, which states the condition that must be true to stop the simulation.</s><s>In the following example, the simulation would be stopped when one or more neurons of the population have a firing rate r higher than 1: pop1 = Population( ... , stop_condition = "r &gt; 1.0")</s></p><p><s>The stop condition can use any neural parameter or variable, and can combine several boolean predicates using the and, or, and not operators.</s><s>If the simulation should be stopped when the condition is true for all neurons, not just any of them, the : all flag can be appended to the condition.</s><s>The simulation can then be run with the simulate_until() method, which accepts a maximal duration for the simulation (if the criteria is never met) and a (list of) population(s) whose criteria should be checked.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.7.">Structural Plasticity</head><p><s>The number of synapses in a network is determined at the time when projections are created and is usually constant during the simulation.</s><s>Some networks require to dynamically add or remove synapses between neurons during the simulation, a mechanism called structural plasticity <ref type="bibr" target="#b10">(Butz et al., 2009)</ref>.</s><s>Projections define create_synapse() and prune_synapse() methods which allow to dynamically create or delete synapses between any pair of neurons.</s><s>These functions are called from Python, so the user has to regularly stop the simulation and check if the conditions for creating or deleting a synapse are met, depending on some neural or synaptic variable or randomly.</s><s>If the structural plasticity mechanism is applied frequently, it will slow down the simulation because of the constant switches between Python and C++.</s></p><p><s>Alternatively, simple rules for the creation or deletion of a synapse can be passed to the definition of the synapse model.</s><s>The pruning argument takes a simple boolean expression which, when true, will lead to the online deletion of the synapse.</s><s>Oppositely, the creating argument defines a binary condition which leads to the creation of a synapse if it does not exist yet.</s><s>Creation or deletion can be made probabilistic by passing the flag proba after the rule.</s><s>The weight and delay of created synapses can also be specified.</s></p><p><s>In the following example, each synapse updates an age variable which is incremented at each simulation step, but is reset to 0 when both pre-and post-synaptic neurons are simultaneously active.</s><s>When the age of a synapse exceeds a given threshold, the synapse is pruned with a probability of 0.5.</s><s>Similarly, a synapse can be created when two unconnected neurons are strongly active at the same time.</s></p><p><s>StructuralPlasticity = Synapse( parameters = "max_age = 1000.0</s><s>: postsynaptic", equations = "age = if pre.r * post.r</s><s>&gt; 0.9: 0.0 else: age + dt", pruning = "age &gt; max_age : proba=0.5",</s><s>creating = "pre.r</s><s>* post.r</s><s>&gt; 0.9 : proba=0.5, w=0.5" )</s></p><p><s>Creation and pruning of synapses have to be explicitly started with start_creating() and start_pruning() methods, which also accept a period argument defining how often the structural plasticity conditions will be checked (by default at every time step, which is computationally inefficient and probably unnecessary in most cases).</s><s>Structural plasticity is available for spiking networks, but creating and pruning can not be linked to events such as the emission of a spike: it must rely on continuous variables.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.8.">Reporting</head><p><s>As noted by <ref type="bibr" target="#b47">Stimberg et al. (2014)</ref>, the equation-based representation of neural networks allows the automatic documentation of models.</s><s>Parameters are known, equations can be parsed to L A T E X mathematical code, and the structure of the network is simply defined in terms of populations and projections.</s><s>User-defined neuron or synapse models can be documented by adding a name and a detailed text description of its behavior.</s><s>Calling the report() method will generate a complete L A T E X file, organized in tables as suggested by <ref type="bibr" target="#b39">Nordlie et al. (2009)</ref>.</s><s>It contains a summary of the network, a list of all the populations (including their size and the neuron model), a list of all the projections with a description of the connectivity and the synapse model, a textual description of each neuron and synapse models used in the network (with the parsed equations) and finally the initial value of the parameters used in each population and projection.</s><s>The generated file still requires some editing before being published, but it should ease the modeler's work.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Code Generation</head><p><s>The approach chosen for the neural simulator is based on a complete code generation mechanism.</s><s>As noted in <ref type="bibr" target="#b26">Goodman (2010)</ref>, code generation allows to couple the flexibility of a high-level language (here Python) with the speed and hardware specificities of a low-level language (C++).</s><s>This approach is used in Brian to speed up some code portions and is further extended in Brian 2 where a complete C++code for the network can be optionally generated at runtime (cpp_standalone mode, <ref type="bibr" target="#b47">Stimberg et al., 2014)</ref>.</s><s>ANNarchy relies entirely on this concept, by generating and compiling a shared C++ library during the call to compile().</s><s>Only this library will hold the data representing the model.</s><s>The library is then imported by the Python script which transfers the initial value of all parameters and variables and starts the simulation.</s><s>The Python script has only an indirect access to the C++ data and possible recordings through Cython wrappings.</s><s>Cython is a Python-like compiled language allowing to execute instructions at C-speed and to access C or C++ data structures and methods <ref type="bibr" target="#b2">(Behnel et al., 2009)</ref>.</s><s>Cython was for example used to create maintainable bindings to NEST <ref type="bibr" target="#b53">(Zaytsev and Morrison, 2014)</ref>.</s></p><p><s>The main advantage of a complete code generation in comparison to a simple interface to a low-level simulator (as in PyNest; <ref type="bibr" target="#b20">Eppler et al., 2008)</ref> is that it allows to optimize the execution regarding the structure of the network.</s><s>For example, if the model does not use delays in synaptic transmission (which require to implement queues for the output variables), or if no structural plasticity mechanism is involved (requiring more flexible data structures for the synapses), the corresponding code is not generated, reducing the complexity of the code and avoiding unnecessary overhead.</s><s>Furthermore, the code can be adapted to the parallel computing platform, either a shared memory system with OpenMP (the parallel strategy can be different depending on whether 4 or 256 cores are available) or a graphical processing unit with CUDA (depending on its model or version).</s><s>A drawback is that the structure of the network cannot be changed after the call to compile(): no population or projection can be added, or equations modified.</s><s>The only changes possible are parameter or variable values, as well as the dynamical addition or suppression of synapses in case of structural plasticity.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Internal Representation of Data</head><p><s>Each population and projection is represented by a C++structure storing each attribute, either a parameter or a variable.</s><s>Their name is easily extracted from the parameters and equations arguments to the neuron model: they are alone on the left side of the equation, except for ODEs where it is surrounded by d and /dt.</s><s>Local attributes of a population are represented by a standard C++ vector with as many elements as neurons in the population while global ones (annotated by the population flag) are represented by a single value.</s><s>Indexing is simple because all neurons have the same attributes.</s></p><p><s>For projections, the data representation depends on the platform: on shared memory systems with openMP, local attributes are represented by a vector of vectors, one per postsynaptic neuron receiving connections.</s><s>Each of these vectors represents all synapses reaching this post-synaptic neuron (they can have different sizes).</s><s>The connectivity matrix is therefore stored as a list of lists (LIL) structure in order to associate each value to the corresponding synapse.</s><s>On graphical cards with CUDA, the connectivity is stored in the compressed sparse row (CSR) format, where the values of each attribute are flattened into a single vector and a list of row pointers allow to attribute portions of this array to a single post-synaptic neuron (see <ref type="bibr">Brette and Goodman, 2011, for a review)</ref>.</s><s>These different data structures lead to a better parallel performance: CSR representations ensure a coalesced access to the attributes (i.e., the data is contiguous in memory), which is a strong condition for GPU computations to be efficient <ref type="bibr" target="#b8">(Brette and Goodman, 2012)</ref>, while the LIL structure allows a faster distribution of the data to the different OpenMP threads <ref type="bibr" target="#b16">(Dinkelbach et al., 2012)</ref>.</s><s>LIL and CSR representations have similar memory requirements, but LIL is more adapted to the dynamical addition or suppression of synapses: structural plasticity is very inefficient on the GPU platform and is currently disabled.</s></p><p><s>The ability to adapt the data structures to the hardware is a clear advantage of the code generation approach, especially when the number and type of attributes is a priori unknown.</s><s>These data structures can furthermore be easily exported to the Python namespace through the generation of Cython bindings, so the choice of the data structure is transparent to the user.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Simulation Steps</head><p><s>ANNarchy performs the simulation with an equidistant time grid, where the integration step size dt is fixed for all equations.</s><s>Although this scheme is natural for rate-coded networks, it can have a negative influence on spiking networks because of the forced alignment of spike times on this grid <ref type="bibr" target="#b36">(Morrison et al., 2007)</ref>.</s><s>Brian also allows the use of different clocks for different parts of the model, which is currently impossible in ANNarchy.</s><s>Future versions will address this issue.</s></p><p><s>Each simulation step is composed of several successive computational processes, which are mainly common to spiking and rate-coded networks:</s></p><p><s>1. Propagation: the results of the previous simulation step is propagated in the network.</s><s>For rate-coded projections, the weighted sum of pre-synaptic firing rates is accumulated in the post-synaptic population.</s><s>For spiking projections, the postsynaptic conductances are increased from the synaptic weight (or any other value defined in the pre_spike argument of the synapse) if the corresponding pre-synaptic neuron has emitted a spike.</s><s>The variable updates defined in pre_spike are also processed if they exist (e.g., in the STDP rule).</s><s>In both cases, if delays in synaptic transmission are defined, these operations are performed on the value of these variables at the corresponding time.</s><s>2. Neural update: the variables of each population are updated according to their definition in the equations argument of the neuron model.</s><s>For spiking populations, the spiking condition is then evaluated.</s><s>If the condition is met, the rank of the neuron is appended to a vector, the reset statement is evaluated and the neuron is possibly put into a refractory state.</s><s>However, if a spiking neuron is in the refractory state, only the ODEs corresponding to the conductances are updated until the refractory period has elapsed, so no spike can be emitted.</s><s>3. Delayed outputs: before the simulation starts, each population computes the maximal delay in synaptic transmission required by outgoing projections and instantiates a doubleended queue of the adequate size.</s><s>In this step, the new value of the output variable (firing rate or spike) is appended to the queue while the oldest value is removed.</s><s>4. Synaptic updates: the variables of each projection (if any) are updated, including synaptic plasticity. 5. Post-synaptic events: for each spiking projection where a post-synaptic neuron has emitted a spike, the post_spike statement is evaluated for all synapses reaching this neuron.</s><s>6. Structural plasticity: if structural plasticity is defined, the addition/suppression of synapses is evaluated.</s><s>7. Recording: each neural or synaptic variable is associated with a boolean flag which enables the recording of the variable with a given period.</s><s>When the criterion is met, the value of the variable is appended to a vector.</s></p><p><s>Finally, the internal time t is incremented.</s><s>These steps are all performed sequentially to ensure the correctness of the simulation.</s><s>Parallel computations only occur within each of these steps if possible.</s><s>The only difference between rate-coded and spiking networks are the pre_spike and post_spike statements, as well as the spike emission mechanism.</s><s>This common structure allows hybrid networks to be simulated.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Mathematical Parser</head><p><s>The different mechanisms described above are based on the equations defined at the neural or synaptic level.</s><s>As the simulation is performed in C++, the computations are not vectorized, so an update rule for the variable has to be defined for each neuron of a population or each synapse of a projection.</s><s>The transformation between the mathematical equation and the corresponding C++ code snippet is performed through the use of the Sympy library <ref type="bibr" target="#b31">(Joyner et al., 2012)</ref> coupled with regular expressions.</s><s>The first step in the analysis of a neuron or synapse model is to determine with regular expressions the list of parameters and variables (by analysing the left side of the equation), their locality (presence of population or postsynaptic in the flags), their type (int, float or bool), bounds (min and max), initial value (init) and eventually the associated numerical method.</s><s>The value of each parameter (e.g., tau = 10.0) is stored in a temporary dictionary which will be transferred to the C++library when it is instantiated.</s></p><p><s>For each variable, the equation is first manipulated to extract non-standard vocabulary.</s><s>For example, the weighted sum in a rate-coded neuron (sum(exc)) is extracted and replaced by a temporary variable name (_sum_exc_).</s><s>The same is done for random number distributions (Uniform(0, 1) is replaced by _rand_) and global operations (mean(pre.r)</s><s>by _mean_pre_r).</s><s>Conditional statements (if A: B else: C) are also extracted and each of the three terms are recursively analyzed.</s><s>These temporary variables are added to the list of parameters and variables of the model.</s><s>This list allows to build a dictionary where the correspondence between the name of an attribute and its C++ equivalent is calculated.</s><s>Each attribute belongs to a C++ structure representing a population or projection, so the name of the attribute must be prepended by the instance of the structure: pop%(id)s.</s><s>for populations, proj%(id)s.</s><s>for projections, where %(id)s will be replaced by the ID of the population or projection when the complete code is generated.</s><s>As the update will be performed in a loop over all neurons or synapses, the index of the neuron in its population <ref type="bibr">([i]</ref>) or of the synapse in the projection <ref type="bibr">([i][j]</ref> for the LIL structure) is appended to this name.</s><s>For example, the firing rate r of a neuron is represented by pop%(id)s.r[i]</s><s>while the weight of a synapse becomes (proj%(id)s.w</s></p><formula xml:id="formula_12">[i][j]).</formula><p><s>Once the dictionary is built, Sympy is able to directly generate the C++ code equivalent to each side of the equation: constants (such as numbers) and functions of the C math library are automatically recognized and correctly translated.</s><s>The temporary variables introduced for the weighted sums or random distributions are finally replaced by the adequate code thanks to regular expressions.</s><s>As an example, the following equation for a neuron:</s></p><formula xml:id="formula_13">r = sum(exc) + B + cos(2 * pi * t)</formula><p><s>with B being a global parameter and t the current time in milliseconds, leads to the following code:</s></p><formula xml:id="formula_14">pop%(id)s.r[i] = pop%(id)s.sum_exc[i] + pop%(id)s.B + cos(2.0 * M_PI * double(t) * dt))</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Numerical Methods</head><p><s>A special case has to be made for ODEs, as the desired numerical method will influence the resulting C++ code.</s><s>Additionally, a neuron or synapse can be described by a set of coupled ODEs, so the code generation must be performed globally depending on the numerical method.</s><s>We retained an approach similar to the one described in <ref type="bibr" target="#b47">Stimberg et al. (2014)</ref>, except that we do not explicitly generate an abstract code representation of the equations, but rather directly manipulate Sympy symbols.</s></p><p><s>To illustrate how the numerical methods are applied, we take the example of a simple spiking neuron defined by the Equation ( <ref type="formula" target="#formula_15">13</ref>), but the principle is similar for synapses or rate-coded models, regardless of the number of ODEs.</s></p><formula xml:id="formula_15">τ • dv(t) dt + v(t) = g exc (t) − u(t) τ • du(t) dt + u(t) = v(t)<label>(13)</label></formula><p><s>Such a neuron could be represented by the following description:</s></p><formula xml:id="formula_16">tau * dv/dt + v = g_exc -u tau * du/dt + u = v</formula><p><s>with tau being a global parameter of the population.</s><s>The problem to be addressed by the numerical method is to find the next value of the variables v and u based on the value they had at the previous time step and the current value of the conductance g_exc.</s><s>Figure <ref type="figure" target="#fig_4">5</ref> shows the code generated for these equations by the different available numerical methods (explicit, implicit, exponential and midpoint).</s><s><ref type="formula" target="#formula_15">13</ref>) using different numerical methods: 1. Explicit Euler; 2. Implicit Euler; 3. Exponential Euler; 4. Midpoint (Runge-Kutta method of order 2).</s><s>pop0 is a C++ structure holding the different attributes of the population: the vectors v and u for the two variables, the vector g_exc for the excitatory inputs and the double value tau for the time constant.</s><s>All methods compute first the increments _v and _u before adding them to v and u, in order to make sure the update rules use the previous values of these variables.</s><s>The number of elementary operations differs from one method to another, increasing the simulation runtime, but the numerical precision and stability of the more complex methods might be required in some cases.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.1.">Explicit Euler</head><p><s>The explicit (or forward) Euler method evaluates the gradients dv/dt and du/dt at the current time t.</s><s>In the textual representations of the equations, dv and du are simply replaced by two new variables _v and _u, and the system of equations is solved and simplified to find the value of these increments as a function of v, u, tau, and g_exc.</s><s>Here, the problem is simple because _v and _u are present only once per equation: the equations are not coupled.</s><s>The increments are translated into a C++code snippet using the same dictionary-based approach as for regular equations, and the increments are then added to the previous value of v and u.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.2.">Implicit Euler</head><p><s>The implicit (or backward) Euler method evaluates the gradients dv/dt and du/dt at the next time t + dt.</s><s>dv and du are replaced by _v -v and _u -u, where _v and _u represent the next value of the variables, and all occurrences of v and u are replaced by _v and _u.</s><s>This leads to a system of two linear equations with two variables, which is solved using the Sympy linear solver.</s><s>Contrary to the explicit method, the equations are coupled, and the solver will only succeed if the equations are linear in v and u.</s><s>The parser will return an error if not.</s><s>Once the solution is found, we subtract v and u to _v and _u and simplify the equation in order to find the increment that will be added to the previous value of the variables.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.3.">Exponential Euler</head><p><s>The exponential Euler method is a special forward method which has the smallest numerical error on uncoupled linear first-order ODEs.</s><s>The first step is to canonize each equation in the form τ • dx(t) dt + x(t) = A(t), with τ being the time constant of the variable and A(t) its steady state.</s><s>Here the equations are already in this form, but a conductance-based neuron with the equation tau * dv/dt + v = g_exc * (E-v) would have an equivalent time constant of tau/(1+g_exc) and a steady state of g_exc * E/(1+g_exc).</s><s>Once these equivalent time constants and steady states are identified and simplified for each equation, the increments can be directly obtained through:</s></p><formula xml:id="formula_17">x(t + dt) = x(t) + (1 − exp(− dt τ )) • (A(t) − x(t)))<label>(14)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.4.">Midpoint</head><p><s>The midpoint method is a Runge-Kutta method of order 2, described in <ref type="bibr" target="#b47">Stimberg et al. (2014)</ref>.</s><s>It evaluates successively the gradient at t and in the middle of the interval [t, t + dt].</s></p><p><s>The gradient at t is evaluated using the same mechanism as in the explicit Euler method and stored in the variables _k_v and _k_u.</s><s>These variables allow to estimate the value of v and u by v + dt/2 * _k_v and u + dt/2 * _k_u, respectively.</s><s>The equations are again manipulated, by replacing all occurrences of v and u by their estimates at t +dt/2 and finding the corresponding increment using the explicit Euler method.</s><s>This method has a much smaller numerical error and is more stable than the explicit or implicit methods, but requires more computations during the simulation, as the gradient is evaluated twice.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.5.">Event-driven Integration</head><p><s>This method is only available for spiking synapses, if the ODEs are linear (which is the case for the online STDP rule).</s><s>For this method, the equations are not evaluated at each time step, but only when a pre-or post-synaptic spike occurs for a synapse.</s><s>The new value of the variables is then computed exactly, using the time elapsed since the last event.</s><s>Event-driven integration is not yet available for neural equations, as it requires to predict the occurrence of the next spike.</s><s>Future versions of ANNarchy will address this mechanism.</s><s>However, it may only speed simulations up if the network is small and does not generate too many spikes per step <ref type="bibr" target="#b9">(Brette et al., 2007;</ref><ref type="bibr" target="#b36">Morrison et al., 2007)</ref>.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.">OpenMP and CUDA Code Generation</head><p><s>Once the structure of network is known and all equations have been analyzed, the C++code corresponding to the simulation can be generated depending on the desired parallel framework.</s><s>Each simulation step described in Section 3.2 leads to the generation of a code portion for the corresponding populations and projections which is then integrated into the main simulation code.</s><s>Figure <ref type="figure" target="#fig_6">6</ref> shows an example of a code portion for the update of the neural variables of a population pop0 whose 1000 neurons are defined by the neuron model described on The parallel execution of this loop over the available cores is ensured through the addition of an OpenMP #pragma statement.</s></p><p><s>The complete code is pasted in a standard C++file called ANNarchy.cpp</s><s>and compiled using g++ on Linux or clang++ on MacOS X.</s><s>The code generated for the same population in the CUDA framework is more complex, as shown on Figure <ref type="figure" target="#fig_6">6C</ref>.</s><s>The instructions executed on the GPU have to be compiled with the NVIDIA compiler nvcc, so the code is generated in a special file called ANNarchy.cu.</s><s>CUDA code generally consists of two sections: one is intended to run on the CPU (host code) while the other (flagged with the keywords __global__ or __device__) will be executed on the GPU (device code).</s><s>At the beginning of the simulation, the vectors holding population and projection data are transferred to the GPU using the CUDA method cudaMemcpy().</s><s>The CUDA object will work on these copies during the whole simulation and they will be transfered back to the host at the end, allowing the Python script to analyze the results.</s><s>An exception is during the recording of variables: the arrays to be recorded are transferred to the host at each time step, as the amount of memory is usually limited on GPUs.</s></p><p><s>Figure <ref type="figure" target="#fig_6">6C</ref> shows the corresponding host and device code portions: the host code simply calls the device method with a copy of the necessary data.</s><s>The device code updates the passed variables in parallel according to the desired numerical method.</s><s>The same mechanism is used for all steps of the simulation.</s><s>The weighted sum of inputs is for example executed in parallel over blocks of post-synaptic neurons with OpenMP.</s><s>In contrast, parallel reduction is used in the CUDA implementation, as it leads to better performance <ref type="bibr" target="#b16">(Dinkelbach et al., 2012)</ref>.</s><s>The main advantage of this code generation approach is that only the required steps are generated: spike-only mechanisms are skipped for rate-coded networks, as well as mechanisms for synaptic delays or structural plasticity if the network does not define them.</s><s>This allows to minimize the code overhead and improves the readability of the generated code.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Benchmarks</head><p><s>We here report the parallel performance of the neural simulator but do not attempt to study it in all details.</s><s>It is planned to issue future releases of ANNarchy, most improvements concerning the parallel performance.</s><s>Nevertheless, we want to highlight that code generation already allows to obtain a parallel performance comparable to most specialized simulators.</s><s>The OpenMP tests are performed on a Linux machine with 2 Intel XEON X5675 at 3 GHz (12 physical cores in total, with hyperthreading disabled) and 12 GB RAM.</s><s>The CUDA tests are performed on a Linux machine with 2 Intel XEON E5-2650 at 2.6 GHz, 128 GB RAM and a NVIDIA Tesla K20m graphical card.</s><s>The simulation times are measured and averaged over 10 different trials with the same initial conditions (standard deviations are omitted as they are negligible in all cases).</s><s>All scripts used in this section are provided in the Supplementary Material.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Rate-coded Benchmark</head><p><s>To test the parallel performance of rate-coded networks, we used a simple network of two populations composed of N = 1000 (resp.</s><s>4000) neuron each, connected with a all-to-all projection representing 1 (resp.</s><s>16) million connections.</s><s>Each neuron is a simple leaky-integrator of excitatory inputs with a firing rate defined by the ODE tau * dr/dt + r = sum(exc), tau being a global parameter of the population.</s><s>Unlike spiking networks, the simulation time of a rate-coded network does not depend on the activity in the network and the summation of inputs for all-to-all connectivity patterns hugely overcomes the update of neural variables <ref type="bibr" target="#b16">(Dinkelbach et al., 2012)</ref>, so such a simple network is sufficient to exhibit the parallel performance of the simulation.</s><s>As outlined in the introduction, we are not aware of parallel simulators of rate-coded networks which could simply implement this network, so we only present in Figure <ref type="figure">7</ref> the speed-up ratio of the simulation time when using 1-12 threads with OpenMP or when using CUDA as the simulation backend.</s><s>The single-threaded implementation is performed without the OpenMP primitives, so it avoids the small sequential overhead of OpenMP.</s><s>The CUDA implementation uses the default configuration used by ANNarchy (32 threads for the neural variables updates, 192 threads for the weighted sums), but this can be changed by the user.</s></p><p><s>The network with 1000 neurons in each population shows a fairly efficient scaling behavior, while the network with 4000 neurons quickly saturates to a speed-up of approximately 2.9.</s><s>This can be explained by the fact that the connectivity matrix with 16 million synapses (each connection weight being represented by a double floating-point value) cannot fit into the cache, so we have a memory-bound problem where memory transfers between the RAM and the processor limit the efficiency of the parallel implementation on shared-memory systems.</s><s>This limitation is well-known for this kind of operation, especially because of the LIL structure used for the connectivity matrix.</s><s>We chose this structure as it allows easier modification through structural plasticity mechanisms and internal tests showed that a CSR structure does not improve much the performance.</s><s>We will investigate further the influence of data structures on parallel performance.</s><s>The main operation performed here is a matrixvector multiplication.</s><s>The strategy to efficiently parallelize this operation depends on the sparseness of the connectivity matrix.</s><s>Depending on this type, there are multiple methods available, including single-instruction-multiple-data operations (SIMD), FIGURE 7 | Speedup ratio obtained by ANNarchy for a fully connected rate-coded network composed of two populations of 1000 (resp.</s><s>4000) neurons each.</s><s>The speedup ratio is defined by the ratio between the execution time (measured for a simulation of 1 s) of the single-threaded implementation and the one measured when using T threads.</s><s>The single-threaded implementation does not use OpenMP nor CUDA primitives.</s><s>For the OpenMP implementation, the number of threads is varied between 2 and 12.</s><s>For the CUDA implementation, the default configuration of ANNarchy (32 threads for the neural variables updates, 192 threads for the weighted sums) is used.</s><s>The CUDA implementation is run on a different machine for technical reasons, so the single-threaded baseline measured on this machine differs from the one used for OpenMP.</s><s>Nevertheless, only the scaling ratio is interesting here, not the absolute execution times.</s><s>The black line denotes the ideal linear scaling, the blue line the scaling of the network with 1000 neurons, the green one the scaling for 4000 neurons.</s><s>With OpenMP, the scaling for 1000 neurons is slightly sub-optimal, while the one for 4000 neurons saturates quickly at a ratio of 2.9.</s><s>The situation is reversed with CUDA: the network with 1000 neurons only achieves a speedup ratio of 3.8, while the network with 4000 neurons achieves a ratio of 7.15.</s><s>cache blocking, loop unrolling, prefetching and autotuning <ref type="bibr" target="#b51">(Williams et al., 2007;</ref><ref type="bibr" target="#b32">Kelefouras et al., 2015)</ref>.</s><s>Thanks to the code generation approach used in ANNarchy, we will be able in future versions to implement these improvements depending on the known connectivity before compilation.</s></p><p><s>The situation is reversed for the CUDA implementation: the network with 1000 neurons is speeded up by a factor 3.8, while the network with 4000 neurons obtains a speedup of 7.15, more than three times the maximal speedup obtained with OpenMP.</s><s>This confirms our previous work showing that ratecoded networks with a relatively small number of connections might benefit more from a CPU-based implementation, while networks with many connections should be run on a GPU <ref type="bibr" target="#b16">(Dinkelbach et al., 2012)</ref>.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Spiking Benchmark</head><p><s>For spiking networks, we compare the parallel performance of ANNarchy with other neural simulators on the COBA benchmark proposed in <ref type="bibr" target="#b9">Brette et al. (2007)</ref> and based on the model of <ref type="bibr" target="#b49">Vogels and Abbott (2005)</ref>.</s><s>The network is composed of 4000 integrate-and-fire neurons (3200 excitatory and 800 inhibitory) using exponentially-decreasing conductance-based synapses:</s></p><formula xml:id="formula_18">C • dv(t) dt = g L • (E l − v(t)) + g e (t) • (E e − v(t)) (15) +g i (t) • (E i − v(t)) + I τ e • dg e (t) dt = −g e (t) τ i • dg i (t) dt = −g i (t)</formula><p><s>All neurons are randomly connected with a probability of 0.02.</s><s>We implemented this benchmark on ANNarchy (version 4.  <ref type="formula">2014</ref>), the default NEST implementation with RK45 is roughly ten times slower than the modified NEST version with explicit Euler, but both have a very good scaling behavior.</s><s>In the single-threaded version, Brian 2 is much faster than Brian and comparable to ANNarchy, but its scaling behavior is not as optimal as other simulators.</s><s>It should be noted that Brian 2 is still in development, so this result is only preliminary.</s><s>Auryn is almost one order of magnitude faster than the other simulators and with an satisfying scaling behavior (although the number of MPI processes must be a multiple of 2).</s><s>The single-threaded implementation of ANNarchy is in comparison fairly efficient, but the scaling properties could be further improved.</s><s>This is mostly due to the spike propagation mechanism (increasing post-synaptic conductances when a spike is emitted), which scales poorly in comparison to the neural variable updates.</s><s>Future work will investigate different implementations of this mechanism.</s><s><ref type="formula" target="#formula_4">5</ref>) method (noted NEST-RK45), and a patched version using the explicit Euler method (NEST-Euler).</s><s>The simulation times are normalized to show the real-time ratio: a normalized time of 1 means that simulating the network for 1 s takes exactly 1 s of computer time (simulations are run for 10 s).</s><s>Both axes use a logarithmic scale.</s><s>Brian only allows single-threaded simulations.</s><s>Brian 2, NEST and ANNarchy use OpenMP, while Auryn uses MPI (openMPI 1.4.3).</s><s>Auryn only allows a number of processes which is a multiple of 2. The single-threaded version of ANNarchy compares well to other neural simulators, but its scaling properties are not optimal compared to NEST.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Discussion</head><p><s>We have described the core principles of the neural simulator ANNarchy.</s><s>It provides a high-level interface in Python similar to PyNN to facilitate the creation of rate-coded, spike-coded or hybrid neural networks.</s><s>An important set of neuron and synapse models can be implemented with an equation-oriented syntax close to the one proposed by Brian.</s><s>These definitions are used to generate an entire C++library optimized for the underlying parallel framework (OpenMP for shared memory systems, CUDA for GPU cards).</s><s>Different numerical methods are available for solving the possible ODEs.</s><s>Code generation allows complete control over data structures and computational methods, which leads to the execution of fine-tuned and simple code.</s><s>It allows to obtain a parallel performance comparable to specialized simulators.</s></p><p><s>ANNarchy brings the flexibility of the Brian interface to ratecoded networks, while being compatible with state-of-the-art spiking simulators.</s><s>Although several features and concepts for spiking networks are comparable to other simulators (especially Brian 2, <ref type="bibr" target="#b47">Stimberg et al., 2014)</ref>, ANNarchy also provides novel features to the community.</s><s>Structural plasticity can be easily implemented through simple synapse-specific rules.</s><s>Any neural or synaptic variable can be easily recorded during the simulation.</s><s>The network can be easily interfaced to external C/C++libraries through the Cython bindings, so images or video streams can efficiently be fed to the network, or neural activity read to control robots in real-time.</s><s>Automatic reporting allows to generate complete reports in L A T E X about the current network model, including the network structure, the equations used for the neurons and synapses, as well as the different parameters used.</s><s>Brian 2 provides a similar feature as it is also based on Sympy, but only for individual equations.</s><s>Some features are implemented only for rate-coded networks (such as convolution or pooling operations which do not make much sense for spiking networks), but the hybrid ability of ANNarchy allows for example to integrate convoluted rate-coded networks for vision with spiking cognitive models.</s></p><p><s>The chosen equation-oriented approach is very powerful, but has some limitations, some of which are already listed in <ref type="bibr" target="#b47">Stimberg et al. (2014)</ref>.</s><s>The number of explicit neural states is limited to two for spiking neurons (active or refractory) and only one for rate-coded ones.</s><s>However, the syntax allows the use of conditional statements which can modify entirely the properties of a neuron, mimicking additional states.</s><s>The equation-oriented syntax is also limited in its current form to the description of point-neurons, neglecting the effects of the neurons' morphology on their properties.</s><s>Such neurons would require the use of another simulator such as NEURON or GENESIS.</s></p><p><s>As Brian 2 and ANNarchy are based on the principles stated in <ref type="bibr" target="#b47">Stimberg et al. (2014)</ref>, one should highlight the main differences between the two equation-oriented interfaces for spiking networks.</s><s>Brian 2 proposes a powerful mechanism to incrementally build connection matrices by accessing the underlying data structure, possibly through text-based rules.</s><s>It is also possible to dynamically add and remove populations and projections between two simulations.</s><s>This is currently impossible with ANNarchy: all data structures are linked to the generated library and are only indirectly accessible in Python.</s><s>Synapse definition in Brian 2 allows to modify any pre-or post-synaptic neural variable.</s><s>Because of the way the code is generated, ANNarchy only allows the synapse to modify the post-synaptic conductance in addition to synaptic variables.</s><s>Brian 2 allows to solve stochastic differential equations (SDE), while ANNarchy is limited for now to ODEs: one can only use random variables inside an ODE to simulate for example intracellular noise, but this is not a stochastic process.</s><s>Brian 2 allows a finer control on the evolution of neural variables during the refractory period, while ANNarchy freezes all variables during this period except for the conductances.</s><s>SDEs and control over variables during the refractory period will be progressively introduced in future versions.</s><s>On the other hand, ANNarchy proposes a solution to structural plasticity and hetero-synaptic plasticity (through the possible use of global post-synaptic variables in a projection) which could be integrated in Brian 2. It also provides additional control over the evolution of variables, such as their initial value and the minimal or maximal value they can take over the course of a simulation.</s></p><p><s>ANNarchy will be further maintained and new features will be integrated in future releases.</s><s>Learning in rate-coded networks is focused on biologically-plausible rules where all information is local to the synapse, which currently rules out methods such as backpropagation.</s><s>Synaptic delays are currently only implemented between the pre-synaptic neuron and the synapse, while some plasticity models rely on an additional delay between the synapse and the soma of the post-synaptic neuron.</s><s>Exact event-based integration of neural dynamics needs to be implemented <ref type="bibr" target="#b36">(Morrison et al., 2007)</ref>, as it allows to simulate faster low-firing networks of linear neurons.</s><s>Additional numerical methods (such as Runge-Kutta of order 4) will be progressively introduced.</s><s>Computations are limited to an equidistant time grid, as it is the easiest method for rate-coded networks.</s><s>Some networks may nevertheless benefit from adaptive time steps, or of the use of different clocks in different parts of the model.</s><s>This may be particularly useful for hybrid networks, as rate-coded networks often behave well with integration steps of 1 ms, while some spiking networks require at least 0.1 ms.</s><s>Finally, as the chosen interface is very close to PyNN <ref type="bibr" target="#b14">(Davison et al., 2008)</ref>, we will implement a fully compatible interface so that ANNarchy can be used as an alternative simulation backend using the available standard models.</s></p><p><s>As the interface is already stable, there is room for improvement regarding the parallel performance.</s><s>On CPU-based shared memory systems, the OpenMP implementation is efficient for rate-coded networks (in the limit of memory bandwidth), but the spike propagation mechanism does not scale linearly yet, introducing a strong sequential component to the simulation.</s><s>This issue will be investigated in future releases: based on our experiments, simulators using array-based computations (Brian 2, ANNarchy and partially Auryn) tend to scale sub-optimally, while NEST performs better.</s><s>A possible reason for this difference is linked to the object-oriented design of NEST: each thread computes individual neurons, leading to a more cache-friendly access to the variables, especially when using synaptic delays.</s><s>In contrast the array-based approach share neural and synaptic data among several threads and quickly fill the cache.</s><s>The opposite effect seems to be true for the update of neural variables <ref type="bibr" target="#b54">(Zenke and Gerstner, 2014)</ref>.</s><s>Hybrid solutions between array-based and object-oriented implementations might lead to a better parallel performance for spiking networks.</s></p><p><s>Parallel computing on distributed memory systems is also planned.</s><s>The performance of NEST on such systems suggests that this is an interesting solution for spiking networks, although it has been shown that memory transfers might impair scaling already for medium-scale spiking networks <ref type="bibr" target="#b54">(Zenke and Gerstner, 2014)</ref>.</s><s>Communication costs might become a problem for ratecoded networks, as firing rates must be exchanged at each simulation step.</s><s>However, if synaptic data is appropriately distributed on each node, it may increase the total available memory bandwidth, which is an important limiting factor.</s><s>We are currently investigating hybrid MPI/OpenMP solutions which may minimize the communication costs through a structural analysis of the network's topology.</s></p><p><s>The generation of CUDA code for simulation on GPU platforms is still experimental and currently only available for rate-coded networks.</s><s>One major issue is the choice of the correct configuration depending on the network, such as the number of threads per operation (the optimal number of threads for the summation of inputs is different from the one for the update of neural or synaptic variables).</s><s>ANNarchy currently proposes a default configuration which can be overwritten by the user, but we will investigate solutions using auto-tuning of the simulation parameters <ref type="bibr" target="#b16">(Dinkelbach et al., 2012)</ref>.</s></p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>FIGURE 2 |</head><label>2</label><figDesc><div><p><s>FIGURE 2 | Examples of rate-coded neuron and synapse definitions.</s><s>(A) Noisy leaky-integrator rate-coded neuron.</s><s>It defines a global parameter tau for the time constant and a local one B for the baseline firing rate.</s><s>The evolution of the firing rate r over time is rules by an ODE integrating the weighted sum of excitatory inputs sum(exc) and the baseline.</s><s>The random variable is defined by the Uniform(-1.0,</s><s>1.0) term, so that a value is taken from the uniform range [−1, 1] at each time step and for each neuron.</s><s>The initial value at t = 0 of r is set to 1.0 through the init flag and the minimal value of r is set to zero.</s><s>(B) Rate-coded synapse implementing the IBCM learning rule.</s><s>It defines a global parameter tau, which is used to compute the sliding temporal mean of the square of the post-synaptic firing rate in the variable theta.</s><s>This variable has the flag postsynaptic, as it needs to be computed only once per post-synaptic neuron.</s><s>The connection weights w are then updated according to the IBCM rule and limited to positive values through the min=0.0</s><s>flag.</s></p></div></figDesc><graphic coords="4,314.28,334.55,226.80,219.96" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc><div><p><s>pop1 = Population(1, Neuron(equations="r = 1 + sin(2 * pi * t)")) pop2 = PoissonPopulation(100, target='exc') proj = Projection(pop1, pop2, 'exc') proj.connect_all_to_all(1.0)</s></p></div></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc><div><p><s>pop1 = PoissonPopulation(1000, rates=100.0)</s><s>pop2 = Population(1, Neuron(equations="r=sum(exc)")) proj = DecodingProjection(pop1, pop2, 'exc', window=10.0)</s><s>proj.connect_all_to_all(1.0)</s></p></div></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>FIGURE 4 |</head><label>4</label><figDesc><div><p><s>FIGURE 4 | Example of an hybrid network encoding a rate-coded population into a spiking population (PoissonPopulation) and decoded back to the rate-coded domain (DecodingProjection).</s><s>The script for this plot is provided in the Supplementary Material.</s><s>(A) Raster plot of the spiking population reacting to step-wise inputs for 1 s.</s><s>Each step lasts 250 ms (0, 10, 50, and 100 Hz).</s><s>(B) Firing rate of a single rate-coded neuron decoding the corresponding spiking neuron.</s><s>The blue line shows the firing rate in the input population and the green line shows the decoded firing rate.</s><s>It follows the original firing rate with some noise due to the stochastic nature of the spike trains and some delay due to the integration window.</s><s>(C) Relative decoding error (ǫ = 1 250 250 t=0 |r(t)−F| F dt) depending on the number of spiking neurons used for decoding, for different input firing rates (10, 50, and 100 Hz).For small number of neurons, the decoding error is high as individual spike trains are stochastic.</s><s>When the number of neurons is increased (over 200), the decoding error is reduced.</s><s>Decoding is relatively more precise at high frequencies than at low ones.</s></p></div></figDesc><graphic coords="10,54.00,70.04,226.80,353.64" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>FIGURE 5 |</head><label>5</label><figDesc><div><p><s>FIGURE 5 | Example of code generated for the Equation (13) using different numerical methods: 1. Explicit Euler; 2. Implicit Euler; 3. Exponential Euler; 4. Midpoint (Runge-Kutta method of order 2).</s><s>pop0 is a C++ structure holding the different attributes of the population: the vectors v and u for the two variables, the vector g_exc for the excitatory inputs and the double value tau for the time constant.</s><s>All methods compute first the increments _v and _u before adding them to v and u, in order to make sure the update rules use the previous values of these variables.</s><s>The number of elementary operations differs from one method to another, increasing the simulation runtime, but the numerical precision and stability of the more complex methods might be required in some cases.</s></p></div></figDesc><graphic coords="14,54.00,69.46,226.77,315.21" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc><div><p><s>Figure 6A.</s><s>It defines a global parameter tau and the firing rate r is defined by the ODE tau * dr/dt = sum(exc) -r, limited to positive values with the flag min=0.0.</s><s>The OpenMP implementation on Figure6Bis in this case simple: the code snippet corresponding to the ODE (here using the explicit Euler method) is integrated into a for-loop over the 1000 neurons, where the value of each element in the corresponding vector is updated sequentially.</s></p></div></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>FIGURE 6 |</head><label>6</label><figDesc><div><p><s>FIGURE 6 | Code generated for a single population pop0 of 1000 identical neurons.</s><s>(A) Neuron model used for code generation: a global parameter tau and a local variable r following a linear ODE and limited to positive values.</s><s>(B) Code generated for the OpenMP framework.</s><s>The code is pasted into the main C++ code ANNarchy.cpp</s><s>and called at each step.</s><s>It iterates over the 1000 neurons of the population and updates their firing rate depending on the corresponding code snippet.</s><s>It operates directly on the data contained in the structure pop0.</s><s>A simple #pragma statement allows parallel</s></p></div></figDesc><graphic coords="15,56.64,408.43,481.92,212.28" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc><div><p><s>4.0), Brian (version 1.4.1),</s><s>Brian 2 (version 2.0b3), NEST (with Python bindings, version 2.4.2), and Auryn (version 0.4.1).</s><s>As noted in<ref type="bibr" target="#b54">Zenke and Gerstner (2014)</ref>, NEST uses by default the precise but very expensive Runge-Kutta-Fehlberg 4(5) (RK45) numerical method, while Brian and Auryn use the faster explicit Euler method.</s><s>We therefore also applied the patch provided by<ref type="bibr" target="#b54">Zenke and Gerstner (2014)</ref> to force NEST to use the Euler method (noted NEST-Euler as opposed to NEST-RK45).</s><s>The Auryn simulator was modified to use synaptic delays of 0.1 ms.</s><s>The code for Brian 2 uses the cpp_standalone mode to generate efficient C++ code and OpenMP parallel processing.</s><s>All simulations were run using the same parameters, random number generator seeds (for the initial values of the membrane potential) and connectivity matrix (generated as a Scipy sparse matrix and loaded into the different simulators).</s><s>The ANNarchy and Brian implementations produced exactly the same spiking patterns, while the other simulators showed only minor deviations.</s><s>The time needed for 10 s of simulation (excluding building time) was measured using the Python time module, except for Auryn where MPI timer routines were used.The results are shown on Figure8.</s><s>In agreement with the results ofZenke and Gerstner (</s></p></div></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>FIGURE 8 |</head><label>8</label><figDesc><div><p><s>FIGURE 8 | Comparison of the simulation times of different simulators depending on the number of threads on a shared-memory system.</s><s>The parallel performance of the simulators Brian (version 1.4.1),</s><s>Brian 2 (version 2.0b3), NEST (with Python bindings, version 2.4.2),</s><s>Auryn (version 0.4.1), and ANNarchy (version 4.4.0)</s><s>are investigated up to 12 threads.</s><s>Two versions of NEST are used: one using the Runge-Kutta-Fehlberg 4(5) method (noted NEST-RK45), and a patched version using the explicit Euler method (NEST-Euler).</s><s>The simulation times are normalized to show the real-time ratio: a normalized time of 1 means that simulating the network for 1 s takes exactly 1 s of computer time (simulations are run for 10 s).</s><s>Both axes use a logarithmic scale.</s><s>Brian only allows single-threaded simulations.</s><s>Brian 2, NEST and ANNarchy use OpenMP, while Auryn uses MPI (openMPI 1.4.3).</s><s>Auryn only allows a number of processes which is a multiple of 2. The single-threaded version of ANNarchy compares well to other neural simulators, but its scaling properties are not optimal compared to NEST.</s></p></div></figDesc><graphic coords="17,314.28,69.28,226.80,212.40" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc><div><p></p></div></figDesc><graphic coords="3,54.00,351.31,226.80,231.60" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc><div><p></p></div></figDesc><graphic coords="5,68.69,122.84,457.82,372.89" type="bitmap" /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">The GeNN project, http://sourceforge.net/projects/genn/.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">http://bitbucket.org/annarchy/annarchy and http://annarchy.readthedocs.org.Frontiers in Neuroinformatics | www.frontiersin.org</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">July 2015 | Volume 9 | Article 19</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">Frontiers in Neuroinformatics | www.frontiersin.org</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p><s>The authors would like to thank Javier Baladron for useful discussions and suggestions.</s><s>Parts of this work have been supported by the German Research Foundation/DFG grant HA2630/4-2 (Geschäftszeichen INST 270/221-1 FUGG), the European Project FP7-NBIS "Spatial Cognition" (grant no.</s><s>600785) and the Graduiertenkolleg Crossworlds (DFG GRK 1780/1).</s><s>The publication costs of this article were funded by the German Research Foundation/DFG (Geschäftszeichen INST 270/219-1) and the Chemnitz University of Technology in the funding program Open Access Publishing.</s></p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Author Contributions</head><p><s>JV and HD designed and wrote the library.</s><s>JV wrote primarily the article and performed the tests.</s><s>FH supervised the development and participated in the writing.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Supplementary Material</head><p><s>The Supplementary Material for this article can be found online at: http://journal.frontiersin.org/article/10.3389/fninf.</s></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2015.00019</head><p><s>Conflict of Interest Statement: The authors declare that the research was conducted in the absence of any commercial or financial relationships that could be construed as a potential conflict of interest.</s></p><p><s>Copyright © 2015 Vitay, Dinkelbach and Hamker.</s><s>This is an open-access article distributed under the terms of the Creative Commons Attribution License (CC BY).</s><s>The use, distribution or reproduction in other forums is permitted, provided the original author(s) or licensor are credited and that the original publication in this journal is cited, in accordance with accepted academic practice.</s><s>No use, distribution or reproduction is permitted which does not comply with these terms.</s></p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The emergent neural modeling system</title>
		<author>
			<persName><forename type="first">B</forename><surname>Aisa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mingus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Reilly</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.neunet.2008.06.016</idno>
	</analytic>
	<monogr>
		<title level="j">Neural Netw</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="1146" to="1152" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Topographica: building and analyzing map-level simulations from python, C/C++, MATLAB, NEST, or NEURON components</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Bednar</surname></persName>
		</author>
		<idno type="DOI">10.3389/neuro.11.008.2009</idno>
	</analytic>
	<monogr>
		<title level="j">Front. Neuroinform</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">8</biblScope>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Cython tutorial</title>
		<author>
			<persName><forename type="first">S</forename><surname>Behnel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Bradshaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Seljebotn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 8th Python Science Conference</title>
				<editor>
			<persName><forename type="first">G</forename><surname>Varoquaux</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Van Der Walt</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Millman</surname></persName>
		</editor>
		<meeting>8th Python Science Conference<address><addrLine>Pasadena, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="4" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Nengo: a Python tool for building large-scale functional brain models</title>
		<author>
			<persName><forename type="first">T</forename><surname>Bekolay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bergstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Hunsberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Dewolf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">C</forename><surname>Stewart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Rasmussen</surname></persName>
		</author>
		<idno type="DOI">10.3389/fninf.2013.00048</idno>
	</analytic>
	<monogr>
		<title level="j">Front. Neuroinform</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page">48</biblScope>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A mechanistic cortical microcircuit of attention for amplification, normalization and suppression</title>
		<author>
			<persName><forename type="first">F</forename><surname>Beuth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">H</forename><surname>Hamker</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.visres.2015.04.004</idno>
	</analytic>
	<monogr>
		<title level="j">Vision Res</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
	<note>Epub ahead of print</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Theory of the development of neuron selectivity: orientation specificity and binocular interaction in visual cortex</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Bienenstock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">N</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">W</forename><surname>Munroe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Neurosci</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="32" to="48" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Constructing realistic neural simulations with GENESIS</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Bower</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Beeman</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-1-59745-520-6/7</idno>
	</analytic>
	<monogr>
		<title level="j">Methods Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">401</biblScope>
			<biblScope unit="page" from="103" to="125" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Vectorized algorithms for spiking neural network simulation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Brette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">F M</forename><surname>Goodman</surname></persName>
		</author>
		<idno type="DOI">10.1162/NECO/a/00123</idno>
	</analytic>
	<monogr>
		<title level="j">Neural Comput</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="1503" to="1535" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Simulating spiking neural networks on GPU</title>
		<author>
			<persName><forename type="first">R</forename><surname>Brette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">F M</forename><surname>Goodman</surname></persName>
		</author>
		<idno type="DOI">10.3109/0954898X.2012.730170</idno>
	</analytic>
	<monogr>
		<title level="j">Network</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="167" to="182" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Simulation of networks of spiking neurons: a review of tools and strategies</title>
		<author>
			<persName><forename type="first">R</forename><surname>Brette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Carnevale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hines</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Beeman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Bower</surname></persName>
		</author>
		<idno type="DOI">10.1007/s10827-007-0038-6</idno>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Neurosci</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="349" to="398" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Activity-dependent structural plasticity</title>
		<author>
			<persName><forename type="first">M</forename><surname>Butz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Wörgötter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Van Ooyen</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.brainresrev.2008.12.023</idno>
	</analytic>
	<monogr>
		<title level="j">Brain Res. Rev</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="page" from="287" to="305" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Normalization as a canonical neural computation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Carandini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Heeger</surname></persName>
		</author>
		<idno type="DOI">10.1038/nrn3136</idno>
	</analytic>
	<monogr>
		<title level="j">Nat. Rev. Neurosci</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="51" to="62" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">An efficient automated parameter tuning framework for spiking neural networks</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">D</forename><surname>Carlson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Nageswaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Dutt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Krichmar</surname></persName>
		</author>
		<idno type="DOI">10.3389/fnins.2014.00010</idno>
	</analytic>
	<monogr>
		<title level="j">Front. Neurosci</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">10</biblScope>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Methods for estimating neural firing rates, and their application to brain-machine interfaces</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Cunningham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Gilja</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">I</forename><surname>Ryu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">V</forename><surname>Shenoy</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.neunet.2009.02.004</idno>
	</analytic>
	<monogr>
		<title level="j">Neural Netw</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="1235" to="1246" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">PyNN: a common interface for neuronal network simulators</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Davison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Brüderle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Eppler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kremkow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Muller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pecevski</surname></persName>
		</author>
		<idno type="DOI">10.3389/neuro.11.011.2008</idno>
	</analytic>
	<monogr>
		<title level="j">Front. Neuroinform</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">11</biblScope>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Theoretical Neuroscience: Computational and Mathematical Modeling of Neural Systems</title>
		<author>
			<persName><forename type="first">P</forename><surname>Dayan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Abbott</forename></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">F</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>The MIT Press</publisher>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Comparison of GPU-and CPU-implementations of mean-firing rate neural networks on parallel hardware</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">U</forename><surname>Dinkelbach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vitay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Beuth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">H</forename><surname>Hamker</surname></persName>
		</author>
		<idno type="DOI">10.3109/0954898X.2012.739292</idno>
	</analytic>
	<monogr>
		<title level="j">Network</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="212" to="236" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The connection-set algebra-a novel formalism for the representation of connectivity structure in neuronal network models</title>
		<author>
			<persName><forename type="first">M</forename><surname>Djurfeldt</surname></persName>
		</author>
		<idno type="DOI">10.1007/s12021-012-9146-1</idno>
	</analytic>
	<monogr>
		<title level="j">Neuroinformatics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="287" to="304" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Dopaminergic and nondopaminergic value systems in conditioning and outcome-specific revaluation</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Dranias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Grossberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bullock</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.brainres.2008.07.013</idno>
	</analytic>
	<monogr>
		<title level="j">Brain Res</title>
		<imprint>
			<biblScope unit="volume">1238</biblScope>
			<biblScope unit="page" from="239" to="287" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A large-scale model of the functioning brain</title>
		<author>
			<persName><forename type="first">C</forename><surname>Eliasmith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">C</forename><surname>Stewart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Choo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Bekolay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Dewolf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Tang</surname></persName>
		</author>
		<idno type="DOI">10.1126/science.1225266</idno>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">338</biblScope>
			<biblScope unit="page" from="1202" to="1205" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">PyNEST: a convenient interface to the NEST simulator</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Eppler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Helias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Muller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Diesmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-O</forename><surname>Gewaltig</surname></persName>
		</author>
		<idno type="DOI">10.3389/neuro.11.012.2008</idno>
	</analytic>
	<monogr>
		<title level="j">Front. Neuroinform</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">12</biblScope>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">NeMo: a platform for neural modelling of spiking neurons using GPUs</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Fidjeland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">B</forename><surname>Roesch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Shanahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Luk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2009 20th IEEE International Conference Application-specific Systems Architectures and Processors</title>
				<meeting><address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="137" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">An approach to the quantitative analysis of electrophysiological data from single neurons</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">L</forename><surname>Gerstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">Y</forename><surname>Kiang</surname></persName>
		</author>
		<idno type="DOI">10.1016/S0006-3495(60)86872-5</idno>
	</analytic>
	<monogr>
		<title level="j">Biophys. J</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="15" to="28" />
			<date type="published" when="1960">1960</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A neuronal learning rule for sub-millisecond temporal coding</title>
		<author>
			<persName><forename type="first">W</forename><surname>Gerstner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kempter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Van Hemmen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wagner</surname></persName>
		</author>
		<idno type="DOI">10.1038/383076a0</idno>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">383</biblScope>
			<biblScope unit="page" from="76" to="81" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">NEST (NEural Simulation Tool)</title>
		<author>
			<persName><forename type="first">M.-O</forename><surname>Gewaltig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Diesmann</surname></persName>
		</author>
		<idno type="DOI">10.4249/scholarpedia.1430</idno>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">1430</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Brian: a simulator for spiking neural networks in python</title>
		<author>
			<persName><forename type="first">D</forename><surname>Goodman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Brette</surname></persName>
		</author>
		<idno type="DOI">10.3389/neuro.11.005.2008</idno>
	</analytic>
	<monogr>
		<title level="j">Front. Neuroinform</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">5</biblScope>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Code generation: a strategy for neural network simulators</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">F M</forename><surname>Goodman</surname></persName>
		</author>
		<idno type="DOI">10.1007/s12021-010-9082-x</idno>
	</analytic>
	<monogr>
		<title level="j">Neuroinformatics</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="183" to="196" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Predictions of a model of spatial attention using sum-and max-pooling functions</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">H</forename><surname>Hamker</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.neucom.2003.09.006</idno>
	</analytic>
	<monogr>
		<title level="j">Neurocomputing</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="page" from="329" to="343" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">The NEURON simulation environment</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Hines</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">T</forename><surname>Carnevale</surname></persName>
		</author>
		<idno type="DOI">10.1162/neco.1997.9.6.1179</idno>
	</analytic>
	<monogr>
		<title level="j">Neural Comput</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="1179" to="1209" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Objective function formulation of the BCM theory of visual cortical plasticity: statistical connections, stability conditions</title>
		<author>
			<persName><forename type="first">N</forename><surname>Intrator</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">N</forename><surname>Cooper</surname></persName>
		</author>
		<idno type="DOI">10.1016/S0893-6080(05)80003-6</idno>
	</analytic>
	<monogr>
		<title level="j">Neural Netw</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="3" to="17" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Simple model of spiking neurons</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Izhikevich</surname></persName>
		</author>
		<idno type="DOI">10.1109/TNN.2003.820440</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Neural Netw</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="1569" to="1572" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Open source computer algebra systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Joyner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Čertík</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Meurer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">E</forename><surname>Granger</surname></persName>
		</author>
		<idno type="DOI">10.1145/2110170.2110185</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Commun. Comput. Algebr</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page">225</biblScope>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A methodology for speeding up matrix vector multiplication for single/multi-core architectures</title>
		<author>
			<persName><forename type="first">V</forename><surname>Kelefouras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kritikakou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Papadima</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Goutis</surname></persName>
		</author>
		<idno type="DOI">10.1007/s11227-015-1409-9</idno>
	</analytic>
	<monogr>
		<title level="j">J. Supercomput</title>
		<imprint>
			<biblScope unit="volume">71</biblScope>
			<biblScope unit="page" from="2644" to="2667" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Gradient-based learning applied to document recognition</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bottou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Haffner</surname></persName>
		</author>
		<idno type="DOI">10.1109/5.726791</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE</title>
				<meeting>IEEE</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="page" from="2278" to="2324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Regulation of synaptic efficacy by coincidence of postsynaptic APs and EPSPs</title>
		<author>
			<persName><forename type="first">H</forename><surname>Markram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lubke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Frotscher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Sakmann</surname></persName>
		</author>
		<idno type="DOI">10.1126/science.275.5297.213</idno>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">275</biblScope>
			<biblScope unit="page" from="213" to="215" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Differential signaling via the same axon of neocortical pyramidal neurons</title>
		<author>
			<persName><forename type="first">H</forename><surname>Markram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tsodyks</surname></persName>
		</author>
		<idno type="DOI">10.1073/pnas.95.9.5323</idno>
	</analytic>
	<monogr>
		<title level="j">Proc. Natl. Acad. Sci. U.S.A</title>
		<imprint>
			<biblScope unit="volume">95</biblScope>
			<biblScope unit="page" from="5323" to="5328" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Exact subthreshold integration with continuous spike times in discretetime neural network simulations</title>
		<author>
			<persName><forename type="first">A</forename><surname>Morrison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Straube</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">E</forename><surname>Plesser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Diesmann</surname></persName>
		</author>
		<idno type="DOI">10.1162/neco.2007.19.1.47</idno>
	</analytic>
	<monogr>
		<title level="j">Neural Comput</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="47" to="79" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">CNS: a GPU-based Framework for Simulating Cortically-organized Networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mutch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Knoblich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Poggio</surname></persName>
		</author>
		<idno>MIT-CSAIL- TR-2010-013 / CBCL-286</idno>
		<imprint>
			<date type="published" when="2010">2010</date>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Massachusetts Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Single-trial estimation of neuronal rates: from single-neuron spike trains to population activity</title>
		<author>
			<persName><forename type="first">M</forename><surname>Nawrot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aertsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rotter</surname></persName>
		</author>
		<idno type="DOI">10.1016/S0165-0270(99)00127-2</idno>
	</analytic>
	<monogr>
		<title level="j">J. Neurosci. Methods</title>
		<imprint>
			<biblScope unit="volume">94</biblScope>
			<biblScope unit="page" from="81" to="92" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Towards reproducible descriptions of neuronal network models</title>
		<author>
			<persName><forename type="first">E</forename><surname>Nordlie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-O</forename><surname>Gewaltig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">E</forename><surname>Plesser</surname></persName>
		</author>
		<idno type="DOI">10.1371/journal.pcbi.1000456</idno>
	</analytic>
	<monogr>
		<title level="j">PLoS Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page">e1000456</biblScope>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">A simplified neuron model as a principal component analyze</title>
		<author>
			<persName><forename type="first">E</forename><surname>Oja</surname></persName>
		</author>
		<idno type="DOI">10.1007/BF00275687</idno>
	</analytic>
	<monogr>
		<title level="j">J. Math. Biol</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="267" to="273" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Making working memory work: a computational model of learning in the prefrontal cortex and basal ganglia</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>O'reilly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Frank</surname></persName>
		</author>
		<idno type="DOI">10.1162/089976606775093909</idno>
	</analytic>
	<monogr>
		<title level="j">Neural Comput</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="283" to="328" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Hierarchical models of object recognition in cortex</title>
		<author>
			<persName><forename type="first">M</forename><surname>Riesenhuber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Poggio</surname></persName>
		</author>
		<idno type="DOI">10.1038/14819</idno>
	</analytic>
	<monogr>
		<title level="j">Nat. Neurosci</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="1019" to="1025" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">DANA: distributed numerical and adaptive modelling framework. Network 237-253</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Rougier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Fix</surname></persName>
		</author>
		<idno type="DOI">10.3109/0954898X.2012.721573</idno>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Dysfunctional and compensatory synaptic plasticity in Parkinson&apos;s disease</title>
		<author>
			<persName><forename type="first">H</forename><surname>Schroll</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vitay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">H</forename><surname>Hamker</surname></persName>
		</author>
		<idno type="DOI">10.1111/ejn.12434</idno>
	</analytic>
	<monogr>
		<title level="j">Eur. J. Neurosci</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="688" to="702" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Estimating instantaneous irregularity of neuronal firing</title>
		<author>
			<persName><forename type="first">T</forename><surname>Shimokawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shinomoto</surname></persName>
		</author>
		<idno type="DOI">10.1162/neco.2009.08-08-841</idno>
	</analytic>
	<monogr>
		<title level="j">Neural Comput</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<date type="published" when="1931">2009. 1931-1951</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Competitive Hebbian learning through spike-timing-dependent synaptic plasticity</title>
		<author>
			<persName><forename type="first">S</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">D</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Abbott</forename></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">F</forename></persName>
		</author>
		<idno type="DOI">10.1038/78829</idno>
	</analytic>
	<monogr>
		<title level="j">Nat. Neurosci</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="919" to="926" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Equationoriented specification of neural models for simulations</title>
		<author>
			<persName><forename type="first">M</forename><surname>Stimberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">F M</forename><surname>Goodman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Benichoux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Brette</surname></persName>
		</author>
		<idno type="DOI">10.3389/fninf.2014.00006</idno>
	</analytic>
	<monogr>
		<title level="j">Front. Neuroinform</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">6</biblScope>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">The NumPy array: a structure for efficient numerical computation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Thibeault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hoang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">C</forename><surname>Harris</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Van Der Walt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Colbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varoquaux</surname></persName>
		</author>
		<idno type="DOI">10.1109/MCSE.2011.37</idno>
	</analytic>
	<monogr>
		<title level="m">3rd International Conference on Bioinformatics and Computational Biology</title>
				<meeting><address><addrLine>New Orleans, LA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011. BICoB 2011. 2011</date>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="22" to="30" />
		</imprint>
	</monogr>
	<note>A Novel Multi-GPU Neural Simulator</note>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Signal propagation and logic gating in networks of integrate-and-fire neurons</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">P</forename><surname>Vogels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Abbott</forename></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">F</forename></persName>
		</author>
		<idno type="DOI">10.1523/JNEUROSCI.3508-05.2005</idno>
	</analytic>
	<monogr>
		<title level="j">J. Neurosci</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="10786" to="10795" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Probabilistic decision making by slow reverberation in cortical circuits</title>
		<author>
			<persName><forename type="first">X.-J</forename><surname>Wang</surname></persName>
		</author>
		<idno type="DOI">10.1016/S0896-6273(02)01092-9</idno>
	</analytic>
	<monogr>
		<title level="j">Neuron</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="955" to="968" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Optimization of sparse matrix-vector multiplication on emerging multicore platforms</title>
		<author>
			<persName><forename type="first">S</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Oliker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Vuduc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shalf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Yelick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Demmel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2007 ACM/IEEE Conference on Supercomputing -SC &apos;07</title>
				<meeting>the 2007 ACM/IEEE Conference on Supercomputing -SC &apos;07<address><addrLine>NewYork, NY</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Modeling and decoding motor cortical activity using a switching Kalman filter</title>
		<author>
			<persName><forename type="first">W</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mumford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Bienenstock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Donoghue</surname></persName>
		</author>
		<idno type="DOI">10.1109/TBME.2004.826666</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Biomed. Eng</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="page" from="933" to="942" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">CyNEST: a maintainable Cythonbased interface for the NEST simulator</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">V</forename><surname>Zaytsev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Morrison</surname></persName>
		</author>
		<idno type="DOI">10.3389/fninf.2014.00023</idno>
	</analytic>
	<monogr>
		<title level="j">Front. Neuroinform</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">23</biblScope>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Limits to high-speed simulations of spiking neural networks using general-purpose computers</title>
		<author>
			<persName><forename type="first">F</forename><surname>Zenke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Gerstner</surname></persName>
		</author>
		<idno type="DOI">10.3389/fninf.2014.00076</idno>
	</analytic>
	<monogr>
		<title level="j">Front. Neuroinform</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">76</biblScope>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Split of spatial attention as predicted by a systems-level model of visual attention</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zirnsak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Beuth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">H</forename><surname>Hamker</surname></persName>
		</author>
		<idno type="DOI">10.1111/j.1460-9568.2011.07718.x</idno>
	</analytic>
	<monogr>
		<title level="j">Eur. J. Neurosci</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="2035" to="2045" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
